<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>alazymachine</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                标签
            </a>
            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">alazymachine's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/08/21/aeg-reviwer/">AEG_reviwer</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-08-21</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs"><a href="#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs" class="headerlink" title="Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h2><hr>
<p>文章贡献：</p>
<ul>
<li>提出了primitive-crucialbehaviors analysis  ，该方法用于在符号执行过程中查找关键执行结构</li>
<li>利用模糊测试和符号执行设计了一套攻击原语确定方法</li>
<li>设计DEPA方法用于检测堆溢出相关原语</li>
</ul>
<p>文章提出了一种新的堆溢出漏洞原语的查找方法DEPA，基于以下两种技术：</p>
<ul>
<li>primitive-crucial-behavior analysis module <ul>
<li>该模块对目标程序进行符号执行，在执行过程中进行primitive-crucial-behavior analysis（关键原语行为分析）</li>
<li>primitive-crucial-behavior   ：实现原语的关键结构，此类结构往往与程序语义以及系统API有关<ul>
<li>如何精准识别这些结构？</li>
<li>如何利用该结构进行漏洞的发现？</li>
</ul>
</li>
</ul>
</li>
<li>exploit primitive determination method  ：</li>
</ul>
<p><strong>事件循环驱动（event loop driven）</strong>：例如通过交互式进行功能分发的程序，此类程序在一次运行过程中接收一次输入，选择一种处理方式，而后结束。在对此类程序分析的过程中很难使用fuzzing或者符号执行的方法来探索程序的深层状态。</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/08/03/android-framework/">android_framework</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-08-03</span>
                
            </div>
            <div class="post-content">
                
                    
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/07/20/go-reverse/">go_reverse</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-07-20</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="GO-reverse"><a href="#GO-reverse" class="headerlink" title="GO  reverse"></a>GO  reverse</h2><hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​	GO语言是谷歌开发的强类型静态静态语言，其编译出的汇编代码与 C/ C++语言存在极大的差异。本身Go在编译过程中将所有的库函数和第三方包都进行了静态的打包操作，还打包进去了自身的runtime和（Garbage Collection， 垃圾回收）模块部分代码，导致其编译后的二进制文件体积十分庞大，存在较大的分析难度。</p>
<h3 id="Go语言特性"><a href="#Go语言特性" class="headerlink" title="Go语言特性"></a>Go语言特性</h3><ul>
<li><strong>独有的数据表示方式</strong>： 例如String类型使用，（start_address，length）二元组进行表示，导致其在进行函数调用时，传入的内容由原本C中的字符串地址变为了两个参数。</li>
<li><strong>独有的栈管理机制</strong>：Go语言中的栈使用continue stack机制，每个runtime在初始状态下分配一个较小的区域当做栈，每次运行时如果栈不够用了就再申请一个更大的栈，将旧栈中的内容复制进去。</li>
<li><strong>全静态链接</strong>：程序中并不按照函数名对库函数进行动态使用，而是进行全静态链接，在没有调试信息和符号表的情况下调试难度很大</li>
<li><strong>独有的函数调用机制</strong>：Go语言函数中的callee的栈空间由caller来进行管理，caller在进入callee之前预先将栈中把参数留出，同时还要给返回值留出栈空间</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL21lbWJlci5odG1sP21lbWJlcklkPTEyMjA3OQ==">https://www.anquanke.com/member.html?memberId=122079</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5UYzJNRFl4TXc9PSZtaWQ9MjQ1ODM4NzExNiZpZHg9MSZzbj1jNjY4ZGFlYTMwYmM5ZGNlOGQ3OWQzMTZlOTM5OTNlNCZjaGtzbT1iMThmMzIyNjg2ZjhiYjMwZTgxYjc0NjQ0NmYwOGRjZDM4MWE1ODhiNWMwYzZiODQyMDA3Y2M4MjJhODc1YmQ1ZWQxNGMyZDc0ZDZhJnNjZW5lPTI3">https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458387116&amp;idx=1&amp;sn=c668daea30bc9dce8d79d316e93993e4&amp;chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&amp;scene=27</span></p>
<p><span class="exturl" data-url="aHR0cDovL2xlYW5vdGUuY29tL2Jsb2cvcG9zdC81YzY0YmIyYmFiNjQ0MTUxNjcwMDBmNDg=">http://leanote.com/blog/post/5c64bb2bab64415167000f48</span></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/07/20/android-basic/">Android_Basic</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-07-20</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="本文用于介绍安卓基础架构以及安卓安全的学习方法及路线"><a href="#本文用于介绍安卓基础架构以及安卓安全的学习方法及路线" class="headerlink" title="本文用于介绍安卓基础架构以及安卓安全的学习方法及路线"></a>本文用于介绍安卓基础架构以及安卓安全的学习方法及路线</h2><ul>
<li>采用课程与笔记相结合的方式</li>
<li>移动安全课程<ul>
<li>看完这些课程就行，每天一节，方便以后找工作</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5iNDExZjc3Ny8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=">https://www.bilibili.com/video/BV1nb411f777/?spm_id_from=333.337.search-card.all.click</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXQzNDExdTdjcC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=">https://www.bilibili.com/video/BV1t3411u7cp/?spm_id_from=333.337.search-card.all.click</span></li>
</ul>
</li>
</ul>
<h3 id="安卓程序的代码加载顺序"><a href="#安卓程序的代码加载顺序" class="headerlink" title="安卓程序的代码加载顺序"></a>安卓程序的代码加载顺序</h3><p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223143885.png" alt="image-20231122223143885"></p>
<p>java层在使用native层函数时，首先要使用system.loadLibrary函数，最终调用dlopen去加载文件</p>
<p>在加载成功后首先会加载.init函数和在.init_array列表中的函数，然后再进行程序主要逻辑的执行，这些函数中包含了对程序中的解密，解压缩等操作，应该重点关注。后面就是正常的start和main</p>
<p>JNI_Onload对jni进行初始化，让native层执行java层的代码</p>
<p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223818379.png" alt="image-20231122223818379"></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/07/14/clash-build/">clash_build</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-07-14</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Clash-Install"><a href="#Clash-Install" class="headerlink" title="Clash Install"></a>Clash Install</h2><hr>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载clash</span>
<span class="token function">wget</span> <span class="token parameter variable">-O</span> clash.gz https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz
<span class="token comment"># 解压</span>
gunzip <span class="token parameter variable">-d</span> clash.gz
<span class="token function">sudo</span> <span class="token function">chmod</span> +x clash
<span class="token function">sudo</span> <span class="token function">mkdir</span> /opt/clash
<span class="token function">sudo</span> <span class="token function">mv</span> clash /opt/clash
<span class="token builtin class-name">cd</span> /opt/clash
<span class="token comment"># 下载配置文件</span>
<span class="token function">sudo</span> <span class="token function">wget</span> https://github.com/Dreamacro/maxmind-geoip/releases/download/20230612/Country.mmdb
<span class="token comment"># config.yaml中存放的是</span>
<span class="token comment"># 这里的配置文件需要clash的订阅文件，可以在客户端里找到</span>
<span class="token function">mv</span> /home/harry/1688348600374.yml ./config.yaml 
./clash <span class="token parameter variable">-f</span> config.yaml
<span class="token comment"># 保证clash后台运行</span>
<span class="token function">cp</span> Country.mmdb config.yaml ~/.config/clash
<span class="token function">nohup</span> ./clash <span class="token parameter variable">-f</span> config.yaml <span class="token operator">&amp;</span>
<span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> clash

<span class="token comment"># 设置代理</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://127.0.0.1:7890 
<span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://127.0.0.1:7890
<span class="token comment"># 里面编辑上述内容</span>
<span class="token function">sudo</span> <span class="token function">vim</span> ~/.bashrc
<span class="token builtin class-name">source</span> ~/.bashrc
<span class="token comment"># 如果想取消就是用下面命令</span>
<span class="token builtin class-name">unset</span> http_proxy
<span class="token builtin class-name">unset</span> https_proxy
 <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>/depot_tools:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h3><h4 id="重启后没有图形化界面"><a href="#重启后没有图形化界面" class="headerlink" title="重启后没有图形化界面"></a>重启后没有图形化界面</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 重新安装图形化界面</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">--reinstall</span> ubuntu-desktop
<span class="token comment"># 一般执行完上面一条就进去了</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> unity
<span class="token function">sudo</span> <span class="token function">service</span> lightdm resta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="建立python与python3之间的软连接"><a href="#建立python与python3之间的软连接" class="headerlink" title="建立python与python3之间的软连接"></a>建立python与python3之间的软连接</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/bin/python3 /usr/bin/python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/07/13/kernel-pwn/">kernel_pwn</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-07-13</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Kernel-PWN"><a href="#Kernel-PWN" class="headerlink" title="Kernel PWN"></a>Kernel PWN</h2><hr>
<p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016734.png" alt="image-20230713204349079"></p>
<h3 id="内核保护技术"><a href="#内核保护技术" class="headerlink" title="内核保护技术"></a>内核保护技术</h3><ul>
<li><p><strong>SMAP/SMEP</strong>: </p>
<ul>
<li><em>arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。</em><ul>
<li>SMAP(Supervisor Mode Access Prevention，管理模式访问保护): 禁止内核访问用户空间数据</li>
<li>SMEP(Supervisor Mode Execution Prevention，管理模式执行保护): 禁止内核访问用户代码区域</li>
<li>使用cat /proc/cpuinfo指令查看当前程序中存在的SMAP/SMEP功能是否支持，<strong>win8之后开始支持SMEP，并且在RC4中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址来绕过</strong>。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</li>
</ul>
</li>
<li>ret2User: 在没有SMAP/SMEP保护的情况下将内核指针重定向到用户空间进行漏洞利用</li>
<li>ret2dir:  physmap区域由内核管理并且由虚拟地址直接映射到物理地址。（也就时可以直接访问实际物理内存的内容）。在用户进行vmmap操作的时候，有很大概率能够将当前内存写入到该物理内存中，而内核又是可以直接访问该区域的，因此可以bypass SMAP/SMEP 参考文献： <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zYzY2MmI2MTYzYTc=">https://www.jianshu.com/p/3c662b6163a7</span></li>
</ul>
</li>
<li><p><strong>stack protector</strong>:  在编译内核时选择<em>CONFIG_CC_STACKPROTECTOR</em>选项开启该保护，功能类似canary</p>
</li>
<li><p><strong>Kernel Address Display Restrict</strong> ：限制内核地址显示，当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>
</li>
<li><h3 id="Kernel-Address-Space-Layout-Randomisation："><a href="#Kernel-Address-Space-Layout-Randomisation：" class="headerlink" title="Kernel Address Space Layout Randomisation："></a>Kernel Address Space Layout Randomisation：</h3><ul>
<li>内存地址随机化，类似一般程序中的地址随机化，只不过是发生在内核</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">commit_creds</span><span class="token punctuation">(</span><span class="token function">prepare_kernel_cred</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// prepare_kernel_cred(0) 用0为参数生成一个root权限的结构体，并将其传递给commit_creds</span>
<span class="token comment">// commit_creds 用于将当前结构体设置为当前程序的凭证</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="安装qemu启动一个Linux内核调试试一下"><a href="#安装qemu启动一个Linux内核调试试一下" class="headerlink" title="安装qemu启动一个Linux内核调试试一下"></a>安装qemu启动一个Linux内核调试试一下</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><span class="exturl" data-url="aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjYyNDI1Lmh0bQ==">https://bbs.kanxue.com/thread-262425.htm</span></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/07/04/bopc-data-only-attack/">BOPC_Data_Only_Attack</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-07-04</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Block-Oriented-Programming-Automating-Data-Only-Attacks"><a href="#Block-Oriented-Programming-Automating-Data-Only-Attacks" class="headerlink" title="Block Oriented Programming: Automating Data-Only Attacks"></a>Block Oriented Programming: Automating Data-Only Attacks</h2><hr>
<p>目的： 能够依照代码块组指出包含特定语义的结构。构造出了一种自己的语言SPL，生成SPL payload来组织成特定的语义。</p>
<p>前提： 一个任意内存写原语（能够向任意位置中写入任意值），一个任意内存读原语（可选），以及执行完上述两个原语后自然到达的位置。（其实本质上来讲改文章的贡献在于如何充分利用给一个AWP(任意内存写原语)</p>
<p>流程：</p>
<ul>
<li>BOPC提供了一个面向exploit编程的语言SPL，使分析人员能够定义一个独立于目标问题和底层架构的exploit</li>
<li>在目标程序中搜索相应的功能块作为基本块</li>
<li>搜索Dispatcher块用于将各个功能块链接在一起</li>
<li>依照AWP构造出相应的BOP链的payload</li>
</ul>
<p>关键技术：</p>
<p><strong>Block Oriented Programming</strong>：</p>
<ul>
<li>BOP链由表示一条SPL语义的BOP gadget和链接这些BOP gadget的DIspatcher组成</li>
<li>将每个基本块抽象为块约束摘要便于与SPL语言的一一对应。但是由于进入该块的时候上下文的不同，每一个块可能会表现出不同的功能（这里怎么进行抽象的？</li>
<li>构造BOP链本身是NP难的问题</li>
</ul>
<p><strong>Block Constraint Summaries</strong>：  </p>
<p>​	将程序的输入映射到程序执行路径是NP难的问题，<strong>使用启发式的方法帮助查找路径中所有可能的路径</strong>。</p>
<ul>
<li><p>对单个块做符号执行，收集约束，做出输入与输出之间的映射关系。</p>
</li>
<li><p>要查找块和SPL语句之间的匹配，块必须执行该SPL语句所需的所有操作。</p>
</li>
<li><p>BOPC依照语义计算一组候选功能块和相应的分发器，但是很可能选出的几个gadget之间并不存在合法的路径，或者符合CFI的路径</p>
</li>
<li><p>BOP gadget依照选取的块不同，其本身也是不稳定的，前面的gadget很可能会改变后面gadget的性质，同时不断增加gadget也会增加当前路径的约束</p>
</li>
</ul>
<p><strong>解决方案</strong>：BOPC使用当前程序的BOP块的接近度用于评分排序，以及delta图来组织BOP gadget序列</p>
<ul>
<li><strong>BOP块接近度</strong>：</li>
<li><strong>delta图</strong>：用于表示当前搜寻分发器block的状态。<ul>
<li>存储每一个功能块到下一个候选块之前的最短路径</li>
<li>任意拼接两个块之间的路径本身是一个NP难的问题</li>
<li>功能块之间的选择依据是，更短的路径可能会导致更合适的约束</li>
<li>delta图中记录了每一个功能块，功能块的边是两个功能块之间转移需要经过的block数量.（但是在计算两个block之间的路径时，静态CFG上是可以有多个重点，但在实际执行时只会有一个终点。其实就是对控制流进行枚举的过程，你怎么知道实际路径是哪些的</li>
<li>文章提出的路径算法是迪杰斯特拉算法的递归版本，并且避免了所有的破坏块。<ul>
<li>迪杰斯特拉算法：不断加入新的结点作为中间跳转结点，计算出最短距离</li>
<li>算法逻辑：初始分析时将相邻的边的开销设置为1。当其遇到call指令时，就进行递归地计算，找到每个功能块之间的最短路径</li>
</ul>
</li>
</ul>
</li>
<li>BOP gadget缝合：<ul>
<li>从每一个BOPgadget开始不断向后进行符号执行读入新的BOP功能块，直到最后一个块。</li>
</ul>
</li>
</ul>
<p>在进行组织的过程中需要在BOP gadget间拼接不会影响当前程序执行流的基本块。使用delta 图来搜索当前所有的调度块。</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/06/27/viper-ssgvdoa/">VIPER_SSGVDOA</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-06-27</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks"><a href="#VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks" class="headerlink" title="VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks"></a>VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks</h2><hr>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>文章的主要目的是检查那些影响数据流，促使程序运行至关键系统调用的关键变量。VIPER能够自动化地查找实现对系统调用保护分支和变量的自动和可扩展检测</li>
<li>两个关键定义：Syscall-Guard Variables，syscallguard变量决定是否调用与安全相关的系统调用 ，因此它们的值对程序安全性有直接影响。这意味着它们应该被视为关键数据。同样也衍生出，syscall-Guard branch，用于决定是否会执行当前的系统调用。</li>
<li>一个关键方法： 文章提出了分支强制（branch force），它有意地翻转执行过程中的每个条件分支，并检查是否调用了新的与安全相关的syscalls。如果是，则进行数据流分析以估计通过常见内存错误翻转这些分支的可行性。</li>
<li>基本逻辑：程序想要通过数据流攻击实现一定的攻击语义，必须要依赖于一定的系统调用实现。然而系统调用在处理不受信任的输入前一定会存在一定的检查操作。</li>
</ul>
<h3 id="识别困难"><a href="#识别困难" class="headerlink" title="识别困难"></a>识别困难</h3><p>​	关键变量可能会以任何数据类型，任何存储位置存在。这会导致传统的分析方式失效。况且对于大型程序，进行变量的推断是十分困难的。</p>
<h3 id="攻击的前提"><a href="#攻击的前提" class="headerlink" title="攻击的前提"></a>攻击的前提</h3><ul>
<li>不管程序是什么，大多数纯数据攻击都依赖于与安全相关的系统 调用(简称系统调用)来实现最终目标。（其实就是最终的攻击语义一定要依赖于系统调用的存在）</li>
<li>关键的系统调用函数前一定会存在一些分支检查</li>
</ul>
<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><ul>
<li>使用相同的输入进入程序，找到分支，进行强制跳转。如果强制跳转之后触发了程序的bug，那么该分支就作为候选分支</li>
<li>在一次执行中翻转分支条件，找到新的分支条件生成新的路径，查找新的系统调用</li>
</ul>
<h3 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h3><ul>
<li>修剪掉无用的分支，并且评估单个变量的影响是十分有挑战性的。符号执行能够找到从程序入口到关键系统调用的路径，但是并不能给出，当前路径上的哪些分支是更重要的，因此只能对所有的分支都做分析</li>
<li>找到一种高效的分析方法很困难，使用间接函数调用的程序太多了，使用静态分析十分不切实际</li>
</ul>
<h3 id="approaches"><a href="#approaches" class="headerlink" title="approaches"></a>approaches</h3><ul>
<li><strong>branch force</strong>：收集候选的分支变量<ul>
<li>思想：假设当前分支时关键保护分支，那么该分支向后执行仅仅只能有其中一个分支触发当前程序中的系统调用，如果两个都能触发，那这个分支肯定不是关键保护分支。如果都不能触发，则该分支对于当前程序的安全性并不重要。</li>
<li>执行流程：<ul>
<li>以相同的输入I执行程序，将遇到的每一个分支进行强制翻转（并不改变输入），并且</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016500.png" alt="image-20230628155213365"></p>
<ul>
<li><strong>dynamic backward data-flow</strong>：检查每个变量被覆盖利用的可能性</li>
<li><strong>Corruptibility Assessment</strong> ： 使用数据流来评估每一个分支变量被内存错误污染的可能性。同时使用动态数据流分析，在过程中根据变量的存储位置和内存的声明周期对内存进行定性，分别视为容易利用和难利用三种等级。全局变量相对局部变量更容易被利用，生命周期越长，被修改次数越多，能被利用的概率越高。依此能够筛选出被破坏概率更高的关键变量。</li>
</ul>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016755.png" alt="image-20230628205325968"></p>
<p>VIPER在对程序分析后，最终会报告当前程序中存在的各种危险的关键分支，系统调用及其保护变量。</p>
<p>​	BranchForcer运行包含原始输入的程序，并记录执行的分支和系统调用。然后，使用相同的输入多次运行程序，并为每次新的执行翻转一个不同分支的目标。如果重新执行触发了新的与安全性相关的系统调用，我们将当前分支添加到候选列表中。对于每个候选分支，VariableRator再次运行程序，以记录执行的完整跟踪，包括分支序列、所有内存访问地址和进程内存布局。利用记录的轨迹对程序IR进行反向数据流分析。VariableRator检查内存布局以确定每个内存节点的位置，并计算内存写指令的数量以估计节点的生命周期</p>
<h3 id="分支记录"><a href="#分支记录" class="headerlink" title="分支记录"></a>分支记录</h3><p>​	由于在执行的过程中可能会出现路径爆炸以及某些分支翻转了没有意义，因此只在固定路径上做分支翻转。每个分支只会做一次翻转。为了提高效率，使用多线程尽心探索。</p>
<p>​	每次使用相同的输入和不同的分支翻转执行程序，如果遇到新的系统调用就将当前路径做为候选路径进行存储，然后进行完整的分支执行分析，利用数据流进行后向切片，确定所有与分支保护状态相关的指令。利用值集分析来找到控制变量中所有可能的值。</p>
<p>​	</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2023/05/12/blind-rop/">blind-rop</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2023-05-12</span>
                
            </div>
            <div class="post-content">
                
                    
                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/2/">
            <i class="iconfont icon-prev"></i>
            上一页
        </a>
        
        
        <a class="next" href="/page/4/">
            下一页
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2024
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">alazymachine</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
