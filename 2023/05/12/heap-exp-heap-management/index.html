



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="alazymachine" href="https://alazymechnaic.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="alazymachine" href="https://alazymechnaic.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="alazymachine" href="https://alazymechnaic.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="HEAP PWN CTF" />


<link rel="canonical" href="https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/">



  <title>
HEAP-EXP-heap_management |
Alazymachine = alazymachine = Alazymachine&PersonalBlog</title>
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">HEAP-EXP-heap_management
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-05-12 19:47:55">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-05-12T19:47:55+08:00">2023-05-12</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Alazymachine</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/myavatar.jpg">
    <meta itemprop="name" content="alazymachine">
    <meta itemprop="description" content="Alazymachine&PersonalBlog, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="alazymachine">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h1><hr>
<p>​	本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。</p>
<h2 id="堆管理机制"><a href="#堆管理机制" class="headerlink" title="堆管理机制"></a>堆管理机制</h2><p>​	堆区域与栈区域在内存使用上存在不同：</p>
<ul>
<li>堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置</li>
<li>堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长</li>
<li><strong>堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念</strong></li>
</ul>
<p><img data-src="/HEAP-EXP-heap-management.assets/image-20230613200259727.png" alt="先知社区https://xz.aliyun.com/t/10650"></p>
<p>(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)</p>
<p><img data-src="/HEAP-EXP-heap-management.assets/image-20230613200729790.png" alt="image-20230613200729790"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li>32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.</li>
<li>64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，</li>
</ul>
<h4 id="内存的分配管理策略"><a href="#内存的分配管理策略" class="headerlink" title="内存的分配管理策略"></a>内存的分配管理策略</h4><ul>
<li>具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）</li>
<li>特别大的内存分配使用的是mmap，<strong>使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大</strong></li>
<li>短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源</li>
<li>空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存</li>
<li>对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中</li>
<li><strong>注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统</strong></li>
</ul>
<h4 id="arena分配区机制"><a href="#arena分配区机制" class="headerlink" title="arena分配区机制"></a>arena分配区机制</h4><ul>
<li>arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，<strong>但是如果是单线程程序也可以拥有多个arena</strong>，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：<ul>
<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>
<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止</li>
<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>
</ul>
</li>
<li>在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。</li>
<li>每个进程只能有一个主分配区，但有多个非主分配区<ul>
<li>主分配区可以使用brk和mmap两种方式进行内存的分配</li>
<li>非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理</li>
<li>同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena</li>
<li>可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。</li>
<li>多线程环境下内存的分配与回收：<ul>
<li>查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；</li>
<li>当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。</li>
</ul>
</li>
</ul>
</li>
<li>进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。</li>
</ul>
<h2 id="堆管理的数据结构"><a href="#堆管理的数据结构" class="headerlink" title="堆管理的数据结构"></a>堆管理的数据结构</h2><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>​	一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。</p>
<p>​	主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止</p>
<p>​	依照该数据结构的情况能够看到：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">heap_info</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">heap_info</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">//指向前一个heap_info结构</span>
  <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>  <span class="token comment">//当前heap_info结构所描述的堆内存大小</span>
  <span class="token keyword">int</span> mmaped<span class="token punctuation">;</span>  <span class="token comment">//标记当前堆内存是否由mmap系统调用分配</span>
  <span class="token keyword">struct</span> <span class="token class-name">heap_info</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">//指向后一个heap_info结构</span>
  <span class="token keyword">struct</span> <span class="token class-name">arena</span> <span class="token operator">*</span>ar_ptr<span class="token punctuation">;</span>  <span class="token comment">//指向当前堆内存所在的arena</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>malloc_state</code> 用于表示 <em>arena</em> 的信息，因此也被称为 <em>arena header</em>，每个线程只含有一个 <em>arena header</em>。<em>arena header</em> 包含 <em>bin</em>、<em>top chunk</em> 以及 <em>last remainder chunk</em> 等信息</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token punctuation">{</span>
  <span class="token class-name">binmap_t</span>     binmap<span class="token punctuation">[</span>BINMAPSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于标记哪些 bin 是非空的</span>
  mfastbinptr  fastbinsY<span class="token punctuation">[</span>NFASTBINS<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于存放小块内存的链表</span>
  mchunkptr    top<span class="token punctuation">;</span>  <span class="token comment">// 指向当前 arena 中最后一个已分配的 chunk</span>
  mchunkptr    last_remainder<span class="token punctuation">;</span>  <span class="token comment">// 指向上一个 arena 中未被使用完的 chunk</span>
  mchunkptr    bins<span class="token punctuation">[</span>NBINS <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 用于存放各个 bin 中的 chunk</span>
  <span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 指向下一个 malloc_state 结构</span>
  <span class="token class-name">uint64_t</span>     magic<span class="token punctuation">;</span>  <span class="token comment">// 用于检查 malloc_state 结构的完整性</span>
  <span class="token class-name">uint64_t</span>     flags<span class="token punctuation">;</span>  <span class="token comment">// 保存了 malloc_state 的各种状态信息</span>
  <span class="token class-name">mutex_t</span>      mutex<span class="token punctuation">;</span>  <span class="token comment">// 用于保护 malloc_state 结构的互斥锁</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>       seg<span class="token punctuation">;</span>  <span class="token comment">// 指向当前 arena 的起始地址</span>
  <span class="token class-name">size_t</span>       size<span class="token punctuation">;</span>  <span class="token comment">// 当前 arena 的大小</span>
  <span class="token class-name">size_t</span>       mprotect_size<span class="token punctuation">;</span>  <span class="token comment">// 当前 arena 中已经保护的内存大小</span>
  mchunkptr    mprotect_base<span class="token punctuation">;</span>  <span class="token comment">// 当前 arena 中已经保护的内存的起始地址</span>
  mchunkptr    last_remainder<span class="token punctuation">;</span>  <span class="token comment">// 上一个 arena 中未被使用完的 chunk</span>
  <span class="token keyword">struct</span> <span class="token class-name">heap_info</span> <span class="token operator">*</span>heap_info<span class="token punctuation">;</span>  <span class="token comment">// 当前 arena 所在的 heap_info 结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="chunk的组织形式"><a href="#chunk的组织形式" class="headerlink" title="chunk的组织形式"></a>chunk的组织形式</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span> <span class="token punctuation">{</span>
  <span class="token comment">/* #define INTERNAL_SIZE_T size_t */</span>
  INTERNAL_SIZE_T      prev_size<span class="token punctuation">;</span>  <span class="token comment">/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/</span>
  INTERNAL_SIZE_T      size<span class="token punctuation">;</span>       <span class="token comment">/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */</span>
  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> fd<span class="token punctuation">;</span>    
  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> bk<span class="token punctuation">;</span>
	<span class="token comment">/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/</span>
  <span class="token comment">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> fd_nextsize<span class="token punctuation">;</span> <span class="token comment">/* double links -- used only if free. */</span>
  <span class="token keyword">struct</span> <span class="token class-name">malloc_chunk</span><span class="token operator">*</span> bk_nextsize<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些</li>
<li>基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk</li>
<li>如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法</li>
</ul>
<p><strong>已分配chunk的数据结构情况</strong></p>
<p><img data-src="/HEAP-EXP-heap-management.assets/image-20230613234305496.png" alt="image-20230613234305496"></p>
<p><strong>未分配的chunk数据结构情况</strong></p>
<p><img data-src="/HEAP-EXP-heap-management.assets/image-20230613234401273.png" alt="image-20230613234401273"></p>
<p>​	在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。</p>
<p>​	这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，<strong>且prev_size的大小指的是包含当前块头部和用户数据的部分</strong>）</p>
<pre class="line-numbers language-none"><code class="language-none">N：是不是「主分配区」分配的内存 1 表示不是主分配区分配的，0 表示是主分配区分配的

M：是不是 Memory Mapped 分配的内存，1 表示是，0 表示是 heap

P：表示前一个 chunk 是否在使用，在初始化的时候通常为 1，防止使用不能访问的内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s">https://www.freebuf.com/articles/system/171261.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWV6ZV9DQVQvYXJ0aWNsZS9kZXRhaWxzLzEwMzc4ODY5OA==">https://blog.csdn.net/Breeze_CAT/article/details/103788698</span></p>
<h3 id="tcache（thread-local-caching）机制"><a href="#tcache（thread-local-caching）机制" class="headerlink" title="tcache（thread local caching）机制"></a>tcache（thread local caching）机制</h3><ul>
<li><code>tcache</code>属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。</li>
<li>仅适用于glibc2.26以上的版本使用</li>
</ul>
<h3 id="Bin机制"><a href="#Bin机制" class="headerlink" title="Bin机制"></a>Bin机制</h3><ul>
<li>ptmalloc 一共维护128个bin，使用数组存储链表头，</li>
<li><strong>fast bin</strong>：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个<strong>单向链表</strong>进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。</li>
<li><strong>small bin</strong>：专门存放size&lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin</li>
<li><strong>large bin</strong>：需要对bin中的chunk按照大小进行排序。</li>
<li><strong>unsorted bin</strong>：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。</li>
<li>unsorted bin在使用的过程中是FIFO的</li>
</ul>
</li>
<li><strong>Top Chunk</strong>：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，<strong>初始状态下的UNsorted chunk 就是 Top chunk</strong></li>
<li>last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。</li>
</ul>
<h3 id="Bin运作流程"><a href="#Bin运作流程" class="headerlink" title="Bin运作流程"></a>Bin运作流程</h3><ul>
<li>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中</li>
<li>在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</li>
<li>如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。</li>
<li>unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。</li>
<li>在size&gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。<br>Unsorted Bin</li>
<li>空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中</li>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话</li>
<li>分配过程：fastbin-&gt;unsorted bin-&gt;其他bins-&gt;切割top chunk</li>
<li>回收过程：<ul>
<li>在maped区域，直接回收即可</li>
<li>在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理</li>
</ul>
</li>
</ul>
<h3 id="各个bin的处理先后顺序"><a href="#各个bin的处理先后顺序" class="headerlink" title="各个bin的处理先后顺序"></a>各个bin的处理先后顺序</h3><ul>
<li>fastbin 是 LIFO (后入先出)</li>
<li>unsorted bin是 FIFO (先进先出)</li>
<li>small bin 是 FIFO</li>
<li>large bin 是 FIFO</li>
<li>tcache 是 LIFO</li>
<li>实际利用时只要知道fastbin为了加快速度学习了栈的机制</li>
</ul>
<h3 id="线程堆"><a href="#线程堆" class="headerlink" title="线程堆"></a>线程堆</h3><ul>
<li>每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。</li>
</ul>
<h3 id="malloc-state-1"><a href="#malloc-state-1" class="headerlink" title="malloc_state"></a>malloc_state</h3><ul>
<li>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。</li>
<li>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Serialize access.  */</span>
    <span class="token function">__libc_lock_define</span><span class="token punctuation">(</span><span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Flags (formerly in max_fast).  */</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>

    <span class="token comment">/* Fastbins */</span>
    mfastbinptr fastbinsY<span class="token punctuation">[</span> NFASTBINS <span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
    mchunkptr top<span class="token punctuation">;</span>

    <span class="token comment">/* The remainder from the most recent split of a small request */</span>
    mchunkptr last_remainder<span class="token punctuation">;</span>

    <span class="token comment">/* Normal bins packed as described above */</span>
    mchunkptr bins<span class="token punctuation">[</span> NBINS <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">2</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> binmap<span class="token punctuation">[</span> BINMAPSIZE <span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/* Linked list, points to the next arena */</span>
    <span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>

    <span class="token comment">/* Linked list for free arenas.  Access to this field is serialized
       by free_list_lock in arena.c.  */</span>
    <span class="token keyword">struct</span> <span class="token class-name">malloc_state</span> <span class="token operator">*</span>next_free<span class="token punctuation">;</span>

    <span class="token comment">/* Number of threads attached to this arena.  0 if the arena is on
       the free list.  Access to this field is serialized by
       free_list_lock in arena.c.  */</span>
    INTERNAL_SIZE_T attached_threads<span class="token punctuation">;</span>

    <span class="token comment">/* Memory allocated from the system in this arena.  */</span>
    INTERNAL_SIZE_T system_mem<span class="token punctuation">;</span>
    INTERNAL_SIZE_T max_system_mem<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>















<h2 id="堆管理函数"><a href="#堆管理函数" class="headerlink" title="堆管理函数"></a>堆管理函数</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="libc_malloc"></a>libc_malloc</h3><p>​	malloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。</p>
<p><strong>用户申请的字节一旦进入libc_malloc会转换为无符号整数</strong>，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><ul>
<li>作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。</li>
<li>使用场景：<ul>
<li><strong>malloc</strong><ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li>
<li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink</strong> 。</li>
</ul>
</li>
<li>从比请求的 chunk 所在的large bin 中取 chunk。</li>
</ul>
</li>
<li><strong>free</strong><ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><strong>malloc_consolidate</strong>：用于合并的时候要把空闲块取出来先。<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><strong>realloc</strong><ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Take a chunk off a bin list */</span>
<span class="token comment">// unlink p</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span><span class="token comment">//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \
    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span>
	<span class="token comment">// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">prev_size</span> <span class="token punctuation">(</span><span class="token function">next_chunk</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      \
      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"corrupted size vs. prev_size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               \
    FD <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>                                                                      \
    BK <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>                                                                      \
    <span class="token comment">// 此处才真正的取出FD和BK两个chunk块</span>
    <span class="token comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-&gt;</span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-&gt;</span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    \ <span class="token comment">// 看看取出的目标块是不是真正的目标</span>
      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  \
    <span class="token keyword">else</span> <span class="token punctuation">{</span>                                                                      \
        FD<span class="token operator">-&gt;</span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>                                                              \
        BK<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>   <span class="token comment">// 此处主要是将P排除在外，让前后块进行连接                 \
        // 下面主要考虑 P 对应的 nextsize 双向链表的修改</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_smallbin_range</span> <span class="token punctuation">(</span><span class="token function">chunksize_nomask</span> <span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span>                              \
            <span class="token comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span>
            <span class="token comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span>
            <span class="token comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span>
            <span class="token operator">&amp;&amp;</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      \
            <span class="token comment">// 类似于小的 chunk 的检查思路</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>              \
                <span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    \
              <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span>                                      \
                               <span class="token string">"corrupted double-linked list (not small)"</span><span class="token punctuation">,</span>    \
                               P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>                                              \
            <span class="token comment">// 这里说明 P 已经在 nextsize 链表中了。</span>
            <span class="token comment">// 如果 FD 没有在 nextsize 链表中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                      \
                <span class="token comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span>
                <span class="token comment">// 令 FD 为 nextsize 串起来的</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">==</span> P<span class="token punctuation">)</span>                                      \
                  FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> FD<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>                      \
                <span class="token keyword">else</span> <span class="token punctuation">{</span>                                                              \
                <span class="token comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span>
                    FD<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd_nextsize<span class="token punctuation">;</span>                              \
                    FD<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>                              \
                    P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>                              \
                    P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>                              \
                  <span class="token punctuation">}</span>                                                              \
              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                                              \
                <span class="token comment">// 如果在的话，直接拿走即可</span>
                P<span class="token operator">-&gt;</span>fd_nextsize<span class="token operator">-&gt;</span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>bk_nextsize<span class="token punctuation">;</span>                      \
                P<span class="token operator">-&gt;</span>bk_nextsize<span class="token operator">-&gt;</span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-&gt;</span>fd_nextsize<span class="token punctuation">;</span>                      \
              <span class="token punctuation">}</span>                                                                      \
          <span class="token punctuation">}</span>                                                                      \
      <span class="token punctuation">}</span>                                                                              \
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&gt;fd,和P-&gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露</li>
<li>泄露思路：<ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）</li>
</ul>
</li>
<li>泄露堆地址<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
<li>注意：<ul>
<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>
<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>
<li><strong>堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></li>
</ul>
</li>
</ul>
<h3 id="init-malloc函数"><a href="#init-malloc函数" class="headerlink" title="_init_malloc函数"></a>_init_malloc函数</h3><p>该函数是malloc申请内存的底层函数</p>
<ol>
<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>
<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>
<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>
<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>
</ol>
<ul>
<li>注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。</li>
<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></li>
</ul>
<h2 id="堆溢出常见攻击手段"><a href="#堆溢出常见攻击手段" class="headerlink" title="堆溢出常见攻击手段"></a>堆溢出常见攻击手段</h2><p><img data-src="/HEAP-EXP-heap-management.assets/image-20230625155220102.png" alt="image-20230625155220102"></p>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>​	堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。</p>
<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>​	double free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况</p>
<h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><ul>
<li>unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。</li>
<li>注意事项:unlink不发生在<em>fastbin和smallbin</em>中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储</li>
<li>unlink本身存在一些检查</li>
</ul>
<p>unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。</p>
<p>unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">FD <span class="token operator">=</span> p<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>
BK <span class="token operator">=</span> p<span class="token operator">-&gt;</span>bk<span class="token punctuation">;</span>
FD<span class="token operator">-&gt;</span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>
BK<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>
<span class="token comment">// 其实就是传统的双向链表取元素的操作</span>
<span class="token comment">/*
	上述操作中，当前块的fd和bk是可以被伪造的。
	假设此刻将两个地址分别重写为got[free], 和shellcode地址
	执行前两条指令后。
	FD = got[free] - 12（32位机器）
	BK = shellcode  // 这里BK要加fd，所以不需要存储
	执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持
	但是这个方法在新版libc里没有用！！！
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​	unlink之前需要进行一些简单的检查，这个检查是可以欺骗的：</p>
<p>​	fd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&gt;bk-&gt;fd==p &amp;&amp; p-&gt;fd-&gt;bk==p, 只需要保证满足 fd = &amp;p - 3*size(int); bk = &amp;p - 2*size(int) 即可。</p>
<p>​	<strong>也就是说</strong>：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;ptr - 3*size(int); bk = &amp;ptr- 2*size(int) ，在检查的过程中BK-&gt;fd = FD-&gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改</p>
<h4 id="例题-0CTF2015-freenote"><a href="#例题-0CTF2015-freenote" class="headerlink" title="例题 0CTF2015 freenote"></a>例题 0CTF2015 freenote</h4><p>​	</p>
<h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h3><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。</p>
<h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvODUzNTc=">https://www.anquanke.com/post/id/85357</span></p>
<ul>
<li>house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构</li>
<li></li>
</ul>
<h3 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h3><p>tcache本身是单向链表，并且一个线程对应一个tcache存在。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9maXJtaWFuYXkuZ2l0Ym9va3MuaW8vY3RmLWFsbC1pbi1vbmUvY29udGVudC9kb2MvNC4xNF9nbGliY190Y2FjaGUuaHRtbCNjdGYtJUU1JUFFJTlFJUU0JUJFJThC">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly92MWNreWR4cC5naXRodWIuaW8vMjAxOS8wNi8zMC9UY2FjaGUtJUU2JTlDJUJBJUU1JTg4JUI2JUU1JTg4JTg2JUU2JTlFJTkwJUU1JThGJThBJUU1JTg4JUE5JUU3JTk0JUE4JUU2JTgwJTlEJUU4JUI3JUFGLw==">https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/</span></p>
<h2 id="堆利用例题"><a href="#堆利用例题" class="headerlink" title="堆利用例题"></a>堆利用例题</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzE3MTI2MS5odG1s">https://www.freebuf.com/articles/system/171261.html</span></p>
<h3 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h3>
      <div class="tags">
          <a href="/tags/HEAP-PWN-CTF/" rel="tag"><i class="ic i-tag"></i> HEAP PWN CTF</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-08-24 09:14:17" itemprop="dateModified" datetime="2023-08-24T09:14:17+08:00">2023-08-24</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="alazymachine 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="alazymachine 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="alazymachine 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>alazymachine <i class="ic i-at"><em>@</em></i>alazymachine
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/" title="HEAP-EXP-heap_management">https://alazymechnaic.github.io/2023/05/12/heap-exp-heap-management/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/05/05/bypass-aslr/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclflwv2aj20zk0m84qp.jpg" title="bypass-aslr">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>bypass-aslr</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/05/12/blind-rop/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4baakhj20zk0m8h5q.jpg" title="blind-rop">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>blind-rop</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">堆利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">堆管理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">内存的分配管理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arena%E5%88%86%E9%85%8D%E5%8C%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">arena分配区机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">堆管理的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#heap-info"><span class="toc-number">1.3.1.</span> <span class="toc-text">heap_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-state"><span class="toc-number">1.3.2.</span> <span class="toc-text">malloc_state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">chunk的组织形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache%EF%BC%88thread-local-caching%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">tcache（thread local caching）机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bin%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">Bin机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bin%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">Bin运作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AAbin%E7%9A%84%E5%A4%84%E7%90%86%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">各个bin的处理先后顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A0%86"><span class="toc-number">1.3.8.</span> <span class="toc-text">线程堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-state-1"><span class="toc-number">1.3.9.</span> <span class="toc-text">malloc_state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">堆管理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-malloc"><span class="toc-number">1.4.1.</span> <span class="toc-text">libc_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink"><span class="toc-number">1.4.2.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-malloc%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">_init_malloc函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5"><span class="toc-number">1.5.</span> <span class="toc-text">堆溢出常见攻击手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">堆溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#double-free"><span class="toc-number">1.5.2.</span> <span class="toc-text">double free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-0CTF2015-freenote"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">例题 0CTF2015 freenote</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">1.5.4.</span> <span class="toc-text">fastbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">house of spirit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-attack"><span class="toc-number">1.5.5.</span> <span class="toc-text">tcache attack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8%E4%BE%8B%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">堆利用例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-number">1.6.1.</span> <span class="toc-text">fastbin_dup_into_stack</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="alazymachine"
      data-src="/images/myavatar.jpg">
  <p class="name" itemprop="name">alazymachine</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">21</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">12</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/05/05/bypass-aslr/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/05/12/blind-rop/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/06/27/viper-ssgvdoa/" title="VIPER_SSGVDOA">VIPER_SSGVDOA</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/07/20/android-basic/" title="Android_Basic">Android_Basic</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/07/20/go-reverse/" title="go_reverse">go_reverse</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/05/02/personal-plan/" title="personal_plan">personal_plan</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/05/02/bypass-nx/" title="bypass-NX">bypass-NX</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/08/03/android-framework/" title="android_framework">android_framework</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/08/30/afl-fuzz-diy/" title="afl_fuzz_DIY">afl_fuzz_DIY</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/07/13/kernel-pwn/" title="kernel_pwn">kernel_pwn</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/09/03/libdft/" title="libdft">libdft</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/09/05/useful-command/" title="Useful_command">Useful_command</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">alazymachine @ Alazymachine</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/05/12/heap-exp-heap-management/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
