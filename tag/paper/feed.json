{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"paper\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/08/22/sec-paper-list/",
            "url": "https://alazymechnaic.github.io/2023/08/22/sec-paper-list/",
            "title": "Sec_paper_list",
            "date_published": "2023-08-22T02:00:57.000Z",
            "content_html": "<h2 id=\"安全相关论文及博客汇总\"><a href=\"#安全相关论文及博客汇总\" class=\"headerlink\" title=\"安全相关论文及博客汇总\"></a>安全相关论文及博客汇总</h2><hr>\n<h3 id=\"安全会议\"><a href=\"#安全会议\" class=\"headerlink\" title=\"安全会议\"></a>安全会议</h3><ul>\n<li><strong>NDSS</strong>：  <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL25kc3MyMDIzL2FjY2VwdGVkLXBhcGVycy8=\">https://www.ndss-symposium.org/ndss2023/accepted-papers/</span></li>\n<li><strong>ACM CCS</strong>： <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2lnc2FjLm9yZy9jY3MvQ0NTMjAyMy8=\">https://www.sigsac.org/ccs/CCS2023/</span></li>\n<li><strong>USENIX</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9jb25mZXJlbmNlL3VzZW5peHNlY3VyaXR5MjMv\">https://www.usenix.org/conference/usenixsecurity23/</span></li>\n<li><strong>S&amp;P</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWVlZS1zZWN1cml0eS5vcmcvVEMvU1AyMDIzL3Byb2dyYW0tcGFwZXJzLmh0bWw=\">https://www.ieee-security.org/TC/SP2023/program-papers.html</span></li>\n</ul>\n<h3 id=\"更新活跃的安全媒体\"><a href=\"#更新活跃的安全媒体\" class=\"headerlink\" title=\"更新活跃的安全媒体\"></a>更新活跃的安全媒体</h3><ul>\n<li><strong>先知社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tLw==\">https://xz.aliyun.com/</span></li>\n<li><strong>安全客</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tLw==\">https://www.anquanke.com/</span></li>\n<li><strong>360 核心安全技术博客</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9ncy4zNjAubmV0Lw==\">https://blogs.360.net/</span></li>\n</ul>\n<h3 id=\"技术博客\"><a href=\"#技术博客\" class=\"headerlink\" title=\"技术博客\"></a>技术博客</h3><ul>\n<li><strong>知道创宇</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLw==\">https://paper.seebug.org/</span></li>\n<li><strong>棱角社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS55d2hhY2suY29tL2ZvcnVtLTU5LTEuaHRtbA==\">https://forum.ywhack.com/forum-59-1.html</span></li>\n<li><strong>奇安信攻防社区</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5idXRpYW4ubmV0L2NvbW11bml0eS9hbGwvbmV3ZXN0\">https://forum.butian.net/community/all/newest</span></li>\n</ul>\n<p><strong>Personal Blog</strong></p>\n<ul>\n<li>游戏安全：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucGVyZmFyZS5uZXQv\">https://www.perfare.net/</span></li>\n<li>逆向工程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aW55aGFjay5jb20v\">https://tinyhack.com/</span></li>\n<li>漏洞分析：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndG9hZC5naXRodWIuaW8v\">https://gtoad.github.io/</span></li>\n</ul>\n<hr>\n<h2 id=\"usenix\"><a href=\"#usenix\" class=\"headerlink\" title=\"usenix\"></a>usenix</h2><h3 id=\"Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#Viper-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"Viper: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>Viper: Spotting Syscall-Guard Variables for Data-Only Attacks</h3><p>由于控制流保护技术得到广泛应用，攻击者很难修改控制数据，如函数指针，以劫持程序的控制流。相反，仅针对数据的攻击会破坏安全关键的非控制数据（关键数据），并且可以绕过所有的控制流保护措施，实施严重的攻击。以前的研究已经探索了各种方法来帮助构建或防止仅针对数据的攻击。然而，目前还没有解决方案能够自动检测程序特定的关键数据。</p>\n<p>在本文中，我们确定了一个重要的关键数据类别，即系统调用保护变量（syscall-guard variables），并提出了一组解决方案，以可扩展的方式自动检测此类变量。系统调用保护变量决定是否调用与安全相关的系统调用（syscalls），修改它们将允许攻击者向操作系统请求额外的特权。我们提出了分支强制（branch force）的方法，在执行过程中有意地翻转每个条件分支，并检查是否调用了新的与安全相关的系统调用。如果是这样，我们通过常见的内存错误进行数据流分析，估计翻转这些分支的可行性。我们构建了一个名为VIPER的工具来实现我们的想法。VIPER成功地从13个程序中检测到了34个以前未知的系统调用保护变量。我们对sqlite和v8进行了四种新的仅针对数据的攻击，可以执行任意命令或删除任意文件。VIPER在大多数程序中在五分钟内完成分析，显示了其用于发现系统调用保护变量的实用性。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy15ZS5wZGY=\">usenixsecurity23-ye.pdf</span></p>\n<h3 id=\"Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\"><a href=\"#Not-All-Data-are-Created-Equal-Data-and-Pointer-Prioritization-for-Scalable-Protection-Against-Data-Oriented-Attacks\" class=\"headerlink\" title=\"Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks\"></a><strong>Not All Data are Created Equal: Data and Pointer Prioritization for Scalable Protection Against Data-Oriented Attacks</strong></h3><p>数据导向的攻击在大多数操作系统中对最先进的防御措施变得越来越现实和有效。这些攻击操纵内存中的数据对象（数据和指针），而不改变程序的控制流。用于保护数据和指针的软件和硬件防御措施由于对所有数据对象的过度插装而遭受性能瓶颈的困扰。在这项工作中，我们提出了一种基于规则启发的数据和指针优先级（Data and Pointer Prioritization，DPP）框架，用于自动识别应用程序中的敏感内存对象，并仅保护那些敏感数据，利用现有的防御措施。我们使用Linux Flaw Project数据集、Juliet测试套件和五个用于演示数据导向攻击的真实世界程序来评估我们框架的正确性。我们的实验结果表明，DPP可以通过优先处理仅占总数据对象数量3-4%的对象来识别我们测试应用程序中的易受攻击的数据对象。我们对SPEC CPU2017整数基准套件的评估结果显示，启用了DPP的AddressSanitizer（ASan）在保护所有优先级数据对象的同时，可以将性能（吞吐量）提高1.6倍，并将运行时开销减少70%，相比默认的ASan。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly95YW9ncm91cC5jcy52dC5lZHUvZHBwLXVzZW5peC0yMy5wZGY=\">dpp-usenix-23.pdf (vt.edu)</span></p>\n<h3 id=\"sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\"><a href=\"#sAFer-Efficient-and-Error-Tolerant-Binary-Instrumentation\" class=\"headerlink\" title=\"sAFer: Efficient and Error-Tolerant Binary Instrumentation\"></a><strong>sAFer: Efficient and Error-Tolerant Binary Instrumentation</strong></h3><p>最近在二进制插桩方面的进展主要集中在性能方面。通过静态转换代码以避免额外的运行时操作，诸如Egalito和RetroWrite等系统实现了接近零的开销。这些静态转换的安全性依赖于几个假设：(a)无错误和完整的反汇编，(b)独占使用位置无关代码，(c)代码指针识别既没有误报也没有漏报。这些假设的违反可能导致插桩程序崩溃，甚至更糟糕的是，出现延迟故障导致数据损坏或安全受损。许多早期的二进制插桩技术（如DynamoRio、Pin和BinCFI）最小化了这些假设，但代价是更高的开销，尤其是对于间接调用密集（例如C++）的应用程序。因此，一个开放的研究问题是是否可以将早期的安全性优点与最近的性能优点相结合。我们以肯定的回答这个问题，提出了一种新的插桩技术，它(a)容忍使用位置相关代码和常见的反汇编和静态分析错误，(b)在运行时检测假设违规，以防止出现未定义行为。我们的方法提供了一种优雅关闭或恢复的故障崩溃机制。我们在不牺牲性能的情况下实现了安全的插桩，开销约为2%左右。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3NlY2xhYi5jcy5zdW55c2IuZWR1L3NlY2xhYi9wdWJzL3NhZmVyLnBkZg==\">safer.pdf (sunysb.edu)</span></p>\n<h3 id=\"Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\"><a href=\"#Reassembly-is-Hard-A-Reflection-on-Challenges-and-Strategies\" class=\"headerlink\" title=\"Reassembly is Hard: A Reflection on Challenges and Strategies\"></a><strong>Reassembly is Hard: A Reflection on Challenges and Strategies</strong></h3><p>​\t重组（Reassembly）是静态二进制重写的一个分支，如今已成为研究的焦点。然而，尽管它被广泛使用并引起了研究的兴趣，但目前还没有对重组技术和挑战进行系统的调查。在本文中，我们正式定义了当前现有的重组器中出现的不同类型的错误，并提出了一个名为REASSESSOR的自动化工具来发现这些错误。我们试图通过我们的工具和我们创建的大规模基准测试来展示当前领域面临的挑战以及如何解决这些挑战。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfNDM5LWtpbV9oeXVuZ3Nlb2stcHJlcHViLnBkZg==\">sec23summer_439-kim_hyungseok-prepub.pdf (usenix.org)</span></p>\n<h3 id=\"FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\"><a href=\"#FloatZone-Accelerating-Memory-Error-Detection-using-the-Floating-Point-Unit\" class=\"headerlink\" title=\"FloatZone: Accelerating Memory Error Detection using the Floating Point Unit\"></a><strong>FloatZone: Accelerating Memory Error Detection using the Floating Point Unit</strong></h3><p>​\t内存消毒器（Memory sanitizers）是检测空间和时间内存错误（如缓冲区溢出和使用释放后内存）的强大工具。模糊测试器和软件测试人员通常依赖这些工具来发现错误的存在。然而，消毒器会产生显著的运行时开销。例如，最广泛使用的消毒器——地址消毒器（Address Sanitizer，ASan）会导致2倍的减速。这种开销的主要来源是消毒器检查，其中至少涉及内存查找、比较和条件分支指令。将这些检查应用于确认程序中内存访问的有效性会大大减慢执行速度。</p>\n<p>​\t我们引入了FloatZone，一种基于编译器的消毒器，使用轻量级检查利用浮点单元（FPU）来检测C/C++程序中的空间和时间内存错误。我们展示了通过单个浮点加法触发下溢异常来实现“查找、比较和分支”的综合效果，以检测内存违规访问。这种新颖的检测方法通过避免传统比较的缺点大大提高了性能：它防止了分支预测错误，通过卸载到FPU实现更高的指令级并行性，并且由于没有阴影内存，降低了缓存失效率。</p>\n<p>我们的评估结果显示，FloatZone在SPEC CPU2006和CPU2017上只产生37%的运行时开销。此外，与现有技术相比，我们测量到的模糊测试吞吐量平均增加了2.87倍。最后，我们确认FloatZone在Juliet测试套件和一系列OSS-Fuzz错误上提供了与ASan相媲美的检测能力。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1nb3J0ZXIucGRm\">usenixsecurity23-gorter.pdf</span></p>\n<h3 id=\"PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\"><a href=\"#PUMM-Preventing-Use-After-Free-Using-Execution-Unit-Partitioning\" class=\"headerlink\" title=\"PUMM:Preventing Use-After-Free Using Execution Unit Partitioning\"></a><strong>PUMM:Preventing Use-After-Free Using Execution Unit Partitioning</strong></h3><p>​\t关键软件通常使用内存不安全的编程语言编写，容易受到使用释放后内存和双重释放错误的威胁。这导致了对内存分配器的提案，通过策略性地延迟内存重新分配的时间，使这类错误无法被利用。然而，现有的解决方案存在运行时和内存开销高的问题。为了寻求更好的解决方案，我们提出通过对程序进行分析来识别与处理各个任务相关的代码单元。基于这样的直觉，在运行时，不应该或者几乎不应该在不同任务之间传递数据，因此，释放的内存重新分配被延迟到当前执行单元完成之后，仅仅足够长的时间来防止使用释放后内存的利用。</p>\n<p>​\t为了证明我们设计的有效性，我们在Linux上实现了一个名为PUMM的原型系统，它包括一个离线分析器和一个在线强制执行器，通过透明地封装标准库来保护C/C++二进制文件。在我们的评估中，我们对26个程序中的40个真实世界漏洞和3,000个合成漏洞进行了测试，包括像Chakra JavaScript引擎这样的复杂多线程案例。PUMM成功地阻止了所有真实世界的攻击，并仅允许了4个合成攻击，同时将内存开销降低了52.0%并且平均运行时开销仅为2.04%。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjNzdW1tZXJfMTcteWFnZW1hbm4tcHJlcHViLnBkZg==\">sec23summer_17-yagemann-prepub.pdf (usenix.org)</span></p>\n<h3 id=\"Trojan-Source-Invisible-Vulnerabilities\"><a href=\"#Trojan-Source-Invisible-Vulnerabilities\" class=\"headerlink\" title=\"Trojan Source: Invisible Vulnerabilities\"></a><strong>Trojan Source: Invisible Vulnerabilities</strong></h3><p>​\t我们提出了一种新型攻击，即对源代码进行恶意编码，使其在编译器和人眼看来有所不同。这种攻击利用文本编码标准（如 Unicode）中的微妙之处产生源代码，其标记的逻辑编码顺序与显示顺序不同，从而导致人类代码审查员无法直接感知的漏洞。我们称之为 “源代码木马 “攻击，它对第一方软件和整个行业的供应链破坏都构成了直接威胁。我们介绍了 C、C++、C#、JavaScript、Java、Rust、Go、Python SQL、Bash、Assembly 和 Solidity 中的源代码木马攻击实例。我们提出了明确的编译器级防御措施，并介绍了可在编译器升级时部署到编辑器、资源库和构建流水线中的其他缓解控制措施，以阻止这种攻击。我们记录了针对这些漏洞的全行业协同披露；由于这些漏洞影响了大多数编译器、编辑器和软件源，因此我们通过这次演习了解了不同公司、开源社区和其他利益相关者如何应对漏洞披露。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvdXNlbml4c2VjdXJpdHkyMy1ib3VjaGVyLnBkZg==\">usenixsecurity23-boucher.pdf</span></p>\n<h3 id=\"Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\"><a href=\"#Arbiter-Bridging-the-Static-and-Dynamic-Divide-in-Vulnerability-Discovery-on-Binary-Programs\" class=\"headerlink\" title=\"Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs\"></a><strong>Arbiter: Bridging the Static and Dynamic Divide in Vulnerability Discovery on Binary Programs</strong></h3><p>尽管目前最先进的二进制程序分析方法在发现漏洞方面非常有效，但其准确性和可扩展性之间的固有权衡限制了这些方法的发展。在本文中，我们确定了一系列可帮助静态和动态漏洞检测技术的漏洞属性，提高了前者的精确性和后者的可扩展性。通过精心整合静态和动态技术，我们在真实世界的程序中大规模地检测出了表现出这些特性的漏洞。</p>\n<p>我们实施了我们的技术，在分析二进制代码方面取得了一些进展，并创建了一个名为 ARBITER 的原型。我们通过对四类常见漏洞的大规模评估，证明了我们方法的有效性： CWE-131（缓冲区大小计算错误）、CWE-252（未检查的返回值）、CWE-134（未控制的格式字符串）和 CWE-337（伪随机数生成器中的可预测种子）。我们在 Ubuntu 软件仓库中超过 76516 个 x86-64 二进制文件上评估了我们的方法，发现了新的漏洞，包括一个在编译过程中插入程序的漏洞。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjItdmFkYXlhdGgucGRm\">sec22-vadayath.pdf (usenix.org)</span></p>\n<h3 id=\"Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\"><a href=\"#Fine-Grained-Dataflow-Tracking-with-Proximal-Gradients\" class=\"headerlink\" title=\"Fine Grained Dataflow Tracking with Proximal Gradients\"></a><strong>Fine Grained Dataflow Tracking with Proximal Gradients</strong></h3><p>​\t使用动态污点分析（DTA）进行数据流跟踪是系统安全领域的一种重要方法，有很多应用，包括漏洞分析、引导模糊和侧信道信息泄漏检测。然而，DTA 从根本上受到污点标签布尔性质的限制，无法提供有关检测到的数据流重要性的信息，导致在复杂的真实世界程序中出现假阳性/阴性。</p>\n<p>​\t我们引入了近端梯度分析（PGA），这是一种基于理论的新方法，可以跟踪更准确、更精细的数据流信息。PGA 使用近似梯度（一种对无差异函数梯度的概括）来对程序中的无差异操作进行精确梯度组合。在程序上组合梯度消除了 DTA 中出现的许多数据流传播错误，并提供了有关每个测量数据流如何影响程序的更丰富信息。</p>\n<p>​\t我们在 7 个实际程序上将 PGA 原型实现与三种最先进的 DTA 实现进行了比较。结果表明，与污点跟踪（平均 20%）相比，PGA 可以将数据流跟踪的 F1 精确度提高 33%，而不会带来任何显著的开销（平均 &lt; 5%）。我们发现了 22 个漏洞（20 个经开发人员确认）和 2 个侧信道泄漏，并在测试程序中的 19 个现有 CVE 中识别出了可利用的数据流，从而进一步证明了 PGA 的有效性。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtcnlhbi5wZGY=\">sec21-ryan.pdf (usenix.org)</span></p>\n<h3 id=\"maze-Towards-Automated-Heap-Feng-Shui\"><a href=\"#maze-Towards-Automated-Heap-Feng-Shui\" class=\"headerlink\" title=\"maze: Towards Automated Heap Feng Shui\"></a><strong>maze: Towards Automated Heap Feng Shui</strong></h3><p>​\t大量内存损坏漏洞，例如堆溢出和释放后使用（UAF），只能通过堆风水等技术在特定堆布局中利用。为了给自动生成漏洞利用程序（AEG）铺平道路，需要对堆布局进行自动操作。</p>\n<p>​\t在本文中，我们提出了一种新型解决方案 MAZE，用于操作概念验证 (POC) 样本的堆布局。它首先识别堆布局基元（即输入片段或代码片段），供用户操作堆。然后，它应用一种新颖的 “挖掘与填充 “算法（Dig &amp; Fill algorithm），该算法将问题建模为线性二叉方程（Linear Diophantine Equation）并进行确定性求解，从而推断出能够生成目标堆布局的基元操作序列。</p>\n<p>​\t我们在分析引擎 S2E 的基础上实现了 MAZE 的原型，并在 PHP、Python 和 Perl 解释器、一组 CTF（夺旗）程序以及大型微基准测试中对其进行了评估。结果表明，MAZE 可以为超过 90% 的程序生成预期的堆布局。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtd2FuZy15YW4ucGRm\">sec21-wang-yan.pdf (usenix.org)</span></p>\n<h3 id=\"SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\"><a href=\"#SELECTIVETAINT-Efficient-Data-Flow-Tracking-With-Static-Binary-Rewriting\" class=\"headerlink\" title=\"SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting\"></a>SELECTIVETAINT: Efficient Data Flow Tracking With Static Binary Rewriting</h3><p>污点分析已被广泛应用于许多安全应用中，如漏洞检测、信息流跟踪、恶意软件分析和协议逆向工程。最先进的污点分析工具通常建立在动态二进制仪表之上，对每一条可能的指令进行检测，并依赖运行时信息来判断特定指令是否涉及污点，因此通常会产生很高的性能开销。本文介绍了针对二进制可执行文件的高效选择性污点分析框架 SelectiveTaint。其主要思想是利用静态二进制重写代替动态二进制工具，选择性地对涉及污点分析的指令进行工具化。在高层次上，SelectiveTaint 会静态扫描二进制代码中感兴趣的污点源，利用值集分析保守地确定指令操作数是否需要污点分析，然后选择性地对感兴趣的指令进行污点分析。我们实现了 SelectiveTaint，并用一组二进制程序对其进行了评估，其中包括 16 个 coreutils（侧重于文件 I/O）和 5 个网络守护程序（侧重于网络 I/O），如 nginx 网络服务器。评估结果表明，与最先进的动态污点分析框架相比，SelectiveTaint 静态检测的二进制程序性能更优越（例如，比 libdft 快 1.7 倍）。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1zYW5jaHVhbi5wZGY=\">sec21-chen-sanchuan.pdf (usenix.org)</span></p>\n<h3 id=\"MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\"><a href=\"#MBA-Blast-Unveiling-and-Simplifying-Mixed-Boolean-Arithmetic-Obfuscation\" class=\"headerlink\" title=\"MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation\"></a><strong>MBA-Blast: Unveiling and Simplifying Mixed Boolean-Arithmetic Obfuscation</strong></h3><p>​\t混合布尔算术 (MBA) 混淆是一种执行从简单表达式到难以理解和分析的表示的语义保留转换的方法。 更具体地说，这种混淆技术由算术运算（例如 ADD 和 IMUL）和布尔运算（例如 AND、OR 和 NOT）的混合使用组成。 经过 MBA 混淆的二进制代码可以有效地隐藏静态和动态逆向工程中的秘密数据/算法，包括利用 SMT 求解器的高级分析。 不幸的是，针对 MBA 的反混淆研究仍处于起步阶段：最先进的解决方案（例如模式匹配、位爆破和程序合成）要么遭受严重的性能损失，要么是为特定的 MBA 模式设计的，要么生成太多的代码。 在实践中会导致错误的简化。</p>\n<p>​\t在本文中，我们首先揭秘 MBA 混淆的底层机制。 我们的深入研究揭示了 1 位变量和 n 位变量之间 MBA 转换的隐藏双向特征。 我们利用这一特性并提出了一种可行的解决方案，通过 MBA 混淆来有效地反混淆代码。 我们的主要见解是 MBA 转换在 1 位和 n 位变量上的行为方式相同。 我们提供了数学证明来保证这一发现的正确性。 我们进一步开发了一种新技术，通过 1 位空间的算术缩减将 MBA 表达式简化为正常的简单形式。 我们将这个想法实现为一个名为 MBA-Blast 的开源原型，并在包含约 10,000 个 MBA 表达式的综合数据集上对其进行了评估。 我们还在现实世界的二进制代码反混淆场景中测试了我们的方法，这表明 MBA-Blast 可以帮助人类分析师充分利用 SMT 求解器的优势。 与现有工作相比，MBA-Blast 是最通用、最高效的 MBA 反混淆技术； 它具有坚实的理论基础，并且成功率最高，而开销可以忽略不计。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtbGl1LWJpbmJpbi5wZGY=\">sec21-liu-binbin.pdf (usenix.org)</span></p>\n<h3 id=\"VScape-Assessing-and-Escaping-Virtual-Call-Protections\"><a href=\"#VScape-Assessing-and-Escaping-Virtual-Call-Protections\" class=\"headerlink\" title=\"VScape: Assessing and Escaping Virtual Call Protections\"></a><strong>VScape: Assessing and Escaping Virtual Call Protections</strong></h3><p>​\t许多控制流完整性（CFI）解决方案已被提出，用于保护间接控制传递（ICT），包括C++虚函数调用。评估这些防御方案的安全性保证是重要但困难的。在实践中，对于一个（强）防御方案，通常需要大量的手工工作来评估在给定特定（弱）漏洞时是否可以被绕过。现有的自动化利用生成解决方案，用于评估漏洞的可利用性，尚未解决这个问题。</p>\n<p>​\t在本文中，我们指出了一系列不破坏C++ ABI（应用程序二进制接口）的虚函数保护方案容易受到先进的COOPLUS攻击的威胁，即使给定的漏洞很弱。然后，我们提出了一个名为VScape的解决方案，用于评估虚函数保护方案对这种攻击的有效性。我们开发了VScape的原型，并利用它评估了11个CFI解决方案和14个包含Firefox和PyQt在内的C++应用程序的已知漏洞。结果表明，现实世界的应用程序存在大量可利用的虚函数调用，并且VScape可以用于生成可绕过已部署防御方案的工作利用程序，通过利用弱漏洞实现绕过。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtY2hlbi1rYWl4aWFuZy5wZGY=\">sec21-chen-kaixiang.pdf (usenix.org)</span></p>\n<h3 id=\"Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\"><a href=\"#Precise-and-Scalable-Detection-of-Use-after-Compacting-Garbage-Collection-Bugs\" class=\"headerlink\" title=\"Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs\"></a><strong>Precise and Scalable Detection of Use-after-Compacting-Garbage-Collection Bugs</strong></h3><p>​\t压缩垃圾收集(compact-gc)是一种通过重新安排活动对象和使用地址表更新其引用来提高内存利用率和减少内存碎片的方法。如果在compact-gc之后使用了未在地址表中注册的对象引用，则可能存在严重的use-after-free错误，因为活动对象可能会移动，但在compact-gc之后不会更新引用。我们将此称为use-after-compact-gc (use-after-cgc)错误。以前的工具已经尝试使用特定于目标的启发式方法静态地检测这些错误。然而，由于它们的路径不敏感分析和不精确的目标特异性启发式，它们有很高的假阳性和假阴性。</p>\n<p>​\t在本文中，我们提出了一个精确的、可扩展的静态分析器CGSan，用于查找use-after-cgc错误。CGSan通过过程内静态符号污染分析检测cgc后使用的候选错误，并通过约束不足的定向符号执行检查它们的可行性。为了减轻过程内分析的不完整性，我们采用了基于类型的污染策略。对于可扩展性，我们建议使用定向过程间控制流图，它通过排除与检查可行性无关的路径来减少搜索空间，以及定向调度，它优先考虑路径以快速检查可行性。我们在Google V8和Mozilla SpiderMonkey上评估了CGSan，我们发现了13个独特的使用后cgc错误，只有2个假阳性，而之前的两个工具遗漏了10个错误，总共有34个假阳性.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtaGFuLWh5dW5nc2Vvay5wZGY=\">sec21-han-hyungseok.pdf (usenix.org)</span></p>\n<h3 id=\"FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\"><a href=\"#FlowDist-Multi-Staged-Refinement-Based-Dynamic-Information-Flow-Analysis-for-Distributed-Software-Systems\" class=\"headerlink\" title=\"FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems\"></a><strong>FlowDist: Multi-Staged Refinement-Based Dynamic Information Flow Analysis for Distributed Software Systems</strong></h3><p>​\t动态信息流分析(DIFA)支持各种安全应用，如恶意软件分析和漏洞发现。然而，由于适用性、可移植性和可伸缩性方面的障碍，传统的DIFA方法对分布式软件的效用有限。我们提出了FlowDist，这是一个通用分布式软件的DIFA，可以克服这些挑战。FlowDist工作在纯应用程序级别，避免了平台定制，因此实现了高可移植性。它从全局部分顺序执行事件中推断出隐式的进程间依赖关系，以解决分布式软件的适用性。最重要的是，它为应用程序级DIFA引入了一种基于多阶段细化的方案，在这种方案中，通过廉价的预分析产生的方法级结果减少了昂贵的数据流分析，从而在保持有效性的同时实现了高可伸缩性。我们在12个真实的分布式系统上对FlowDist与两种同类工具进行了评估，结果显示其在实际效率和可扩展性方面具有卓越的有效性。它发现了18个已知漏洞和24个新漏洞，其中17个已确认，2个已修复。我们还提出并评估了FlowDist的两种替代设计，包括设计理由和不同的主题住宿。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjEtZnUteGlhb3Fpbi5wZGY=\">sec21-fu-xiaoqin.pdf (usenix.org)</span></p>\n<h3 id=\"Symbolic-execution-with-SymCC-Don’t-interpret-compile\"><a href=\"#Symbolic-execution-with-SymCC-Don’t-interpret-compile\" class=\"headerlink\" title=\"Symbolic execution with SymCC: Don’t interpret, compile!\"></a><strong>Symbolic execution with SymCC: Don’t interpret, compile!</strong></h3><p>​\t实际符号执行的主要障碍是速度，特别是与模糊测试等接近本地速度的解决方案相比。我们提出了一种基于编译的符号执行方法，其性能优于最先进的实现数量级。我们介绍了SymCC，这是一个基于llvm的C和c++编译器，它将concolic执行构建到二进制文件中。它可以被软件开发人员用作clang和clang++的临时替代品，并且我们展示了如何轻松地添加对其他语言的支持。与KLEE相比，SymCC的速度快了三个数量级，平均快了12个数量级。它的性能也优于Qsym, Qsym是一个最近表现出比其他实现有很大性能改进的系统，最高可达两个数量级，平均为10倍。在真实的软件上使用它，我们发现我们的方法始终达到更高的覆盖率，并且我们在经过大量测试的OpenJPEG项目中发现了两个漏洞，这些漏洞已经被项目维护者确认并分配了CVE标识符。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtcG9lcGxhdS5wZGY=\">sec20-poeplau.pdf (usenix.org)</span></p>\n<h3 id=\"Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\"><a href=\"#Everything-Old-is-New-Again-Binary-Security-of-WebAssembly\" class=\"headerlink\" title=\"Everything Old is New Again: Binary Security of WebAssembly\"></a><strong>Everything Old is New Again: Binary Security of WebAssembly</strong></h3><p>​\tWebAssembly是一种越来越流行的编译目标，通过严格分离代码和数据、强制类型和限制间接控制流，它被设计成在浏览器和其他平台上安全运行代码。尽管如此，内存不安全源语言中的漏洞可能会转化为WebAssembly二进制文件中的漏洞。在本文中，我们分析了WebAssembly二进制文件中的漏洞可被利用的程度，以及与本机代码的比较。我们发现许多经典的漏洞，由于常见的缓解措施，在原生二进制文件中不再被利用，在WebAssembly中完全暴露出来。此外，WebAssembly支持独特的攻击，例如覆盖假定的常量数据或使用堆栈溢出操作堆。我们提出了一组攻击原语，使攻击者能够(i)写入任意内存，(ii)覆盖敏感数据，以及(iii)通过转移控制流或操纵主机环境来触发意外行为。我们提供了一组易受攻击的概念验证应用程序以及完整的端到端漏洞，涵盖了三个WebAssembly平台。对编译到WebAssembly的实际二进制文件和SPEC CPU程序的经验风险评估表明，我们的攻击原语在实践中可能是可行的。总的来说，我们的发现显示WebAssembly中可能令人惊讶地缺乏二进制安全性。我们讨论了潜在的保护机制，以减轻由此产生的风险。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtbGVobWFubi5wZGY=\">sec20-lehmann.pdf (usenix.org)</span></p>\n<h3 id=\"AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\"><a href=\"#AURORA-Statistical-Crash-Analysis-for-Automated-Root-Cause-Explanation\" class=\"headerlink\" title=\"AURORA: Statistical Crash Analysis for Automated Root Cause Explanation\"></a><strong>AURORA: Statistical Crash Analysis for Automated Root Cause Explanation</strong></h3><p>​\t鉴于自动化软件测试技术的巨大成功，在实践中发现了大量的崩溃。确定崩溃的根本原因是一项耗时的工作，会导致发现崩溃和修复底层软件故障之间的不平衡。为了解决这个问题，已经提出了依赖于诸如反向执行和向后污染分析等技术的各种方法。然而，这些技术要么局限于特定的故障类型，要么向分析人员提供组装指令，但没有上下文信息或对潜在故障的解释。</p>\n<p>​\t在本文中，我们提出了一种自动化分析方法，它不仅可以识别给定二进制可执行文件的崩溃输入的根本原因，还可以为分析人员提供有关崩溃输入特征的错误行为的上下文信息。从单个崩溃输入开始，我们生成一组不同的类似输入，这些输入要么使程序崩溃，要么诱发良性行为。然后，我们在执行每个找到的输入时跟踪程序的状态，并生成谓词，即捕获崩溃和非崩溃输入之间的行为差异的简单布尔表达式。对所有谓词的统计分析使我们能够确定确定根本原因的谓词，从而不仅揭示了根本原因的位置，而且还向分析人员提供了在该位置显示的崩溃行为的解释。我们在一个叫做AURORA的工具中实现了我们的方法，并对25个不同的软件故障进行了评估。我们的评估表明，AURORA甚至能够发现复杂bug的根本原因。例如，在开发人员修复和崩溃位置之间执行了数百万条指令的情况下，它成功了。与现有方法相比，AURORA还能够处理根本原因与崩溃之间没有数据依赖关系的错误，例如类型混淆错误。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjBmYWxsX2JsYXp5dGtvX3ByZXB1Yi5wZGY=\">sec20fall_blazytko_prepub.pdf (usenix.org)</span></p>\n<h3 id=\"KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\"><a href=\"#KOOBE-Towards-Facilitating-Exploit-Generation-of-Kernel-Out-Of-Bounds-Write-Vulnerabilities\" class=\"headerlink\" title=\"KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities\"></a><strong>KOOBE: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities</strong></h3><p>​\t现代操作系统内核的整体性导致不断发现错误。 通常不清楚哪些错误值得修复，因为只有其中一部分可能严重到足以导致安全接管（即权限升级）。 因此，研究人员最近开始开发自动漏洞利用生成技术（针对 UAF bug）来协助 bug 分类过程。 在本文中，我们研究了 Linux 内核中的另一个顶级内存漏洞——堆中的越界（OOB）内存写入。 我们基于以下两个观察结果设计 KOOBE 来协助分析此类漏洞：(1) 令人惊讶的是，不同的 OOB 漏洞实例常常表现出广泛的功能。 (2) 内核漏洞利用本质上是多重交互的（即，漏洞利用涉及多个系统调用），这使得漏洞利用制作过程可以模块化。 具体来说，我们专注于提取 OOB 漏洞的功能，这将为后续的可利用性评估过程提供支持。 我们的系统构建在多个构建块上，包括用于发现隐藏功能的新型功能引导模糊解决方案，以及将功能组合在一起以进一步提高成功利用的可能性的方法。 在我们的评估中，我们通过详尽分析 17 个最新的 Linux 内核 OOB 漏洞（其中只有 5 个具有公开可用的漏洞）来证明 KOOBE 的适用性，其中 KOOBE 成功为其中 11 个漏洞生成了候选漏洞利用策略（包括 5 个没有公开的漏洞） 甚至分配了任何 CVE）。 随后，根据这些策略，我们能够为所有这些策略构建完全有效的漏洞利用。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAtY2hlbi13ZWl0ZW5nLnBkZg==\">sec20-chen-weiteng.pdf (usenix.org)</span></p>\n<h3 id=\"Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\"><a href=\"#Automatic-Techniques-to-Systematically-Discover-New-Heap-Exploitation-Primitives\" class=\"headerlink\" title=\"Automatic Techniques to Systematically Discover New Heap Exploitation Primitives\"></a><strong>Automatic Techniques to Systematically Discover New Heap Exploitation Primitives</strong></h3><p>滥用堆分配器元数据的利用技术因其通用性（即独立于应用程序）和强大功能（即绕过现代缓解措施）而被广泛研究。然而，这些技术通常被认为是艺术，因此发现它们的方法仍然是临时的、手动的和针对特定分配器的。</p>\n<p>在本文中，我们提出了一种自动工具 ArcHeap，用于系统地发现尚未开发的堆利用原语，而不管它们的底层实现是什么。ArcHeap 的主要理念是让计算机自主探索空间，其概念类似于模糊测试，方法是指定一组现代堆分配器的常见设计和漏洞根源作为模型，并提供堆操作和攻击能力作为动作。在探索过程中，ArcHeap 会检查这些操作的组合是否有可能用于构建漏洞利用原语，如任意写入或重叠块。作为证明，ArcHeap 会生成工作 PoC，演示所发现的利用技术。</p>\n<p>我们用 ptmalloc2 和其他 10 个分配器对 ArcHeap 进行了评估，在 ptmalloc2 中发现了 5 种以前未知的利用技术，并针对 10 个分配器中的 7 个（包括注重安全的分配器 DieHarder）发现了几种利用技术。为了证明 ArcHeap 方法在其他领域的有效性，我们还研究了安全特性和利用原语是如何在不同版本的 ptmalloc2 中演变的。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudXNlbml4Lm9yZy9zeXN0ZW0vZmlsZXMvc2VjMjAteXVuLnBkZg==\">sec20-yun.pdf (usenix.org)</span></p>\n<h2 id=\"S-amp-P\"><a href=\"#S-amp-P\" class=\"headerlink\" title=\"S&amp;P\"></a>S&amp;P</h2><h3 id=\"Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\"><a href=\"#Karonte-Detecting-Insecure-Multi-binary-Interactions-in-Embedded-Firmware\" class=\"headerlink\" title=\"Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware\"></a>Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware</h3><ul>\n<li>基于污点分析的多二进制文件之间交互过程漏洞挖掘</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1Mjc5Ng==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152796</span></li>\n</ul>\n<h3 id=\"SAVIOR-Towards-Bug-Driven-Hybrid-Testing\"><a href=\"#SAVIOR-Towards-Bug-Driven-Hybrid-Testing\" class=\"headerlink\" title=\"SAVIOR: Towards Bug-Driven Hybrid Testing\"></a>SAVIOR: Towards Bug-Driven Hybrid Testing</h3><ul>\n<li>传统的模糊测试加混合执行的方法会测试许多无意义的代码路径，SAVIOR能够推理出漏洞的可行性，筛选出更可行的程序执行路径。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTE1MjY4Mg==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9152682</span></li>\n</ul>\n<h3 id=\"Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\"><a href=\"#Goshawk-Hunting-Memory-Corruptions-via-Structure-Aware-and-Object-Centric-Memory-Operation-Synopsis\" class=\"headerlink\" title=\"Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis\"></a>Goshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsis</h3><ul>\n<li><p>使用自然语言处理和数据流分析等技术来对内存管理函数进行抽象，从而有效地检测定制化内存管理机制造成的内存破坏缺陷</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cDovL2N5YmVyc2VjLnVzdGMuZWR1LmNuLzIwMjIvMDYwNi9jMjM4NDdhNTU3NDY3L3BhZ2UuaHRt\">http://cybersec.ustc.edu.cn/2022/0606/c23847a557467/page.htm</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTgzMzYxMw==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9833613</span></p>\n</li>\n</ul>\n<h3 id=\"SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\"><a href=\"#SELECTFuzz：Efficient-Directed-Fuzzing-with-Selective-Path-Exploration\" class=\"headerlink\" title=\"SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration\"></a>SELECTFuzz：Efficient Directed Fuzzing with Selective Path Exploration</h3><ul>\n<li>能够将目标程序中的相关代码与不相关代码区分开来，这些代码不会触发目标代码中的漏洞。selectfuzz可以选择性地探索相关的程序路径，以实现高效的崩溃再现和漏洞检测。它确定了两种类型的相关代码-路径发散型代码和数据依赖型代码，它们分别捕获与目标代码的控制数据依赖关系。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWNsYWIuY3NlLmN1aGsuZWR1LmhrL3BhcGVycy9zcDIzX3NlbGVjdGZ1enoucGRm\">https://seclab.cse.cuhk.edu.hk/papers/sp23_selectfuzz.pdf</span></li>\n</ul>\n<h3 id=\"AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\"><a href=\"#AEM-Facilitating-Cross-Version-Exploitability-Assessment-of-Linux-Kernel-Vulnerabilities\" class=\"headerlink\" title=\"AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities\"></a>AEM: Facilitating Cross-Version Exploitability Assessment of Linux Kernel Vulnerabilities</h3><ul>\n<li>内核漏洞迁移</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLndvaGluLm1lL3Bvc3RzL3BhcGVyLWFlbS8=\">https://blog.wohin.me/posts/paper-aem/</span></li>\n</ul>\n<h2 id=\"NDSS\"><a href=\"#NDSS\" class=\"headerlink\" title=\"NDSS\"></a>NDSS</h2><h3 id=\"Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\"><a href=\"#Towards-Automatic-and-Precise-Heap-Layout-Manipulation-for-General-Purpose-Programs\" class=\"headerlink\" title=\"Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs\"></a>Towards Automatic and Precise Heap Layout Manipulation for General-Purpose Programs</h3><ul>\n<li>一种创新的解决方案，用于自动和精确地操作通用程序的堆布局</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmRzcy1zeW1wb3NpdW0ub3JnL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIzLzAyL25kc3MyMDIzX3MyMzJfcGFwZXIucGRm\">https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_s232_paper.pdf</span></li>\n</ul>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\"><a href=\"#LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers\" class=\"headerlink\" title=\"LibAFL: A Framework to Build Modular and Reusable Fuzzers\"></a>LibAFL: A Framework to Build Modular and Reusable Fuzzers</h3><ul>\n<li>集成了多种常用的fuzz方案来进行</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuczMuZXVyZWNvbS5mci9kb2NzL2NjczIyX2Zpb3JhbGRpLnBkZg==\">https://www.s3.eurecom.fr/docs/ccs22_fioraldi.pdf</span></li>\n</ul>\n<h3 id=\"Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\"><a href=\"#Evocatio-Conjuring-Bug-Capabilities-from-a-Single-PoC\" class=\"headerlink\" title=\"Evocatio: Conjuring Bug Capabilities from a Single PoC\"></a>Evocatio: Conjuring Bug Capabilities from a Single PoC</h3><ul>\n<li>分析触发漏洞的原因，并自动生成触发漏洞的输入</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNTQ4NjA2LjM1NjA1NzU=\">https://dl.acm.org/doi/pdf/10.1145/3548606.3560575</span></li>\n</ul>\n<h3 id=\"Binary-Control-Flow-Trimming\"><a href=\"#Binary-Control-Flow-Trimming\" class=\"headerlink\" title=\"Binary Control-Flow Trimming\"></a>Binary Control-Flow Trimming</h3><ul>\n<li>提出了修剪无关代码的方法</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zMzE5NTM1LjMzNDU2NjU=\">https://dl.acm.org/doi/pdf/10.1145/3319535.3345665</span></li>\n</ul>\n<h3 id=\"Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\"><a href=\"#Gollum-Modular-and-Greybox-Exploit-Generation-for-Heap-Overflows-in-Interpreters\" class=\"headerlink\" title=\"Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters\"></a>Gollum: Modular and Greybox Exploit Generation for Heap Overflows in Interpreters</h3><ul>\n<li>自动化堆溢出利用方法<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3Mub3guYWMudWsvdG9tLm1lbGhhbS9wdWIvSGVlbGFuLTIwMTktR01HLnBkZg==\">https://www.cs.ox.ac.uk/tom.melham/pub/Heelan-2019-GMG.pdf</span></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\"><a href=\"#Statically-Discovering-High-Order-Taint-Style-Vulnerabilities-in-OS-Kernels\" class=\"headerlink\" title=\"Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels\"></a>Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels</h3><ul>\n<li>采用基于摘要的新型高阶污点流构建方法来有效地枚举交叉输入污点流</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODQ3OTg=\">3460120.3484798 (acm.org)</span></li>\n</ul>\n<h3 id=\"Learning-to-Explore-Paths-for-Symbolic-Execution\"><a href=\"#Learning-to-Explore-Paths-for-Symbolic-Execution\" class=\"headerlink\" title=\"Learning to Explore Paths for Symbolic Execution\"></a>Learning to Explore Paths for Symbolic Execution</h3><ul>\n<li>Learch，能够有效地选择有希望的状态进行符号执行，以解决路径爆炸问题</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9maWxlcy5zcmkuaW5mLmV0aHouY2gvd2Vic2l0ZS9wYXBlcnMvY2NzMjEtbGVhcmNoLnBkZg==\">ccs21-learch.pdf (ethz.ch)</span></li>\n</ul>\n<h3 id=\"Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\"><a href=\"#Automated-Bug-Hunting-With-Data-Driven-Symbolic-Root-Cause-Analysis\" class=\"headerlink\" title=\"Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis\"></a>Automated Bug Hunting With Data-Driven Symbolic Root Cause Analysis</h3><ul>\n<li>基于执行轨迹的符号重构状态的漏洞挖掘方法，以更好地检测和分析用户程序及其导入库中的溢出、使用后释放、双重释放和格式化字符串漏洞的根本原因</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zNDYwMTIwLjM0ODUzNjM=\">3460120.3485363 (acm.org)</span></li>\n</ul>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><h3 id=\"From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\"><a href=\"#From-Release-to-Rebirth-Exploiting-Thanos-Objects-in-Linux-Kernel\" class=\"headerlink\" title=\"From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel\"></a>From Release to Rebirth: Exploiting Thanos Objects in Linux Kernel</h3><ul>\n<li>提出了一种多功能的利用策略，可以将弱利用原语转换为强利用原语</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9OTk3MDM3Ng==\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=9970376</span></li>\n</ul>\n<h3 id=\"Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\"><a href=\"#Tetris-Automatic-UAF-Exploit-Generation-by-Manipulating-Layout-based-on-Reactivated-Paths\" class=\"headerlink\" title=\"Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths\"></a>Tetris: Automatic UAF Exploit Generation by Manipulating Layout based on Reactivated Paths</h3><ul>\n<li>一个自动生成用户空间 UAF 漏洞利用的系统，能够自动化构建需要的堆布局</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</span></li>\n</ul>\n<h3 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h3><ul>\n<li>识别原语的新方法</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL3N0YW1wL3N0YW1wLmpzcD90cD0mYXJudW1iZXI9MTAwNTMyNDI=\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=10053242</span></li>\n</ul>\n<hr>\n<p>- </p>\n",
            "tags": [
                "Paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "url": "https://alazymechnaic.github.io/2023/08/21/aeg-reviwer/",
            "title": "AEG_reviwer",
            "date_published": "2023-08-21T06:40:17.000Z",
            "content_html": "<h2 id=\"Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\"><a href=\"#Detecting-Exploit-Primitives-Automatically-for-Heap-Vulnerabilities-on-Binary-Programs\" class=\"headerlink\" title=\"Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs\"></a>Detecting Exploit Primitives Automatically for Heap Vulnerabilities on Binary Programs</h2><hr>\n<p>文章贡献：</p>\n<ul>\n<li>提出了primitive-crucialbehaviors analysis  ，该方法用于在符号执行过程中查找关键执行结构</li>\n<li>利用模糊测试和符号执行设计了一套攻击原语确定方法</li>\n<li>设计DEPA方法用于检测堆溢出相关原语</li>\n</ul>\n<p>文章提出了一种新的堆溢出漏洞原语的查找方法DEPA，基于以下两种技术：</p>\n<ul>\n<li>primitive-crucial-behavior analysis module <ul>\n<li>该模块对目标程序进行符号执行，在执行过程中进行primitive-crucial-behavior analysis（关键原语行为分析）</li>\n<li>primitive-crucial-behavior   ：实现原语的关键结构，此类结构往往与程序语义以及系统API有关<ul>\n<li>如何精准识别这些结构？</li>\n<li>如何利用该结构进行漏洞的发现？</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>exploit primitive determination method  ：</li>\n</ul>\n<p><strong>事件循环驱动（event loop driven）</strong>：例如通过交互式进行功能分发的程序，此类程序在一次运行过程中接收一次输入，选择一种处理方式，而后结束。在对此类程序分析的过程中很难使用fuzzing或者符号执行的方法来探索程序的深层状态。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/",
            "url": "https://alazymechnaic.github.io/2023/07/04/bopc-data-only-attack/",
            "title": "BOPC_Data_Only_Attack",
            "date_published": "2023-07-04T09:09:42.000Z",
            "content_html": "<h2 id=\"Block-Oriented-Programming-Automating-Data-Only-Attacks\"><a href=\"#Block-Oriented-Programming-Automating-Data-Only-Attacks\" class=\"headerlink\" title=\"Block Oriented Programming: Automating Data-Only Attacks\"></a>Block Oriented Programming: Automating Data-Only Attacks</h2><hr>\n<p>目的： 能够依照代码块组指出包含特定语义的结构。构造出了一种自己的语言SPL，生成SPL payload来组织成特定的语义。</p>\n<p>前提： 一个任意内存写原语（能够向任意位置中写入任意值），一个任意内存读原语（可选），以及执行完上述两个原语后自然到达的位置。（其实本质上来讲改文章的贡献在于如何充分利用给一个AWP(任意内存写原语)</p>\n<p>流程：</p>\n<ul>\n<li>BOPC提供了一个面向exploit编程的语言SPL，使分析人员能够定义一个独立于目标问题和底层架构的exploit</li>\n<li>在目标程序中搜索相应的功能块作为基本块</li>\n<li>搜索Dispatcher块用于将各个功能块链接在一起</li>\n<li>依照AWP构造出相应的BOP链的payload</li>\n</ul>\n<p>关键技术：</p>\n<p><strong>Block Oriented Programming</strong>：</p>\n<ul>\n<li>BOP链由表示一条SPL语义的BOP gadget和链接这些BOP gadget的DIspatcher组成</li>\n<li>将每个基本块抽象为块约束摘要便于与SPL语言的一一对应。但是由于进入该块的时候上下文的不同，每一个块可能会表现出不同的功能（这里怎么进行抽象的？</li>\n<li>构造BOP链本身是NP难的问题</li>\n</ul>\n<p><strong>Block Constraint Summaries</strong>：  </p>\n<p>​\t将程序的输入映射到程序执行路径是NP难的问题，<strong>使用启发式的方法帮助查找路径中所有可能的路径</strong>。</p>\n<ul>\n<li><p>对单个块做符号执行，收集约束，做出输入与输出之间的映射关系。</p>\n</li>\n<li><p>要查找块和SPL语句之间的匹配，块必须执行该SPL语句所需的所有操作。</p>\n</li>\n<li><p>BOPC依照语义计算一组候选功能块和相应的分发器，但是很可能选出的几个gadget之间并不存在合法的路径，或者符合CFI的路径</p>\n</li>\n<li><p>BOP gadget依照选取的块不同，其本身也是不稳定的，前面的gadget很可能会改变后面gadget的性质，同时不断增加gadget也会增加当前路径的约束</p>\n</li>\n</ul>\n<p><strong>解决方案</strong>：BOPC使用当前程序的BOP块的接近度用于评分排序，以及delta图来组织BOP gadget序列</p>\n<ul>\n<li><strong>BOP块接近度</strong>：</li>\n<li><strong>delta图</strong>：用于表示当前搜寻分发器block的状态。<ul>\n<li>存储每一个功能块到下一个候选块之前的最短路径</li>\n<li>任意拼接两个块之间的路径本身是一个NP难的问题</li>\n<li>功能块之间的选择依据是，更短的路径可能会导致更合适的约束</li>\n<li>delta图中记录了每一个功能块，功能块的边是两个功能块之间转移需要经过的block数量.（但是在计算两个block之间的路径时，静态CFG上是可以有多个重点，但在实际执行时只会有一个终点。其实就是对控制流进行枚举的过程，你怎么知道实际路径是哪些的</li>\n<li>文章提出的路径算法是迪杰斯特拉算法的递归版本，并且避免了所有的破坏块。<ul>\n<li>迪杰斯特拉算法：不断加入新的结点作为中间跳转结点，计算出最短距离</li>\n<li>算法逻辑：初始分析时将相邻的边的开销设置为1。当其遇到call指令时，就进行递归地计算，找到每个功能块之间的最短路径</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BOP gadget缝合：<ul>\n<li>从每一个BOPgadget开始不断向后进行符号执行读入新的BOP功能块，直到最后一个块。</li>\n</ul>\n</li>\n</ul>\n<p>在进行组织的过程中需要在BOP gadget间拼接不会影响当前程序执行流的基本块。使用delta 图来搜索当前所有的调度块。</p>\n",
            "tags": [
                "paper"
            ]
        },
        {
            "id": "https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/",
            "url": "https://alazymechnaic.github.io/2023/06/27/viper-ssgvdoa/",
            "title": "VIPER_SSGVDOA",
            "date_published": "2023-06-27T01:50:02.000Z",
            "content_html": "<h2 id=\"VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\"><a href=\"#VIPER-Spotting-Syscall-Guard-Variables-for-Data-Only-Attacks\" class=\"headerlink\" title=\"VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks\"></a>VIPER: Spotting Syscall-Guard Variables for Data-Only Attacks</h2><hr>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li>文章的主要目的是检查那些影响数据流，促使程序运行至关键系统调用的关键变量。VIPER能够自动化地查找实现对系统调用保护分支和变量的自动和可扩展检测</li>\n<li>两个关键定义：Syscall-Guard Variables，syscallguard变量决定是否调用与安全相关的系统调用 ，因此它们的值对程序安全性有直接影响。这意味着它们应该被视为关键数据。同样也衍生出，syscall-Guard branch，用于决定是否会执行当前的系统调用。</li>\n<li>一个关键方法： 文章提出了分支强制（branch force），它有意地翻转执行过程中的每个条件分支，并检查是否调用了新的与安全相关的syscalls。如果是，则进行数据流分析以估计通过常见内存错误翻转这些分支的可行性。</li>\n<li>基本逻辑：程序想要通过数据流攻击实现一定的攻击语义，必须要依赖于一定的系统调用实现。然而系统调用在处理不受信任的输入前一定会存在一定的检查操作。</li>\n</ul>\n<h3 id=\"识别困难\"><a href=\"#识别困难\" class=\"headerlink\" title=\"识别困难\"></a>识别困难</h3><p>​\t关键变量可能会以任何数据类型，任何存储位置存在。这会导致传统的分析方式失效。况且对于大型程序，进行变量的推断是十分困难的。</p>\n<h3 id=\"攻击的前提\"><a href=\"#攻击的前提\" class=\"headerlink\" title=\"攻击的前提\"></a>攻击的前提</h3><ul>\n<li>不管程序是什么，大多数纯数据攻击都依赖于与安全相关的系统 调用(简称系统调用)来实现最终目标。（其实就是最终的攻击语义一定要依赖于系统调用的存在）</li>\n<li>关键的系统调用函数前一定会存在一些分支检查</li>\n</ul>\n<h3 id=\"技术方案\"><a href=\"#技术方案\" class=\"headerlink\" title=\"技术方案\"></a>技术方案</h3><ul>\n<li>使用相同的输入进入程序，找到分支，进行强制跳转。如果强制跳转之后触发了程序的bug，那么该分支就作为候选分支</li>\n<li>在一次执行中翻转分支条件，找到新的分支条件生成新的路径，查找新的系统调用</li>\n</ul>\n<h3 id=\"challenge\"><a href=\"#challenge\" class=\"headerlink\" title=\"challenge\"></a>challenge</h3><ul>\n<li>修剪掉无用的分支，并且评估单个变量的影响是十分有挑战性的。符号执行能够找到从程序入口到关键系统调用的路径，但是并不能给出，当前路径上的哪些分支是更重要的，因此只能对所有的分支都做分析</li>\n<li>找到一种高效的分析方法很困难，使用间接函数调用的程序太多了，使用静态分析十分不切实际</li>\n</ul>\n<h3 id=\"approaches\"><a href=\"#approaches\" class=\"headerlink\" title=\"approaches\"></a>approaches</h3><ul>\n<li><strong>branch force</strong>：收集候选的分支变量<ul>\n<li>思想：假设当前分支时关键保护分支，那么该分支向后执行仅仅只能有其中一个分支触发当前程序中的系统调用，如果两个都能触发，那这个分支肯定不是关键保护分支。如果都不能触发，则该分支对于当前程序的安全性并不重要。</li>\n<li>执行流程：<ul>\n<li>以相同的输入I执行程序，将遇到的每一个分支进行强制翻转（并不改变输入），并且</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016500.png\" alt=\"image-20230628155213365\"></p>\n<ul>\n<li><strong>dynamic backward data-flow</strong>：检查每个变量被覆盖利用的可能性</li>\n<li><strong>Corruptibility Assessment</strong> ： 使用数据流来评估每一个分支变量被内存错误污染的可能性。同时使用动态数据流分析，在过程中根据变量的存储位置和内存的声明周期对内存进行定性，分别视为容易利用和难利用三种等级。全局变量相对局部变量更容易被利用，生命周期越长，被修改次数越多，能被利用的概率越高。依此能够筛选出被破坏概率更高的关键变量。</li>\n</ul>\n<h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016755.png\" alt=\"image-20230628205325968\"></p>\n<p>VIPER在对程序分析后，最终会报告当前程序中存在的各种危险的关键分支，系统调用及其保护变量。</p>\n<p>​\tBranchForcer运行包含原始输入的程序，并记录执行的分支和系统调用。然后，使用相同的输入多次运行程序，并为每次新的执行翻转一个不同分支的目标。如果重新执行触发了新的与安全性相关的系统调用，我们将当前分支添加到候选列表中。对于每个候选分支，VariableRator再次运行程序，以记录执行的完整跟踪，包括分支序列、所有内存访问地址和进程内存布局。利用记录的轨迹对程序IR进行反向数据流分析。VariableRator检查内存布局以确定每个内存节点的位置，并计算内存写指令的数量以估计节点的生命周期</p>\n<h3 id=\"分支记录\"><a href=\"#分支记录\" class=\"headerlink\" title=\"分支记录\"></a>分支记录</h3><p>​\t由于在执行的过程中可能会出现路径爆炸以及某些分支翻转了没有意义，因此只在固定路径上做分支翻转。每个分支只会做一次翻转。为了提高效率，使用多线程尽心探索。</p>\n<p>​\t每次使用相同的输入和不同的分支翻转执行程序，如果遇到新的系统调用就将当前路径做为候选路径进行存储，然后进行完整的分支执行分析，利用数据流进行后向切片，确定所有与分支保护状态相关的指令。利用值集分析来找到控制变量中所有可能的值。</p>\n<p>​\t</p>\n",
            "tags": [
                "paper"
            ]
        }
    ]
}