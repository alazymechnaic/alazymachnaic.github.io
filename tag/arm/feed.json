{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"arm\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/10/03/arm-base/",
            "url": "https://alazymechnaic.github.io/2023/10/03/arm-base/",
            "title": "Arm_Base",
            "date_published": "2023-10-03T06:28:56.000Z",
            "content_html": "<h2 id=\"ARM\"><a href=\"#ARM\" class=\"headerlink\" title=\"ARM\"></a>ARM</h2><p>​\t本文用于介绍arm指令集的基本架构，特性。</p>\n<h3 id=\"寄存器用法\"><a href=\"#寄存器用法\" class=\"headerlink\" title=\"寄存器用法\"></a>寄存器用法</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">通用寄存器（General-Purpose Registers）：\n\nr0~r3 主要用于子程序间传递参数\n\nr4~r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量\n\nr12 用作子程序间scratch 寄存器，即 ip 寄存器\n\nr13 通常用做栈指针，即 sp\n\nr14 寄存器又被称为连接寄存器（lr），用于保存子程序以及中断的返回地址\n\nr15 用作程序计数器（pc），由于 ARM 采用了流水线机制，当正确读取了 PC 的值后，该值为当前指令地址加 8 个字节，即 PC 指向当前指令的下两条指令地址。\n\nCPSR和SPSR都是程序状态寄存器，其中SPSR是用来保存中断前的CPSR中的值，以便在中断返回之后恢复处理器程序状态<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"基本指令\"><a href=\"#基本指令\" class=\"headerlink\" title=\"基本指令\"></a>基本指令</h3><h3 id=\"常用指令集\"><a href=\"#常用指令集\" class=\"headerlink\" title=\"常用指令集\"></a>常用指令集</h3><p>ARM中的立即数常用井号在前进行标注，#立即数</p>\n<h4 id=\"数据定义\"><a href=\"#数据定义\" class=\"headerlink\" title=\"数据定义\"></a>数据定义</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">DATA1 DCB 10,20,30,40 ;分配一片连续的字节存储单元并初始化\nDATA2 DCD 10,20,30,40 ;分配一片连续的字存储单元并初始化\nBUF SPACE 100 ;给BUF分配100字节的存储单元并初始化为0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"局部符号\"><a href=\"#局部符号\" class=\"headerlink\" title=\"局部符号\"></a>局部符号</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">引用格式：%{F|B|A|T} N{routname}\n%: 引用符号，对一个局部标号产生引用。\nF：指示编译器只向前搜索。B：指示编译器只向后搜索\nA：指示编译器搜索宏的所有宏命令层。T：指示编译器搜索宏的当前层\nN：局部标号的名字。routename：局部标号的作用范围名称，使用ROUT定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"赋值操作\"><a href=\"#赋值操作\" class=\"headerlink\" title=\"赋值操作\"></a>赋值操作</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">a SETA 10 ;给算术变量a赋值为10\na SETL 10 ;给逻辑变量a赋值为10\na SETS “ss” ;给字符串变量a赋值为“ss”<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"加载操作\"><a href=\"#加载操作\" class=\"headerlink\" title=\"加载操作\"></a>加载操作</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)\n\n(2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：\n\nLDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)\n\nLDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)\n\n(3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：\n\nLDR R1,[R0,R2,LSL #2] ;将R0+R2*4地址处的数据读出，保存到R1中（R0，R2的值不变）\n\nLDR R1,[R0,-R2,LSL #2];将R0-R2*4地址处的数据计读出，保存到R1中(R0，R2的值不变)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>STR指令以此类推</p>\n<h3 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h3><ul>\n<li><strong>强制跳转指令</strong>：B 目标地址</li>\n</ul>\n<pre class=\"line-numbers language-assemblu\" data-language=\"assemblu\"><code class=\"language-assemblu\">B（Branch）：无条件分支指令，用于无条件跳转到目标地址。\n\n示例：B label，跳转到标签为 \"label\" 的位置。\nBL（Branch with Link）：带链接的分支指令，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中。\n\n示例：BL subroutine，跳转到子程序 \"subroutine\" 并保存返回地址。\nBX（Branch and Exchange）：分支并切换指令，用于根据寄存器的值跳转到不同的地址，并切换到新的执行状态。\n\n示例：BX Rn，根据寄存器 Rn 的值跳转到相应的地址。\nBLX（Branch with Link and Exchange）：带链接的分支并切换指令，结合了 BL 和 BX 的功能，用于跳转到目标地址，并将返回地址保存在链接寄存器（LR）中，并切换到新的执行状态。\n\n示例：BLX Rn，根据寄存器 Rn 的值跳转到相应的地址，并保存返回地址。\nCMP/BGT/BLT/BGE/BLE（Compare and Branch）：比较和分支指令，用于将两个操作数进行比较，并根据比较结果条件跳转到相应的地址。\n\n示例：CMP Rn, Rm，比较寄存器 Rn 和 Rm 的值。\nBGT label，如果 Rn 大于 Rm，则跳转到标签为 \"label\" 的位置。\nCBZ/CMN（Compare and Branch Zero/Non-zero）：比较并根据零/非零跳转指令，用于比较寄存器的值，并根据比较结果是否为零进行条件跳转。\n\n示例：CBZ Rn, label，如果 Rn 的值为零，则跳转到标签为 \"label\" 的位置<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyYW5rX3p5cC9hcnRpY2xlL2RldGFpbHMvODgyMDIzNDc=\">https://blog.csdn.net/frank_zyp/article/details/88202347</span></p>\n",
            "tags": [
                "arm"
            ]
        }
    ]
}