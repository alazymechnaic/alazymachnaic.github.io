{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"dataflow\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/09/30/shu-ju-liu-fen-xi/",
            "url": "https://alazymechnaic.github.io/2023/09/30/shu-ju-liu-fen-xi/",
            "title": "数据流分析",
            "date_published": "2023-09-30T06:48:10.000Z",
            "content_html": "<h1 id=\"DataFlow-Analysis\"><a href=\"#DataFlow-Analysis\" class=\"headerlink\" title=\"DataFlow Analysis\"></a>DataFlow Analysis</h1><hr>\n<h2 id=\"数据流分析的作用\"><a href=\"#数据流分析的作用\" class=\"headerlink\" title=\"数据流分析的作用\"></a>数据流分析的作用</h2><ul>\n<li><p><strong>简化执行代码</strong>:</p>\n<ul>\n<li>```c<br>// 在下面代码<br>x = a + b;<br>x = 5 * 2;<br>// 可以直接简化为<br>x = 10;<figure class=\"highlight llvm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><br>- **变量取值分析**<br><br>  - ```<span class=\"hljs-keyword\">c</span><br>    a <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>    b <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span><br>    if (...) <span class=\"hljs-keyword\">x</span> <span class=\"hljs-operator\">=</span> a + <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span><br>    else <span class=\"hljs-keyword\">x</span> <span class=\"hljs-operator\">=</span> b + <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">x</span> + <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>    // 虽然程序复杂但是可以直接简化为<span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span><br>    <span class=\"hljs-keyword\">c</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">7</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></tbody></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"技术划分\"><a href=\"#技术划分\" class=\"headerlink\" title=\"技术划分\"></a>技术划分</h2><p>示例代码如下：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-number\">1.</span>   k = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">2.</span>   <span class=\"hljs-keyword\">if</span> (...) {<br><span class=\"hljs-number\">3.</span>     a = k + <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">4.</span>     x = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-number\">5.</span>   } <span class=\"hljs-keyword\">else</span> {<br><span class=\"hljs-number\">6.</span>     a = k * <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">7.</span>     x = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-number\">8.</span>   }<br><span class=\"hljs-number\">9.</span>   k = a;<br><span class=\"hljs-number\">10.</span>  <span class=\"hljs-keyword\">while</span> (...) {<br><span class=\"hljs-number\">11.</span>     b = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-number\">12.</span>     x = a + k;<br><span class=\"hljs-number\">13.</span>     y = a * b;<br><span class=\"hljs-number\">14.</span>     k++;<br><span class=\"hljs-number\">15.</span>  }<br><span class=\"hljs-number\">16.</span>  print(a+x);<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a><em>Constant Propagation</em></h3><p>​\tconstant propagation本质是分析程序中某些变量的值的集合，表现为（变量，取值）的键值对</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309301506330.png\" alt=\"image-20230930150627177\"></p>\n<h3 id=\"Live-Variable-Analysis\"><a href=\"#Live-Variable-Analysis\" class=\"headerlink\" title=\"Live-Variable Analysis\"></a><em>Live-Variable Analysis</em></h3><p>​\t该分析的目的是找到当前时刻中的哪些变量，在内容被覆盖之前可能会被使用，这类变量称为live-Variable。该分析方式属于backward may的分析方法，需要依赖后续代码来生成前面的变量使用情况。</p>\n<h2 id=\"Define-DataFlow-Problem\"><a href=\"#Define-DataFlow-Problem\" class=\"headerlink\" title=\"Define DataFlow Problem\"></a>Define DataFlow Problem</h2><p>​\t在定义数据流问题之前需要先定义两个问题，第一个是<strong>前向传播</strong>（例如，constant propagation）问题，第二个是<strong>后向传播</strong>（例如，live-Variable分析）问题。常见的数据流分析中包含的往往是may和must问题，例如live分析的时候，只能说某个变量在某个节点的存活状态时may，但是在前向传播时某个变量的取值是must。</p>\n<h3 id=\"DataFlow-Problem\"><a href=\"#DataFlow-Problem\" class=\"headerlink\" title=\"DataFlow Problem\"></a>DataFlow Problem</h3><ul>\n<li>在程序开始执行时有哪些信息</li>\n<li>当一个结点存在多于一个的入度边时，如何将两个入度的信息进行合并？</li>\n<li>当每一个结点执行结束后，如何影响当前的数据流状态？</li>\n</ul>\n<p>在数据流分析中的相关定义如下：</p>\n<ul>\n<li>CFG</li>\n<li>a domain D of “dataflow facts” ： 这里给出的定义中，DataFlow facts是指在constant propagation中出现的变量与其对应值的键值对集合，这里的domain就是该集合的幂集，相应的live-variable分析中的就是变量集合的幂集</li>\n<li>a dataflow fact “init” ： 定义前向分析的起始位置或者后向分析的结束状态。这里两种分析的init状态都是空,因为在反向扫描时，从程序结束位置开始，此时的所有变量都寄了。</li>\n<li>an operator ⌈⌉ (used to combine incoming information from multiple predecessors)，该运算符在前向传播时用作交操作，在进行后向传播时用于并操作。只有当变量x在p1和p2之后都具有值v时，才能确定在节点n之前，变量x的值也是v。在”may”类型的数据流问题中，组合操作符⌈⌉通常是类似于并集的操作符，而在”must”类型的问题中，它通常是类似于交集的操作符。</li>\n</ul>\n<p>$$<br>fn(S) = (S - KILLn) ∪ GENn<br>$$</p>\n<p>​\t其中KILLn是在节点n处定义的变量集合，GENn是在节点n处使用的变量集合。对于不对任何变量进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量加上在节点n处被使用的变量。对于对变量x进行赋值的节点，节点n之前的活跃变量是节点n之后的活跃变量中排除变量x后的部分，再加上在节点n处使用的变量（包括变量x，如果它在节点n处既被定义又被使用）。<strong>注意这里是一个反向分析的过程，n处声明的变量定义为kill是因为再向前扫描的话，变量肯定是不存在的。如果在结点n中被用到了，则表明在n之前肯定是活的。</strong></p>\n<h2 id=\"Solving-Dataflow-Problem\"><a href=\"#Solving-Dataflow-Problem\" class=\"headerlink\" title=\"Solving Dataflow Problem\"></a>Solving Dataflow Problem</h2><p>​\t本文中提到的分析方法是针对某个基本块结点n的分析方法。但是为了保证每个节点</p>\n<h3 id=\"The-“Meet-Over-All-Paths”-Solution\"><a href=\"#The-“Meet-Over-All-Paths”-Solution\" class=\"headerlink\" title=\"The “Meet Over All Paths” Solution\"></a>The “Meet Over All Paths” Solution</h3><p>​\tMOP的思想是尽可能多地结算到达节点n时的数据流情况，也就是要考虑到所有的路径，并取∩运算。然而这个结果也是“尽可能对”的结果。MOP方案考虑了所有到达结点n的路径上的数据流状况，但即使是这种分析方式也有可能是过于保守的，因为有些路径未必是实际可执行的，例如永真/永假式的存在，或者谓词之间不独立（一个表达式的正确与否与另一个表达式相关）。</p>\n<h3 id=\"MOP的问题\"><a href=\"#MOP的问题\" class=\"headerlink\" title=\"MOP的问题\"></a>MOP的问题</h3><p>​\tMOP方式的本质是枚举尽可能多的路径来计算其上的数据流，然而对于一些循环（路径爆炸相关）的问题中，MOP方式是结束不了的。</p>\n<p>​\t<em>As we shall see, if those functions are <em>distributive</em>, then the solution that we compute is identical to the MOP solution. If the functions are <em>monotonic</em>, then the solution may not be identical to the MOP solution, but is a conservative approximation.</em></p>\n<p>​\t这里贴一下原文吧，文中说如果这些函数满足分配律（distributive）的性质，那么我们计算得到的解将与MOP解相同。如果数据流函数是单调的（monotonic），那么计算得到的解可能与MOP解不完全相同，但是它是一种保守的近似。</p>\n<p>​\t文中给出的解决方法如下：</p>\n<p>n.before：n执行之前的信息，<br>n.after：n执行之后的信息。</p>\n<p>这些n.before和n.after是我们方程的变量，其定义如下（对于每个节点n有两个方程）：<br>        <strong>n.before = ∩(p1.after, p2.after, …)</strong><br>其中p1、p2等是n在CFG中的前驱节点（∩是此数据流问题的组合运算符）。<br>        <strong>n.after = fn(n.before)</strong></p>\n<p>也就是在结点n之前的状态信息是路径p1到pn的数据流的交集。结点n之后的状态由n之前的状态计算得出。通过解这些方程，我们可以计算出每个节点的数据流信息，从而得到整个程序的数据流分析结果。</p>\n<p>​\t<em>In general, for a “must” problem the desired solution will be the largest one, while for a “may” problem the desired solution will be the smallest one.</em></p>\n<p>​\t文中给出的例子如下：</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022012864.png\" alt=\"image-20231002201252770\"></p>\n<p>​\t连续传播的过程中使用的内容如下：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// constant propagation</span><br>enter.after = empty <span class=\"hljs-built_in\">set</span> <span class=\"hljs-comment\">// 刚开始是没有任何数据赋值状态的</span><br><span class=\"hljs-number\">1.b</span>efore = enter.after <span class=\"hljs-comment\">// 所有的before都是前一个的after</span><br><span class=\"hljs-number\">1.</span>after = <span class=\"hljs-number\">1.b</span>efore - (x, *) <span class=\"hljs-keyword\">union</span> (x, <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 这里在经历x=2的赋值之后，x不在是任意值，而是2</span><br><span class=\"hljs-number\">2.b</span>efore = <span class=\"hljs-number\">1.</span>after<br><span class=\"hljs-number\">2.</span>after = <span class=\"hljs-keyword\">if</span> (x, c) is in <span class=\"hljs-number\">2.b</span>efore then <span class=\"hljs-number\">2.b</span>efore - (y, *) <span class=\"hljs-keyword\">union</span> (y, c), <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">2.b</span>efore - (y, *) <br><span class=\"hljs-comment\">// 算法思想在↑体现，只考虑相邻基本块之间的关系，因此只能分类讨论</span><br><span class=\"hljs-number\">3.b</span>efore = ⌈⌉(<span class=\"hljs-number\">2.</span>after, <span class=\"hljs-number\">4.</span>after ) <span class=\"hljs-comment\">// 存在两个前驱结点，所以取∩操作</span><br><span class=\"hljs-number\">3.</span>after = <span class=\"hljs-number\">3.b</span>efore<br><span class=\"hljs-number\">4.b</span>efore = <span class=\"hljs-number\">3.</span>after<br><span class=\"hljs-number\">4.</span>after = <span class=\"hljs-number\">4.b</span>efore<br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014784.png\" alt=\"image-20231002201421727\"></p>\n<p>这里的分析时must分析，因此要使用到solution 4，尽可能多的结果。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//  live-variable analysis</span><br><span class=\"hljs-comment\">// 这个从最后一行开始看比较好</span><br>enter.after = <span class=\"hljs-number\">1.b</span>efore <br><span class=\"hljs-number\">1.b</span>efore = <span class=\"hljs-number\">1.</span>after - {x} <span class=\"hljs-comment\">// x的声明位置因此要union上x</span><br><span class=\"hljs-number\">1.</span>after = <span class=\"hljs-number\">2.b</span>efore<br><span class=\"hljs-number\">2.b</span>efore = <span class=\"hljs-number\">2.</span>after - {y} <span class=\"hljs-keyword\">union</span> {x} <span class=\"hljs-comment\">// y的声明位置，所以要减去y，同时是x的使用位置要union上x</span><br><span class=\"hljs-number\">2.</span>after = <span class=\"hljs-number\">3.b</span>efore<br><span class=\"hljs-number\">3.b</span>efore = <span class=\"hljs-number\">3.</span>after<br><span class=\"hljs-number\">3.</span>after = <span class=\"hljs-built_in\">exit</span>.before ⌈⌉ <span class=\"hljs-number\">4.b</span>efore<br><span class=\"hljs-number\">4.b</span>efore = <span class=\"hljs-number\">4.</span>after <span class=\"hljs-keyword\">union</span> {y} <span class=\"hljs-comment\">// 4之后不知道，但是由于4出现了y的使用，因此要将y并入</span><br><span class=\"hljs-number\">4.</span>after = <span class=\"hljs-number\">3.b</span>efore <br><span class=\"hljs-built_in\">exit</span>.before = empty-<span class=\"hljs-built_in\">set</span>  <span class=\"hljs-comment\">// 最终结束后都是empty set</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202310022014760.png\" alt=\"image-20231002201431716\"></p>\n<p>这里的variable live是may模式，因此要采用的最好是least的结果。</p>\n<h3 id=\"数据流分析的格点模型\"><a href=\"#数据流分析的格点模型\" class=\"headerlink\" title=\"数据流分析的格点模型\"></a>数据流分析的格点模型</h3><p>MOP模型存在以下问题：</p>\n<ul>\n<li>我们怎么知道方程的解存在?</li>\n<li>如果有不止一个解，我们想要哪一个?</li>\n<li>方程解与MOP解有什么关系?</li>\n</ul>\n<h4 id=\"Partially-ordered-sets-偏序集\"><a href=\"#Partially-ordered-sets-偏序集\" class=\"headerlink\" title=\"Partially ordered sets 偏序集\"></a>Partially ordered sets 偏序集</h4><p>​\t设R是集合A上的一个关系，如果R是自反的、反对称的和可传递的，则称R是集合A的偏序关系，简称偏序，记作“≤”。对于（a，b）∈R，就把它表示成a≤b。</p>\n<p>​\t若在集合A上给定一个偏序关系≤，则称集合A按偏序关系≤构成一个偏序集合，集合A和偏序R一起称为偏序集，记作（A，≤）（取自百度百科）</p>\n<p>偏序关系存在以下性质：</p>\n<p>（1）自反性：a≤a，∀a∈P；</p>\n<p>（2）反对称性：∀a，b∈P，若a≤b且b≤a，则a=b；</p>\n<p>（3）传递性：∀a，b，c∈P，若a≤b且b≤c，则a≤c；</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html\">https://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html</a></p>\n",
            "tags": [
                "dataflow"
            ]
        }
    ]
}