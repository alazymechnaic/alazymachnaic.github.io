{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"binary\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/",
            "url": "https://alazymechnaic.github.io/2023/04/27/one-byte-overflow/",
            "title": "one_byte_overflow",
            "date_published": "2023-04-27T11:40:42.000Z",
            "content_html": "<h2 id=\"off-By-One-缓冲区溢出\"><a href=\"#off-By-One-缓冲区溢出\" class=\"headerlink\" title=\"off-By-One 缓冲区溢出\"></a>off-By-One 缓冲区溢出</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​\t本文用于填补先前对于二进制漏洞一些理解上的不足，学习off-by-one的漏洞利用方式。<strong>缓冲区溢出的终极目的在于获取目标机器的权限，但是获取权限未必只要一种方式，你可以添加用户，反弹shell、开启一个新的网络链接等</strong>。主要参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA2LzA3L29mZi1ieS1vbmUtdnVsbmVyYWJpbGl0eS1zdGFjay1iYXNlZC0yLw==\">https://sploitfun.wordpress.com/2015/06/07/off-by-one-vulnerability-stack-based-2/</span></p>\n<h3 id=\"单字节溢出案例\"><a href=\"#单字节溢出案例\" class=\"headerlink\" title=\"单字节溢出案例\"></a>单字节溢出案例</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h&gt;</span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [1] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">256</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&gt;</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* [3] */</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Attempted Buffer Overflow\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">fflush</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stdout</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* [4] */</span>\n <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​\t<strong>当目标缓冲区大小与写入长度相一致时，会出现单字节溢出</strong>，因为在strcpy的处理过程中，将传入的参数都视为视为是字符串，默认会在复制过后在末尾添加一个字节的0x00，因此会向buffer的第256个位置处写0x00。\t</p>\n<p>​\t该操作会向下一个位置中写入0x00，下一个位置有可能就是ebp的存储位置，其实也就是栈区基地址。但是只能更改一个字节，其实也就是ebp指针的最低字节，当前过程在退出的过程中，执行leave指令，会将被修改后的ebp写入到寄存器中。</p>\n<p>​\t<strong>栈基址</strong>的高位迁移。由于只能向ebp的低字节中写入一个0，也就是稳定会将ebp抬高，从而更改栈的位置。当前ebp的较高位置其实就是用于存放当前函数临时变量的位置，其实也就控制了栈。在上述例子中，在foo函数中完成了栈的抬升，将栈设置到可控区域中。在main函数退出时就会取出错误的返回地址return，进行间接的控制流劫持操作。</p>\n<h3 id=\"栈迁移不可用的情况\"><a href=\"#栈迁移不可用的情况\" class=\"headerlink\" title=\"栈迁移不可用的情况\"></a>栈迁移不可用的情况</h3><ul>\n<li><p><strong>单字节溢出无法影响ebp</strong>：如果本身当前的缓冲区在ebp之上，但是并不能</p>\n</li>\n<li><p><strong>栈基地址的低位本身就是0x00</strong>：</p>\n</li>\n<li><p><strong>程序本身存在16字节对齐的情况</strong>：其实默认情况下gcc编译器都会对程序进行16字节的对齐，因此在创建堆栈空间之前会将esp的最后四个位进行清零操作。（因为最后四位正好是表示16个字节</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">0x08048497 &lt;+0&gt;: push %ebp\n0x08048498 &lt;+1&gt;: mov %esp,%ebp\n0x0804849a &lt;+3&gt;: push %edi\n0x0804849b &lt;+4&gt;: and $0xfffffff0,%esp               //Stack space aligned to 16 byte boundary\n0x0804849e &lt;+7&gt;: sub $0x20,%esp   <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>关于栈迁移请参考该位置<a href=\"https://alazymechnaic.github.io/2023/05/02/bypass-nx/\">https://alazymechnaic.github.io/2023/05/02/bypass-nx/</a></p>\n",
            "tags": [
                "binary"
            ]
        }
    ]
}