{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"kernel pwn\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "url": "https://alazymechnaic.github.io/2023/07/13/kernel-pwn/",
            "title": "kernel_pwn",
            "date_published": "2023-07-13T12:41:24.000Z",
            "content_html": "<h2 id=\"Kernel-PWN\"><a href=\"#Kernel-PWN\" class=\"headerlink\" title=\"Kernel PWN\"></a>Kernel PWN</h2><hr>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016734.png\" alt=\"image-20230713204349079\"></p>\n<h3 id=\"内核保护技术\"><a href=\"#内核保护技术\" class=\"headerlink\" title=\"内核保护技术\"></a>内核保护技术</h3><ul>\n<li><p><strong>SMAP/SMEP</strong>: </p>\n<ul>\n<li><em>arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never)。</em><ul>\n<li>SMAP(Supervisor Mode Access Prevention，管理模式访问保护): 禁止内核访问用户空间数据</li>\n<li>SMEP(Supervisor Mode Execution Prevention，管理模式执行保护): 禁止内核访问用户代码区域</li>\n<li>使用cat /proc/cpuinfo指令查看当前程序中存在的SMAP/SMEP功能是否支持，<strong>win8之后开始支持SMEP，并且在RC4中设置适当的位来表示应该强制执行SMEP，可以通过ROP或者jmp到一个RWX的内核地址来绕过</strong>。linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</li>\n</ul>\n</li>\n<li>ret2User: 在没有SMAP/SMEP保护的情况下将内核指针重定向到用户空间进行漏洞利用</li>\n<li>ret2dir:  physmap区域由内核管理并且由虚拟地址直接映射到物理地址。（也就时可以直接访问实际物理内存的内容）。在用户进行vmmap操作的时候，有很大概率能够将当前内存写入到该物理内存中，而内核又是可以直接访问该区域的，因此可以bypass SMAP/SMEP 参考文献： <a href=\"https://www.jianshu.com/p/3c662b6163a7\">https://www.jianshu.com/p/3c662b6163a7</a></li>\n</ul>\n</li>\n<li><p><strong>stack protector</strong>:  在编译内核时选择<em>CONFIG_CC_STACKPROTECTOR</em>选项开启该保护，功能类似canary</p>\n</li>\n<li><p><strong>Kernel Address Display Restrict</strong> ：限制内核地址显示，当攻击者试图开发通用性更强的漏洞利用程序时，他们通常需要知道内核结构的位置。 通过将内核地址视为敏感信息，常规本地用户无法看到那些地址。 从Ubuntu 11.04开始，/ proc / sys / kernel / kptr_restrict设置为“ 1”，以阻止报告已知的内核地址泄漏。 此外，只有root用户才能读取各种文件和目录：/boot/vmlinuz<em>、/boot/System.map</em>、/sys/kernel/debug/、/proc/slabinfo</p>\n</li>\n<li><h3 id=\"Kernel-Address-Space-Layout-Randomisation：\"><a href=\"#Kernel-Address-Space-Layout-Randomisation：\" class=\"headerlink\" title=\"Kernel Address Space Layout Randomisation：\"></a>Kernel Address Space Layout Randomisation：</h3><ul>\n<li>内存地址随机化，类似一般程序中的地址随机化，只不过是发生在内核</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">commit_creds(prepare_kernel_cred(<span class=\"hljs-number\">0</span>))<br><span class=\"hljs-comment\">// prepare_kernel_cred(0) 用0为参数生成一个root权限的结构体，并将其传递给commit_creds</span><br><span class=\"hljs-comment\">// commit_creds 用于将当前结构体设置为当前程序的凭证</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"自问自答\"><a href=\"#自问自答\" class=\"headerlink\" title=\"自问自答\"></a>自问自答</h2><h3 id=\"为什么会产生僵尸进程（Zombie-Process）\"><a href=\"#为什么会产生僵尸进程（Zombie-Process）\" class=\"headerlink\" title=\"为什么会产生僵尸进程（Zombie Process）\"></a>为什么会产生僵尸进程（Zombie Process）</h3><p>僵尸进程指已经完成了执行任务的子进程，但是由于其父进程没有及时处理该子进程的完成状态，该子进程的进程控制块PCB仍然被保留在系统中，占用了系统资源，但是无法被调用和执行任何任务，也无法被清除。僵尸进程会一直存在，直到父进程执行结束，或者对子进程进行处理wait或者waitpid。</p>\n<h3 id=\"内核如何实现对进程资源的回收\"><a href=\"#内核如何实现对进程资源的回收\" class=\"headerlink\" title=\"内核如何实现对进程资源的回收\"></a>内核如何实现对进程资源的回收</h3><p>程序退出一般有以下几种情况：</p>\n<p>exit()函数退出，也是正常退出。</p>\n<p>quick_exit函数: 执行部分清理工作后再退出</p>\n<p> _Exit()函数：立即终止程序而不进行任何的清理工作。</p>\n<p>信号退出：</p>\n<ul>\n<li>SIGINT：中断信号。通常由用户按下 Ctrl+C 产生。</li>\n<li>SIGTERM：终止信号。通常由 kill 命令发出，表示要求进程正常退出。</li>\n<li>SIGQUIT：退出信号。通常由用户按下 Ctrl+\\ 产生，表示要求进程退出并生成核心转储文件。</li>\n<li>SIGKILL：强制终止信号。通常由 kill 命令发出，表示要求进程立即退出，无法被捕获或阻塞。</li>\n<li>SIGABRT：异常中止信号。通常由进程本身发出，表示要求进程退出并生成核心转储文件。</li>\n</ul>\n<p>与exit不同，接收信号退出时一般不会执行完整的清理工作，比如刷新I/O缓冲区、关闭文件描述符等，在编写信号处理函数时需要手动执行该操作。</p>\n<p>当程序执行exit函数时，操作系统会完成以下几个操作：</p>\n<ul>\n<li>调用atexi()注册的终止函数。这些函数通常用于在程序结束时执行特定的清理任务。</li>\n<li>刷新所有的I/O缓冲区，以确保所有的数据被写入到文件中</li>\n<li>关闭所有打开的文件描述符</li>\n<li>释放所有的动态分配内存</li>\n<li>操作系统向父进程发送一个 SIGCHLD 信号，将程序的退出状态（成功退出还是异常退出）返还给父进程或者操作系统</li>\n<li>父进程通过调用诸如 wait() 或 waitpid() 等函数来回收子进程的资源：以获取子进程的退出状态码和回收子进程的进程表项</li>\n<li>父进程回收子进程的进程表项：子进程结束后，父进程需要回收子进程的进程表项，以便其他进程可以使用该进程号</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://bbs.kanxue.com/thread-262425.htm\">https://bbs.kanxue.com/thread-262425.htm</a></p>\n",
            "tags": [
                "kernel pwn"
            ]
        }
    ]
}