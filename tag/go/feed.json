{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"go\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2024/02/28/golang/",
            "url": "https://alazymechnaic.github.io/2024/02/28/golang/",
            "title": "Golang",
            "date_published": "2024-02-28T01:33:23.000Z",
            "content_html": "<h1 id=\"Go-语言安全实战\"><a href=\"#Go-语言安全实战\" class=\"headerlink\" title=\"Go 语言安全实战\"></a>Go 语言安全实战</h1><hr>\n<h2 id=\"Go语言编程\"><a href=\"#Go语言编程\" class=\"headerlink\" title=\"Go语言编程\"></a>Go语言编程</h2><h3 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h3><p>go语言本身是编译型语言，具备高效、简洁、并发能力强的特点，因此常常被用于云计算、网络服务。Go语言在执行的过程中，将Go代码转化为中间表示，并将程序的中间表示转化为目标平台的机器码。</p>\n<h4 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h4><pre><code class=\"go\">package main\nimport \"fmt\"\nfunc main() {\n    fmt.Printf(\"Congratulations! Go has successfully been installed on your system\\n\")\n}\n</code></pre>\n<p>运行代码</p>\n<pre><code class=\"bash\"> go run hello.go \n</code></pre>\n<p>拆分过程后进行代码的运行</p>\n<pre><code class=\"bash\"> go build -x hello.go  # 拆分过程实现，会产生一个名称为hello的二进制文件\n</code></pre>\n<p>通过gdb调试二进制文件能够看到go产生的中间语言。go语言在运行的过程中通过go的runtime与内核进行通信，runtime完成包括内存的分配等操作。</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202402281041471.png\" alt=\"image-20240228104124390\"></p>\n<p>Go程序首次进入的函数是runtime.rt0_amd64，通过runtime.rt0_go函数调用main函数，并完成数据变量的初始化，CPU核心数量的获取以及全局变量m0、g0的设置。而后m0开启第一个线程。Go语言的runtime中存在优秀的线程管理机制，</p>\n<ul>\n<li>G：goroutine，⼀个计算任务。由需要执⾏的代码和其上下⽂组成，上下⽂包括：当前代码位置，栈顶、栈底地址，状态等。（协程）</li>\n<li>M：machine，系统线程，执⾏实体，想要在 CPU 上执⾏代码，必须有线程，与 C 语⾔中的线程相同，通过系统调⽤ clone 来创建。</li>\n<li>P：processor，虚拟处理器，M 必须获得 P 才能执⾏代码，否则必须陷⼊休眠(后台监控线程除外)，你也可以将其理解为⼀种 token，有这个 token，才有在物理 CPU 核⼼上执⾏的权⼒。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_41000891/article/details/120463494\">https://blog.csdn.net/qq_41000891/article/details/120463494</a></p>\n<ul>\n<li>go语言的包声明和引入包有什么区别？</li>\n</ul>\n<p>go语言中的每一程序都至少包含一个名为main的包。并且package main必须在文件的第一个非注释行出现，表示该文件是程序的主函数。</p>\n<ul>\n<li>后面的为什么还要有一个main？</li>\n</ul>\n<p>package main用于指定程序首先寻找的文件，func main则用于指定首次执行的函数，如果存在init函数，则先执行init函数。</p>\n<h4 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h4><pre><code class=\"go\">var age int;\nage = 2\n//\nvar age = 2\n//\nage := 2\n</code></pre>\n<p>以上三种做法都可以实现对变量的声明。</p>\n<h4 id=\"指针操作\"><a href=\"#指针操作\" class=\"headerlink\" title=\"指针操作\"></a>指针操作</h4><pre><code class=\"go\">package main\nimport \"fmt\"\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    a := 50 // 声明变量 a\n    b := &amp;a // 产生一个指向a的指针b\n    change(b) // 修改b指向内容的数据\n    fmt.Println(a) // 40\n}\n</code></pre>\n<p>在go语言中的指针操作与C语言类似，可以通过:=符号完成对变量的简单声明一个指针类型的变量。</p>\n<pre><code class=\"go\">package main\n\nimport \"fmt\"\n\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    var(\n    a = [3]int{10,20,30}\n    ptr [3]*int\n    )\n\nfor i := 0; i&lt;len(a); i ++{\n    ptr[i] = &amp;a[i]\n    fmt.Printf(\"%d 0x%x\\n\",i+1, ptr[i])\n}\nfmt.Println(ptr[0]+1) // 报错：invalid operation: ptr[0] + 1 (mismatched types *int and int)\n}\n</code></pre>\n<p>在上述过程中能够看到，Go语言只能对程序中的int*类型的变量做解引用操作，且与C语言不同，指针本身并不能像数值一样直接运算。</p>\n<pre><code class=\"go\">package main\n\nimport \"fmt\"\n// import \"unsafe\"\nfunc change(v *int) {\n    *v = 40\n}\nfunc main() {\n    var(\n    a = [3]int{10,20,30}\n    ptr [3]*int\n    )\n\nfor i := 0; i&lt;len(a); i ++{\n    ptr[i] = &amp;a[i]\n    fmt.Printf(\"%d 0x%x\\n\",i+1, ptr[i])\n}\nfmt.Println(*ptr[0])\nintVal := int(uintptr(unsafe.Pointer(ptr[0])))\nintVal += 8\nptr2 := (*int)(unsafe.Pointer(uintptr(intVal)))\nfmt.Println(*(ptr2)) // 报错 unsafe\n}\n</code></pre>\n<p>由于Go语言的特性，直接读取给定地址的内容是不允许的，因为Go语言具有内存安全性和类型安全性的限制。Go语言的内存访问是受限制的，不能直接操纵指针或进行低级别的内存操作。直接将数字转化为指针是不安全的，因此编译都不会通过。</p>\n<h3 id=\"似乎可以利用的点\"><a href=\"#似乎可以利用的点\" class=\"headerlink\" title=\"似乎可以利用的点\"></a>似乎可以利用的点</h3><p>Go语言中如果将代码写在同一行是没问题的，但是需要使用分号隔开。在进行模本注入的过程中可以考虑使用该方法。\t</p>\n<h2 id=\"Go语言的安全问题\"><a href=\"#Go语言的安全问题\" class=\"headerlink\" title=\"Go语言的安全问题\"></a>Go语言的安全问题</h2><h3 id=\"模板注入\"><a href=\"#模板注入\" class=\"headerlink\" title=\"模板注入\"></a>模板注入</h3><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><h3 id=\"命令执行\"><a href=\"#命令执行\" class=\"headerlink\" title=\"命令执行\"></a>命令执行</h3><h3 id=\"任意文件读取\"><a href=\"#任意文件读取\" class=\"headerlink\" title=\"任意文件读取\"></a>任意文件读取</h3><h2 id=\"Go语言漏洞\"><a href=\"#Go语言漏洞\" class=\"headerlink\" title=\"Go语言漏洞\"></a>Go语言漏洞</h2><p><a href=\"https://pkg.go.dev/vuln/list\">https://pkg.go.dev/vuln/list</a></p>\n",
            "tags": [
                "go"
            ]
        }
    ]
}