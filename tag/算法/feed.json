{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"算法\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2024/03/06/wang-an-xuan-shou-de-suan-fa-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/03/06/wang-an-xuan-shou-de-suan-fa-ji-chu/",
            "title": "网安选手的算法基础",
            "date_published": "2024-03-06T06:47:54.000Z",
            "content_html": "<h2 id=\"链\"><a href=\"#链\" class=\"headerlink\" title=\"链\"></a>链</h2><h3 id=\"单链表逆置\"><a href=\"#单链表逆置\" class=\"headerlink\" title=\"单链表逆置\"></a>单链表逆置</h3><h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">searchInsert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>* nums, <span class=\"hljs-type\">int</span> numsSize, <span class=\"hljs-type\">int</span> target)</span>{<br>    <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=numsSize<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;=right){ <span class=\"hljs-comment\">// 这里注意是存在等于号</span><br>        <span class=\"hljs-type\">int</span> mid=(left+right)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>(nums[mid]==target)<br>            <span class=\"hljs-keyword\">return</span> mid;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[mid]&gt;target)<br>            right=mid<span class=\"hljs-number\">-1</span>; <br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[mid]&lt;target)<br>            left=mid+<span class=\"hljs-number\">1</span>;<br>    }<br>    <span class=\"hljs-keyword\">return</span> left; <span class=\"hljs-comment\">// 这里注意是left</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树的中序遍历\"><a href=\"#二叉树的中序遍历\" class=\"headerlink\" title=\"二叉树的中序遍历\"></a>二叉树的中序遍历</h3><h4 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">mid_show</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize, <span class=\"hljs-type\">int</span> *returnNum)</span>{<br>    <span class=\"hljs-keyword\">if</span>(root == <span class=\"hljs-literal\">NULL</span>)<br>        <span class=\"hljs-keyword\">return</span>;<br>   \t<span class=\"hljs-string\">'''</span><br>        前中后序的遍历按照下面的方式换顺序即可<br>    <span class=\"hljs-string\">'''</span><br>    mid_show(root-&gt;left, returnSize, returnNum);<br>    returnNum[(*returnSize)++] = root-&gt;val;<br>    mid_show(root-&gt;right, returnSize, returnNum);<br>}<br><span class=\"hljs-type\">int</span>* <span class=\"hljs-title function_\">inorderTraversal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize)</span><br>{<br>    <span class=\"hljs-comment\">//树中节点数目在范围 [0, 100] 内</span><br>    *returnSize = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> *returnNum = (<span class=\"hljs-type\">int</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>)*<span class=\"hljs-number\">101</span>);<br>    mid_show(root,returnSize,returnNum);<br>    <span class=\"hljs-keyword\">return</span> returnNum;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"非递归方法\"><a href=\"#非递归方法\" class=\"headerlink\" title=\"非递归方法\"></a>非递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span>* <span class=\"hljs-title function_\">inorderTraversal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode* root, <span class=\"hljs-type\">int</span>* returnSize)</span> {<br>    *returnSize = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span>* res = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>) * <span class=\"hljs-number\">501</span>); <span class=\"hljs-comment\">// 返回结果</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">TreeNode</span>** <span class=\"hljs-title\">stk</span> =</span> <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> TreeNode*) * <span class=\"hljs-number\">501</span>); <span class=\"hljs-comment\">// 生成一个栈</span><br>    <span class=\"hljs-type\">int</span> top = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-literal\">NULL</span> || top &gt; <span class=\"hljs-number\">0</span>) {<br>        <span class=\"hljs-keyword\">while</span> (root != <span class=\"hljs-literal\">NULL</span>) {<br>            stk[top++] = root;<br>            root = root-&gt;left;<br>        }<br>        root = stk[--top];<br>        res[(*returnSize)++] = root-&gt;val;<br>        root = root-&gt;right;<br>    }<br>    <span class=\"hljs-keyword\">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h3><h4 id=\"递归方法-1\"><a href=\"#递归方法-1\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">maxDepth</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> TreeNode *root)</span> {<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    \t对于每个节点来说，该结点的最大高度等于其左右子树的最大高度之一</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">NULL</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> fmax(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class=\"hljs-number\">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h2>",
            "tags": [
                "算法"
            ]
        }
    ]
}