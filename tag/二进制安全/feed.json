{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"二进制安全\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-an-quan-ji-chu/",
            "url": "https://alazymechnaic.github.io/2024/04/08/er-jin-zhi-an-quan-ji-chu/",
            "title": "二进制安全基础",
            "date_published": "2024-04-08T09:05:35.000Z",
            "content_html": "<h2 id=\"需要装的工具\"><a href=\"#需要装的工具\" class=\"headerlink\" title=\"需要装的工具\"></a>需要装的工具</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706632.png\" alt=\"image-20220929231115939\"></p>\n<h2 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h2><figure class=\"highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\">## 反汇编指令</span><br>objdump -d -M intel<br>readelf -a <span class=\"hljs-comment\"># 输出所有的elf的文件信息</span><br>nm <span class=\"hljs-comment\"># 用于看所有的函数</span><br>hexdump <span class=\"hljs-comment\"># 用于查看十六进制</span><br><br>ldd <span class=\"hljs-comment\"># 查看使用的函数所在动态链接库的位置</span><br><br><span class=\"hljs-comment\"># GCC的使用</span><br>gcc 文件.C -s 目标.s  <span class=\"hljs-comment\"># 该指令得到的是一个汇编指令构成的asc码文件，但是得到的是att的汇编指令</span><br>gcc -no-pie <span class=\"hljs-comment\"># 关闭pie</span><br>gcc -m32 <span class=\"hljs-comment\"># 进行32位编译，需要装一些依赖</span><br>gcc -static <span class=\"hljs-comment\">#使用静态链接,也就是将动态链接库直接写进二进制文件中，call的时候是一个实际地址，正常连接的时候call的是一个偏移量</span><br>-fomit-frame-pointer <span class=\"hljs-comment\"># 编译后就忽略rbp寄存器，代码里也就没有开栈操作，直接依照rsp间接寻址</span><br>-fno-omit-frame-pointer <span class=\"hljs-comment\"># 保留push rbp, mov rsp,rbp</span><br>-O1 <span class=\"hljs-comment\"># 默认的编译优化等级，O3后就有可能会将某些代码优化，导致攻击失败</span><br>-no-pie <span class=\"hljs-comment\"># 关闭地址随机化</span><br>gcc -fno-stack-protector -o <span class=\"hljs-built_in\">test</span> test.c //禁用栈保护<br>gcc -fstack-protector -o <span class=\"hljs-built_in\">test</span> test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码<br>gcc -fstack-protector-all -o <span class=\"hljs-built_in\">test</span> test.c //启用堆栈保护，为所有函数插入保护代码<br>-z execstack / -z noexecstack (关闭 / 开启) 栈保护<br><span class=\"hljs-comment\"># gdb指令</span><br>-Wl,--dynamic-linker=/动态连接器的路径/ld-linux-x86-64.so.2 <span class=\"hljs-comment\">#指定libc版本编译</span><br><br>distance addr_a addr_b <span class=\"hljs-comment\"># 计算两个地址之间有多远</span><br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"常见容易混淆概念\"><a href=\"#常见容易混淆概念\" class=\"headerlink\" title=\"常见容易混淆概念\"></a>常见容易混淆概念</h2><ul>\n<li>编译是由编译器完成的，高级语言的代码由编译器将其变为汇编代码（也就是gcc -s后得到的东西），这个根据使用的编译器不同，得到的结果也不同</li>\n<li>汇编 则是将汇编代码变成机器码，这个是没有异议的，完全相同。</li>\n<li>64位后的各种指令架构的寄存器，除了rip和flag寄存器外，其余都可以随便用。<ul>\n<li>RSP存放的是当前的栈顶的地址：surface？</li>\n<li>RBP是用于存放当前栈帧的栈底地址：base？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"关于-plt与-got\"><a href=\"#关于-plt与-got\" class=\"headerlink\" title=\"关于.plt与.got\"></a>关于.plt与.got</h2><h3 id=\"延迟绑定技术\"><a href=\"#延迟绑定技术\" class=\"headerlink\" title=\"延迟绑定技术\"></a>延迟绑定技术</h3><p>由于在实际运行的过程中并不会将外部函数的地址写到elf文件中，因为在装载动态链接库的时候会对动态链接库进行重定位。延迟绑定主要依赖的是plt，plt表其实是一种模糊的引用方式。这种方式用于避免在实际动态加载so的时候，一次性将所有的动态链接库加载进来，而是用到哪个加载哪个。主要依赖于_dl_runtime_resovlve(module, function)函数来实现。动态链接库加载进入内存地址后</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706623.png\" alt=\"image-20220926234935798\"></p>\n<ul>\n<li>由上图基本上能够得到一个完整的流程，上图是外部函数在首次执行时的情况</li>\n<li>首先在call指令执行过后会直接到plt表的对应表项中，该表由三条指令构成<ul>\n<li>第一条指令是个jmp *addr，初始状态下该addr中存储的内容其实就是jmp的下一条指令，也就是下面的push，其实就是直接走向下条指令</li>\n<li>第二条指令是将向栈中push一个值，这个值的目的是用于索引当前要找的是哪个函数，这个后面会提到</li>\n<li>第三条指令直接是个无条件跳转，这个跳转就是无脑跳转到一个固定的地址，这个地址就是_dl_runtime_resolve函数的位置，该函数位于代码段，有该函数来帮助程序找到对应的代码位置。其实这个函数也需要一个plt表项，因此这一步跳转的位置还是在所谓common@plt为的位置。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706643.png\" alt=\"image-20220926235654981\"></p>\n<ul>\n<li>_dl_runtime_resolve会去做两件事，一件事是将plt表的第一项，也就是那个间接的jmp *addr中addr所存储的内容改为真正的函数地址（其实这个addr就是在got范围内的），这样在第二次使用该函数的时候就不必再用到got。<ul>\n<li>那么这个函数是怎么找到对应的函数的呢？elf文件中保存了.rel.plt保存了重定位表的信息，该重定位表中存储了该函数对应的got表项的地址，也就是上面的jmp *addr中的addr</li>\n</ul>\n</li>\n<li>根据上面能够看到plt表的第一个就是_dl_runtime_resolve函数的表项，其对应的内容在got[2]的位置，前两个分别是.dynamic段的装载地址和本ELF的link_map数据及结构描述符地址。但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充</li>\n<li>注意！plt段在text段，可读可执行，got表在data段，可读可写（因此也有了覆盖got技术）</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706651.png\" alt=\"image-20220927000902698\"></p>\n<p>在使用之后就可以直接跳转</p>\n<ul>\n<li><p>因此可以使用覆盖got表的方式，来劫持控制流，但是如果开启relo之后就不行了</p>\n</li>\n<li><p>防御方式：</p>\n</li>\n<li><p>Partial RELRO</p>\n<pre><code class=\"hljs\">现在gcc 默认编译就是 partial relro\nsome sections(.init_array .fini_array .jcr .dynamic .got) are marked as read-only after they have been initialized by the dynamic loader\nnon-PLT GOT is read-only (.got)\nGOT is still writeable (.got.plt)\n</code></pre>\n<p>Full RELRO</p>\n<pre><code class=\"hljs\">拥有 Partial RELRO 的所有特性\nlazy resolution 是被禁止的，所有导入的符号都在 startup time 被解析\nbonus: the entire GOT is also (re)mapped as read-only or the .got.plt section is completely initialized with the final addresses of the target functions (Merge .got and .got.plt to one section .got). Moreover,since lazy resolution is not enabled, the GOT[1] and GOT[2] entries are not initialized. GOT[0] is a the address of the module’s DYNAMIC section. GOT[1] is the virtual load address of the link_map, GOT[2] is the address for the runtime resolver function。\n</code></pre>\n</li>\n<li><p>关于.got.plt表，其实是got表的一部分，用来存储链接后的地址</p>\n</li>\n</ul>\n<h3 id=\"rel-plt\"><a href=\"#rel-plt\" class=\"headerlink\" title=\".rel.plt\"></a>.rel.plt</h3><p>.rel.plt节里面记录的是重定位表的信息，所有外部过程调用符号的重定位信息会出现在这个节区中。与之类似的节区还有个.rel.dyn节，这里面的每个表项对应了除了外部过程调用的符号以外的所有重定位对象，比如引用外部的全局变量等。.rel.dyn和.rel.plt节中每个重定位项记录了重定位的操作地址（r_offset），重定位类型的信息和符号的符号表索引（r_info），这两个节区实际上就是Elf32_Rel/Elf64_Rel结构体数组。</p>\n<h3 id=\"plt\"><a href=\"#plt\" class=\"headerlink\" title=\".plt\"></a>.plt</h3><p>.plt节中存放的是需要重定位的外部调用的符号，.plt[0]存放的是更新GOT表中动态链接符号加载地址的操作——将.got.plt[1]中存放的link_map结构体压入栈作为下一步的函数参数，跳转到.got.plt[2]执行动态链接器符号解析函数_dl_runtime_resolve。在延迟绑定场景，.plt[0]的执行会在外部函数第一次调用的时候进行，在该场景中符号的GOT表内容会被初始化为.plt[0]的地址，在执行过plt[0]的操作后会被更新为符号的加载地址</p>\n<h3 id=\"plt-got\"><a href=\"#plt-got\" class=\"headerlink\" title=\".plt.got\"></a>.plt.got</h3><p>.plt.got节是用于存放 __cxa_finalize 函数对应的 PLT 条目。</p>\n<h3 id=\"got\"><a href=\"#got\" class=\"headerlink\" title=\".got\"></a>.got</h3><p>.got节是运行时只读的，可以用于存放全局变量的地址，也可以用于存放不需要延迟绑定的函数的地址。所以很明显，got表是不能动的，相反，got.plt是能动的</p>\n<h3 id=\"got-plt\"><a href=\"#got-plt\" class=\"headerlink\" title=\".got.plt\"></a>.got.plt</h3><p>.got.plt是运行时可读写的，在延迟绑定过程中与 .plt 一起使用，如果关闭了延迟绑定则没有该节。<br>.got.plt[1]存放了link_map结构体的地址，.gotplt[2]存放了_dl_runtime_resolve函数的地址，后面的各项则用于存放函数的加载地址，在使用延迟绑定的时候这些项里会统一初始化为.plt[0]的地址，用于执行_dl_runtime_resolve函数，在执行完成后会被重新初始化为函数的加载地址，在下一次调用的时候就会直接调用了，因此.got.plt必须是运行时可读写的</p>\n<h3 id=\"rel-dyn\"><a href=\"#rel-dyn\" class=\"headerlink\" title=\".rel.dyn\"></a>.rel.dyn</h3><p><a href=\"https://so.csdn.net/so/search?q=%E9%87%8D%E5%AE%9A%E5%90%91&amp;spm=1001.2101.3001.7020\">重定向</a>表，在程序启动时就需要重定位完成。</p>\n<h4 id=\"rel-plt-1\"><a href=\"#rel-plt-1\" class=\"headerlink\" title=\".rel.plt\"></a>.rel.plt</h4><p>保存了重定位表的信息，可以使用lazy的连接方式</p>\n<h3 id=\"fini和init段\"><a href=\"#fini和init段\" class=\"headerlink\" title=\"fini和init段\"></a>fini和init段</h3><p>init_array数组里面的函数都会一一执行，而且main函数结束后还会执行fini_array数组里面的函数，并且倒序执行</p>\n<h2 id=\"重定位表（Relocation-Table）\"><a href=\"#重定位表（Relocation-Table）\" class=\"headerlink\" title=\"重定位表（Relocation Table）\"></a>重定位表（Relocation Table）</h2><ul>\n<li>重定位表（Relocation Table）用于在程序加载到内存中时，进行内存地址的修正。为什么要进行内存地址的修正？我们举个例子来说：test.exe可执行程序需要三个动态链接库dll（a.dll，b.dll，c.dll），<strong>假设test.exe的ImageBase为400000H，而a.dll、b.dll、c.dll的基址ImageBase均为1000000H</strong>。 </li>\n<li>因此在装载到内存中时，每个库肯定不会装载到1000000H的位置，但是每个库中存在一些写死的地址，这个地址是与1000000H相关的绝对地址。因此需要在使用的时候进行修正，由于每个动态链接库所装载的位置不相同，需要一个数据结构来记录这些偏移，这个修正的数据结构就是重定位表。</li>\n</ul>\n<p><a href=\"https://www.freesion.com/article/7648134308/\">https://www.freesion.com/article/7648134308/</a></p>\n<h3 id=\"动态链接库操作\"><a href=\"#动态链接库操作\" class=\"headerlink\" title=\"动态链接库操作\"></a>动态链接库操作</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"># 构造两个文件，一个a.h,一个a.c，a.c就正常声明函数<br><span class=\"hljs-comment\">// a.c</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"a.h\"</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span><br>{<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"this is in hello...\\n\"</span>);<br>}<br><span class=\"hljs-comment\">// a.h 的作用相当于对文件中的函数做一个注册行为</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span>;<br><br><span class=\"hljs-comment\">// 需要使用的文件中直接进行include head文件即可</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"hello.h\"</span></span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>{<br>    hello();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br><br><span class=\"hljs-comment\">// gcc hello.c -shared -fPIC -o libhello.so # 用于生成动态链接库，此处的</span><br><span class=\"hljs-comment\">// 在使用动态链接库的时候只要进行在文件中进行include一下a.h即可  gcc test.c -L. -l hello  -no-pie -o testhello, </span><br><span class=\"hljs-comment\">// -L 表明使用的动态链接库在当前文件夹下，-l 后面跟动态链接库的名称，编译器会自动在前后补齐lib和.so的部分</span><br><span class=\"hljs-comment\">// export LD_LIBRARY_PATH=~/Desktop/Test_Project/getso:$LD_LIBRARY_PATH 执行完该指令后才会从目标路径中找到对应的库文件，否则显示找不到动态链接库</span><br><span class=\"hljs-comment\">// ldd file 指令用于查看当前文件中的动态链接库依赖有哪些</span><br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"常见的内存保护方式\"><a href=\"#常见的内存保护方式\" class=\"headerlink\" title=\"常见的内存保护方式\"></a>常见的内存保护方式</h2><h3 id=\"NX（No-execute）：\"><a href=\"#NX（No-execute）：\" class=\"headerlink\" title=\"NX（No-execute）：\"></a>NX（No-execute）：</h3><p>.data .bss等标记为不可执行，堆栈等均不可执行，传统的修改GOT表的方式不再可行。但是无法阻止代码重用攻击ret2libc。编译时加入-z execstack参数即可关闭该保护方式</p>\n<h3 id=\"stack-canaries：\"><a href=\"#stack-canaries：\" class=\"headerlink\" title=\"stack canaries：\"></a>stack canaries：</h3><p>栈保护机制，当该机制开启时会在栈中压入一个随机值，防止进行栈溢出后，该随机值被修改，使用-fno-stack-protector编译选项则会关闭程序的stack canary。canary的值位于rbp上面，也就是在push rbp之后才会开始完成的内容</p>\n<p>在函数执行结束后会有检查canary内容是否和先前相似的代码，如果不同则返回stack_chk_fail</p>\n<h3 id=\"RELO\"><a href=\"#RELO\" class=\"headerlink\" title=\"RELO\"></a>RELO</h3><ul>\n<li>重定位机制</li>\n<li>Partial RELO的got表本身是可写的，但是full relo的重定位表本身不可写</li>\n<li></li>\n</ul>\n<h3 id=\"ASLR与PIE\"><a href=\"#ASLR与PIE\" class=\"headerlink\" title=\"ASLR与PIE\"></a>ASLR与PIE</h3><h4 id=\"ASLR：\"><a href=\"#ASLR：\" class=\"headerlink\" title=\"ASLR：\"></a>ASLR：</h4><ul>\n<li>address space layout randomizatio: 也就是地址空间随机化，是一种系统功能，在系统将文件装入内存时产生作用，主要针对的内容如下：<ul>\n<li>栈基地址，共享库，mmap基地址，堆地址（这也就是为什么开了ASLR后需要进行堆基地址的泄露</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"PIE：\"><a href=\"#PIE：\" class=\"headerlink\" title=\"PIE：\"></a>PIE：</h4><ul>\n<li>Position - Independent Executable，编译器的功能之一，其主要目的在于对代码段，数据段以及bss段的随机化，将程序的基地址加载到一个任意位置（但是各个段之间的相对位置是固定的）</li>\n<li>关闭地址随机化后，静态地址就是实际运行地址。开启pie后，静态编译的地址就只是单纯的偏移量</li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706659.png\" alt=\"image-20221002153747977\"></p>\n<h2 id=\"不常见的保护方式\"><a href=\"#不常见的保护方式\" class=\"headerlink\" title=\"不常见的保护方式\"></a>不常见的保护方式</h2><h3 id=\"沙箱保护ORW\"><a href=\"#沙箱保护ORW\" class=\"headerlink\" title=\"沙箱保护ORW\"></a>沙箱保护ORW</h3><p>​\t沙盒机制也就是我们常说的沙箱，英文名 sandbox ，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。在 ctf 的 pwn 题中一般有两种函数调用方式实现沙盒机制，第一种是对 prctl 函数调用，第二种是使用 seccomp 库函数。</p>\n<h4 id=\"prctl函数\"><a href=\"#prctl函数\" class=\"headerlink\" title=\"prctl函数\"></a>prctl函数</h4><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/prctl.h&gt;</span> </span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">prctl</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> option, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg2, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg3, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg4,<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> arg5)</span>; <br></code></pre></td></tr></tbody></table></figure>\n\n<p>这个函数有 5 个参数，重点是 option 参数，这里主要关注 2 点：</p>\n<ul>\n<li>PR_SET_NO_NEW_PRIVS(38)</li>\n<li>PR_SET_SECCOMP(22)</li>\n</ul>\n<p>若option为PR_SET_NO_NEW_PRIVS(38)：</p>\n<ul>\n<li>第二个参数arg2设置为1，那么程序将不能通过执行execve系统调用来获得提权。</li>\n</ul>\n<p>若option为PR_SET_SECCOMP(22)：</p>\n<ul>\n<li>表示可以设置沙箱规则，也就是可以自定义函数的系统调用是被允许还是禁止。</li>\n</ul>\n<p>如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read，write，_exit（not exit_group），sigreturn这几个syscall。</p>\n<p>如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式，其中对syscall的限制通过参数3的结构体，来自定义过滤规则。</p>\n<p>总结起来，就是prctl(38, 1LL, 0LL, 0LL, 0LL)表示禁用系统调用，也就是 system 和 onegadget 都没了,而 prctl(22，2) 表示设置沙箱规则，从而可以实现改变函数的系统调用。</p>\n<h4 id=\"seccomp\"><a href=\"#seccomp\" class=\"headerlink\" title=\"seccomp\"></a>seccomp</h4><p>​\tseccomp是 secure computing 的缩写，其是 Linux kernel 引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp 安全机制能使一个进程进入到一种 “安全” 运行模式。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">v1 = seccomp_init(<span class=\"hljs-number\">0LL</span>);<br><span class=\"hljs-keyword\">if</span> ( !v1 )<br>{<br>  <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">\"seccomp error\"</span>);<br>  <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>);<br>}<br> <br><span class=\"hljs-comment\">// seccomp_rule_add添加规则</span><br><span class=\"hljs-comment\">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">2LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">0LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">1LL</span>, <span class=\"hljs-number\">0LL</span>);<br>seccomp_rule_add(v1, <span class=\"hljs-number\">0x7FFF0000</span>LL, <span class=\"hljs-number\">60LL</span>, <span class=\"hljs-number\">0LL</span>);<br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\t首先调用seccomp_init(arg)对结构体进行初始化，若参数arg为SCMP_ACT_ALLOW(0x7fff0000U)，则为黑名单模式，没有匹配到规则的系统调用将被默认允许。若参数为SCMP_ACT_KILL(0x00000000U)，则为白名单模式，没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。</p>\n<p><a href=\"https://blog.csdn.net/qq_45595732/article/details/125472253\">https://blog.csdn.net/qq_45595732/article/details/125472253</a></p>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">构造沙箱，检查沙箱工具<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"关于endbr64\"><a href=\"#关于endbr64\" class=\"headerlink\" title=\"关于endbr64\"></a>关于endbr64</h3><p>​\t在间接跳转之后查看下一条指令是不是endbr64。如果指令是endbr64指令，那么该指令会将CPU状态从WAIT_FOR_ENDBRANCH恢复成DLE。另一方面，如果下一条指令不是endbr64，说明程序可能被控制流劫持了，CPU就报错（#CP）。因为按照正确的逻辑，<strong>间接跳转后应该需要有一条对应的endbr64指令来回应间接跳转，如果不是endbr64指令，那么程序控制流可能被劫持并前往其它地址</strong>（其它任意地址上是以非endbr64开始的汇编代码）。</p>\n<p>​\t这里关于间接跳转与直接跳转之间的区别，直接跳转是写死一个目标标签地址，间接跳转则是通过对一个标签指向的内容进行跳转</p>\n<p>​\t简单来说就是intel新加的一条安全性检查的指令，大部分情况下视作nop即可，但这条指令事实上已用到最新版本的libc中，如果你的libc版本足够新且CPU也不是十多年前的古董的话大概率libc库函数第一条指令就是endbr 64，而这和服务器上是不一致，因此是有可能出现在本地打不通，在远程能够打通的情况。</p>\n<h2 id=\"IDA操作\"><a href=\"#IDA操作\" class=\"headerlink\" title=\"IDA操作\"></a>IDA操作</h2><ul>\n<li>有些字符串在数据段中，并不能通过字符串窗口</li>\n</ul>\n<h2 id=\"使用python打pwn\"><a href=\"#使用python打pwn\" class=\"headerlink\" title=\"使用python打pwn\"></a>使用python打pwn</h2><figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> pwn <span class=\"hljs-keyword\">import</span> * <br>p=process(<span class=\"hljs-string\">'./test'</span>) <span class=\"hljs-comment\"># 本地打</span><br>p=remote(<span class=\"hljs-string\">\"127.0.0.1\"</span>, <span class=\"hljs-number\">10011</span>) <span class=\"hljs-comment\"># 进行远程打</span><br>context.log_level = <span class=\"hljs-string\">'DEBUG'</span> <span class=\"hljs-comment\">#  设置调试标准</span><br>context(log_level=<span class=\"hljs-string\">\"debug\"</span>, arch=<span class=\"hljs-string\">\"i386\"</span>, os=<span class=\"hljs-string\">\"linux\"</span>)<br>gdb.attach(p) <span class=\"hljs-comment\"># 使用gdb调试，这时候就会弹出一个gdb窗口</span><br>p.close() <span class=\"hljs-comment\"># 关闭远程链接</span><br>p32(<span class=\"hljs-number\">0x1000</span>) <span class=\"hljs-comment\"># 将其变为一个32位的地址,注意使用的是小端序字节，不足32位的部分补0x00</span><br>p64(<span class=\"hljs-number\">0x1000</span>) <span class=\"hljs-comment\"># 与上面同理</span><br>p.sendline(parameter) <span class=\"hljs-comment\"># 发送数据，默认后面加\"\\n\"</span><br>p.recvuntil(“<span class=\"hljs-built_in\">input</span>:”)<br>send(payload) <span class=\"hljs-comment\"># 发送payload</span><br>sendline(payload) <span class=\"hljs-comment\"># 发送payload，并进行换行（末尾\\n）</span><br>recvn(N) <span class=\"hljs-comment\"># 接受 N(数字) 字符</span><br>recvline() <span class=\"hljs-comment\"># 接收一行输出</span><br>recvlines(N) <span class=\"hljs-comment\"># 接收 N(数字) 行输出</span><br>recvuntil(some_string) <span class=\"hljs-comment\"># 接收到 some_string 为止</span><br>asm(<span class=\"hljs-string\">'mov eax, 0'</span>) <span class=\"hljs-comment\"># 汇编成机器码,得到的是字节码</span><br>shellcraft.arm <span class=\"hljs-comment\"># 是ARM架构的，</span><br>shellcraft.amd64<span class=\"hljs-comment\"># 是AMD64架构，</span><br>shellcraft.i386<span class=\"hljs-comment\"># 是Intel 80386架构的，</span><br>shellcraft.common<span class=\"hljs-comment\"># 是所有架构通用的</span><br>asm(shellcraft.sh()) <span class=\"hljs-comment\"># 生成/bin/sh 的shellcode</span><br>context(os=<span class=\"hljs-string\">'linux'</span>, arch=<span class=\"hljs-string\">'amd64'</span>, log_level=<span class=\"hljs-string\">'debug'</span>) <span class=\"hljs-comment\"># 设置当前程序运行的上下文，如果是32位则这里设置为i386即可</span><br>c.interactive() <span class=\"hljs-comment\"># 开始进行交互</span><br><br><span class=\"hljs-comment\"># 不想去手动搞地址可以用pwntools帮忙搞</span><br>e = ELF(<span class=\"hljs-string\">'./example_file'</span>)<br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.address)  <span class=\"hljs-comment\"># 0x400000</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.symbols[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 0x401680</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.got[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 输出got地址,为什么还没有运行就能知道got地址？这里其实是got表的地址，该地址的内容指向实际加载的地址</span><br><span class=\"hljs-built_in\">print</span> <span class=\"hljs-built_in\">hex</span>(e.plt[<span class=\"hljs-string\">'write'</span>]) <span class=\"hljs-comment\"># 输出plt地址，该内容中存储的是指向got地址</span><br>offset = e.symbols[<span class=\"hljs-string\">'system'</span>] - e.symbols[<span class=\"hljs-string\">'printf'</span>] <span class=\"hljs-comment\"># calculate offset</span><br>binsh_address = <span class=\"hljs-built_in\">next</span>(e.search(<span class=\"hljs-string\">'/bin/sh\\x00'</span>)) <span class=\"hljs-comment\"># find address which contains /bin/sh</span><br><br><span class=\"hljs-comment\"># 注意这里有个技巧，获取程序的输出</span><br>p.recvuntil(<span class=\"hljs-string\">\"secret[1] is\"</span>) <span class=\"hljs-comment\"># 这里有个技巧</span><br>v3_addr = <span class=\"hljs-built_in\">int</span>(p.recv(<span class=\"hljs-number\">7</span>),<span class=\"hljs-number\">16</span>)<br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t使用给定的libc</span><br><span class=\"hljs-string\">'''</span><br>libc = ELF(<span class=\"hljs-string\">\"./libc_32.so.6\"</span>)<br>libc_write = libc.symbols[<span class=\"hljs-string\">\"write\"</span>]<br>libc_system = libc.symbols[<span class=\"hljs-string\">\"system\"</span>]<br>libc_bin_sh = <span class=\"hljs-built_in\">next</span>(libc.search(<span class=\"hljs-string\">b\"/bin/sh\\x00\"</span>))<br>write_got=u32(sh.recv(<span class=\"hljs-number\">4</span>)) <span class=\"hljs-comment\"># 使用泄露出来的地址</span><br><span class=\"hljs-comment\">#生成格式化字符串漏洞利用脚本</span><br>payload = fmtstr_payload(<span class=\"hljs-number\">6</span>,{printf_got:sys_plt}) <span class=\"hljs-comment\"># 第一个参数是字符串的存储位置也就是这个AAAA</span><br><br>ROPgadget --binary ret2libc3  --only <span class=\"hljs-string\">'pop|ret'</span><br>ROPgadget --binary 文件名 --sting <span class=\"hljs-string\">'/bin/sh'</span><br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t利用python调用libc中的函数</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-comment\"># 使用python调用libc中的函数</span><br><span class=\"hljs-keyword\">from</span> ctypes <span class=\"hljs-keyword\">import</span> *<br>io = remote(<span class=\"hljs-string\">'220.249.52.133'</span>, <span class=\"hljs-number\">54835</span>)<br> <span class=\"hljs-comment\"># 加载C动态链接库</span><br>libc = cdll.LoadLibrary(<span class=\"hljs-string\">\"/lib/x86_64-linux-gnu/libc.so.6\"</span>)<br><span class=\"hljs-comment\"># 调用函数库中的内容</span><br>libc.srand(<span class=\"hljs-number\">1</span>)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>):<br>    num = <span class=\"hljs-built_in\">str</span>(libc.rand()%<span class=\"hljs-number\">6</span>+<span class=\"hljs-number\">1</span>)<br>    io.recvuntil(<span class=\"hljs-string\">'number:'</span>)<br>    io.sendline(num)<br>io.interactive()<br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t无libc文件的时候怎么打ret2libc</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-keyword\">from</span> LibcSearcher <span class=\"hljs-keyword\">import</span> *<br>libc= LibcSearcher(<span class=\"hljs-string\">\"read\"</span>,read_libc) <span class=\"hljs-comment\"># 这里泄露read函数地址，这里其实任何一个函数都可以，只要名称对应上即可</span><br>libc_base=read_libc-libc.dump(<span class=\"hljs-string\">'read'</span>) <span class=\"hljs-comment\"># 这里是重定位后的地址减去在libc中的地址，得到基地址</span><br><br>system_addr=p64(libc_base+libc.dump(<span class=\"hljs-string\">'system'</span>)) <span class=\"hljs-comment\"># 这里得到的是system函数的地址</span><br>binsh_addr = p64(libc.dump(<span class=\"hljs-string\">\"str_bin_sh\"</span>) + libc_base) <span class=\"hljs-comment\"># 这里找到binsh的地址</span><br><br><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-string\">\t求解多元方程组</span><br><span class=\"hljs-string\">'''</span><br><span class=\"hljs-keyword\">from</span> z3 <span class=\"hljs-keyword\">import</span> *<br><span class=\"hljs-comment\"># 这里声明变量</span><br>a = Int(<span class=\"hljs-string\">'a'</span>)<br>b = Int(<span class=\"hljs-string\">'b'</span>)<br><span class=\"hljs-comment\"># 创建求解器</span><br>s = Solver()<br><span class=\"hljs-comment\"># 添加约束条件</span><br>s.add(c * b * a - d == <span class=\"hljs-number\">36182</span>)<br>s.add(a==<span class=\"hljs-number\">19</span>)<br><span class=\"hljs-built_in\">print</span>(s.check())<br><span class=\"hljs-built_in\">print</span>(s.model())<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"容易忘的汇编指令\"><a href=\"#容易忘的汇编指令\" class=\"headerlink\" title=\"容易忘的汇编指令\"></a>容易忘的汇编指令</h2><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asm\">leave: <br>\tmov esp, ebp;<br>    pop ebp;<br>test eax, eax ; 目的在于将eax进行与运算，**其实本质上来讲就是来检查是不是0**，在程序中经常出现<br></code></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三种函数调用约定\"><a href=\"#三种函数调用约定\" class=\"headerlink\" title=\"三种函数调用约定\"></a>三种函数调用约定</h2><ul>\n<li>调用约定的本质是定义函数的参数传递方式，函数的返回值，以及调用后如何返回三项基本内容</li>\n<li>三种调用约定<ul>\n<li>__cdecl是C/C++的默认调用方式<ul>\n<li>参数使用栈传递，按照顺序从右向左依次进行入栈，主函数负责栈平衡（<strong>也就是谁调用谁负责栈平衡</strong>）</li>\n<li>命名方式为下划线加上函数名</li>\n<li>Linux下的主要传参方式<ul>\n<li>X86:普通函数直接全都放在栈上传参（从右向左的方式），syscall则是使用 eax当做调用号，ebx,ecx，edx，esi,edi,ebp传入</li>\n<li>X64: 普通函数传参使用的是rdi,rsi,rdx,rcx,r8,r9 syscall系统调用则是使用rax作为系统调用号，其余与普通函数类似</li>\n<li>arm：r0,1,2,3</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>__stdcall是Windows API函数的调用方式<ul>\n<li>参数从右向左依次进行入栈，被调用的函数负责栈平衡。</li>\n</ul>\n</li>\n<li>__fastcall 对性能要求比较高的时候往往使用该方式<ul>\n<li>该方式优先使用寄存器（ECX、EDX）和栈传参，剩下的参数再使用栈从右向左传递，<strong>栈平衡由被调用的函数负责</strong></li>\n<li>快速调用方式使用中的命名规则为@加上函数名@参数大小</li>\n</ul>\n</li>\n<li>__thiscall 函数调用方式</li>\n<li>CS都是从右向左入栈调用，fastcall则是优先使用ecx，edx，其余参数从右向左入栈</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h2><h3 id=\"flags寄存器有哪些位，有什么作用\"><a href=\"#flags寄存器有哪些位，有什么作用\" class=\"headerlink\" title=\"flags寄存器有哪些位，有什么作用\"></a>flags寄存器有哪些位，有什么作用</h3><p><a href=\"https://zhuanlan.zhihu.com/p/272135463?utm_id=0\">https://zhuanlan.zhihu.com/p/272135463?utm_id=0</a></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#1CF0_59\">1、CF（0）：进位标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#2PF2_65\">2、PF（2）：奇偶标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#3AF4_70\">3、AF（4）：辅助进位标志</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#4ZF60_75\">4、ZF（6）：0标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#5SF7_81\">5、SF（7）：符号标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#6TF8_87\">6、TF（8）：追踪标志</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#7IF9_90\">7、IF（9）：中断标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#8DF10_93\">8、DF（10）：方向标志位</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38633659/article/details/125192247#9OF11_98\">9、OF（11）：溢出标志位</a></li>\n</ul>\n<h3 id=\"控制寄存器有哪些\"><a href=\"#控制寄存器有哪些\" class=\"headerlink\" title=\"控制寄存器有哪些\"></a>控制寄存器有哪些</h3><ol>\n<li>CR0：含有控制处理器操作模式和状态的系统控制标识，它分为两种，一种是协处理器控制位，一种是保护控制位。协处理器控制位包括扩展类型位 ET、任务切换位 TS、仿真位 EM 和数学存在位 MP，用于控制 x86 的浮点，也就是数学协处理器的操作。1</li>\n<li>CR1：保留。2</li>\n<li>CR2：当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会引起异常的线性地址存放在CR2中。</li>\n<li>CR3：页目录基地址寄存器，用来切换和定位当前正在使用的页表。</li>\n<li>CR4：含有与分页机制相关的系统控制标识，包括 PAE 和 PSE 位，用于控制分页的配置。</li>\n</ol>\n<p>以上寄存器都是 32 位的，各自的作用是与分页机制密切相关，因此，在进程管理及虚拟内存管理中会涉及到这几个寄存器。对控制寄存器的读写是通过 mov 指令来实现</p>\n<h2 id=\"系统函数的调用方式\"><a href=\"#系统函数的调用方式\" class=\"headerlink\" title=\"系统函数的调用方式\"></a>系统函数的调用方式</h2><h3 id=\"32位下的系统函数调用\"><a href=\"#32位下的系统函数调用\" class=\"headerlink\" title=\"32位下的系统函数调用\"></a>32位下的系统函数调用</h3><ul>\n<li><p>传参方式：首先将系统调用号传入eax，然后将参数从左到右依次存入ebx、ecx、edx寄存器中，返回值存在eax寄存器中。</p>\n</li>\n<li><p>调用号：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">sys_read = <span class=\"hljs-number\">3</span><br>sys_write = <span class=\"hljs-number\">4</span><br>sys_execve = <span class=\"hljs-number\">11</span><br></code></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>使用int 80h中断进行系统调用</p>\n</li>\n<li><p>32位程序编译</p>\n</li>\n<li><pre><code class=\"sh\">gcc -m32 -o  testAlign32  testAlign.c\n# 如果出现报错/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录    27 | #include &lt;bits/libc-header-start.h&gt;，则使用以下指令\nsudo apt-get install gcc-multilib\n</code></pre>\n</li>\n</ul>\n<h3 id=\"64位下的系统函数调用\"><a href=\"#64位下的系统函数调用\" class=\"headerlink\" title=\"64位下的系统函数调用\"></a>64位下的系统函数调用</h3><ul>\n<li>首先将系统调用号传入rax，然后将参数从左到右依次存入rdi、rsi、rdx寄存器中，返回值存在rax寄存器中</li>\n<li>调用号：sys_read为0，sys_write为1，sys_open为2</li>\n<li>调用方式：使用syscall指令进行系统调用</li>\n</ul>\n<h2 id=\"linux下程序的加载过程\"><a href=\"#linux下程序的加载过程\" class=\"headerlink\" title=\"linux下程序的加载过程\"></a>linux下程序的加载过程</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202404081706670.png\" alt=\"image-20230316183408668\"></p>\n",
            "tags": [
                "二进制安全"
            ]
        }
    ]
}