{
    "version": "https://jsonfeed.org/version/1",
    "title": "alazymachine • All posts by \"heap pwn ctf\" tag",
    "description": "",
    "home_page_url": "https://alazymechnaic.github.io",
    "items": [
        {
            "id": "https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/",
            "url": "https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/",
            "title": "堆溢出利用",
            "date_published": "2023-05-12T11:47:55.000Z",
            "content_html": "<h1 id=\"堆利用\"><a href=\"#堆利用\" class=\"headerlink\" title=\"堆利用\"></a>堆利用</h1><hr>\n<p>​\t本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。</p>\n<h2 id=\"堆管理机制\"><a href=\"#堆管理机制\" class=\"headerlink\" title=\"堆管理机制\"></a>堆管理机制</h2><p>​\t堆区域与栈区域在内存使用上存在不同：</p>\n<ul>\n<li>堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置</li>\n<li>堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长</li>\n<li><strong>堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念</strong></li>\n</ul>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015938.png\" alt=\"先知社区https://xz.aliyun.com/t/10650\"></p>\n<p>(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)</p>\n<p><img src=\"/HEAP-EXP-heap-management.assets/image-20230613200729790.png\" alt=\"image-20230613200729790\"></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ul>\n<li>32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.</li>\n<li>64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，</li>\n</ul>\n<h4 id=\"内存的分配管理策略\"><a href=\"#内存的分配管理策略\" class=\"headerlink\" title=\"内存的分配管理策略\"></a>内存的分配管理策略</h4><ul>\n<li>具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）</li>\n<li>特别大的内存分配使用的是mmap，<strong>使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大</strong></li>\n<li>短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源</li>\n<li>空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存</li>\n<li>对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中</li>\n<li><strong>注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统</strong></li>\n</ul>\n<h4 id=\"arena分配区机制\"><a href=\"#arena分配区机制\" class=\"headerlink\" title=\"arena分配区机制\"></a>arena分配区机制</h4><ul>\n<li>arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，<strong>但是如果是单线程程序也可以拥有多个arena</strong>，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：<ul>\n<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>\n<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止</li>\n<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>\n</ul>\n</li>\n<li>在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。</li>\n<li>每个进程只能有一个主分配区，但有多个非主分配区<ul>\n<li>主分配区可以使用brk和mmap两种方式进行内存的分配</li>\n<li>非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理</li>\n<li>同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena</li>\n<li>可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。</li>\n<li>多线程环境下内存的分配与回收：<ul>\n<li>查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；</li>\n<li>当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。</li>\n</ul>\n<h2 id=\"堆管理的数据结构\"><a href=\"#堆管理的数据结构\" class=\"headerlink\" title=\"堆管理的数据结构\"></a>堆管理的数据结构</h2><h3 id=\"heap-info\"><a href=\"#heap-info\" class=\"headerlink\" title=\"heap_info\"></a>heap_info</h3><p>​\t一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。</p>\n<p>​\t主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域为止</p>\n<p>​\t依照该数据结构的情况能够看到：</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span></span><br><span class=\"hljs-class\">{</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">prev</span>;</span>  <span class=\"hljs-comment\">//指向前一个heap_info结构</span><br>  <span class=\"hljs-type\">size_t</span> size;  <span class=\"hljs-comment\">//当前heap_info结构所描述的堆内存大小</span><br>  <span class=\"hljs-type\">int</span> mmaped;  <span class=\"hljs-comment\">//标记当前堆内存是否由mmap系统调用分配</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">//指向后一个heap_info结构</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">arena</span> *<span class=\"hljs-title\">ar_ptr</span>;</span>  <span class=\"hljs-comment\">//指向当前堆内存所在的arena</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"malloc-state\"><a href=\"#malloc-state\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><p><code>malloc_state</code> 用于表示 <em>arena</em> 的信息，因此也被称为 <em>arena header</em>，每个线程只含有一个 <em>arena header</em>。<em>arena header</em> 包含 <em>bin</em>、<em>top chunk</em> 以及 <em>last remainder chunk</em> 等信息</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> {</span><br>  <span class=\"hljs-type\">binmap_t</span>     binmap[BINMAPSIZE];  <span class=\"hljs-comment\">// 用于标记哪些 bin 是非空的</span><br>  mfastbinptr  fastbinsY[NFASTBINS];  <span class=\"hljs-comment\">// 用于存放小块内存的链表</span><br>  mchunkptr    top;  <span class=\"hljs-comment\">// 指向当前 arena 中最后一个已分配的 chunk</span><br>  mchunkptr    last_remainder;  <span class=\"hljs-comment\">// 指向上一个 arena 中未被使用完的 chunk</span><br>  mchunkptr    bins[NBINS * <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">// 用于存放各个 bin 中的 chunk</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">// 指向下一个 malloc_state 结构</span><br>  <span class=\"hljs-type\">uint64_t</span>     magic;  <span class=\"hljs-comment\">// 用于检查 malloc_state 结构的完整性</span><br>  <span class=\"hljs-type\">uint64_t</span>     flags;  <span class=\"hljs-comment\">// 保存了 malloc_state 的各种状态信息</span><br>  <span class=\"hljs-type\">mutex_t</span>      mutex;  <span class=\"hljs-comment\">// 用于保护 malloc_state 结构的互斥锁</span><br>  <span class=\"hljs-type\">char</span> *       seg;  <span class=\"hljs-comment\">// 指向当前 arena 的起始地址</span><br>  <span class=\"hljs-type\">size_t</span>       size;  <span class=\"hljs-comment\">// 当前 arena 的大小</span><br>  <span class=\"hljs-type\">size_t</span>       mprotect_size;  <span class=\"hljs-comment\">// 当前 arena 中已经保护的内存大小</span><br>  mchunkptr    mprotect_base;  <span class=\"hljs-comment\">// 当前 arena 中已经保护的内存的起始地址</span><br>  mchunkptr    last_remainder;  <span class=\"hljs-comment\">// 上一个 arena 中未被使用完的 chunk</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">heap_info</span> *<span class=\"hljs-title\">heap_info</span>;</span>  <span class=\"hljs-comment\">// 当前 arena 所在的 heap_info 结构</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"chunk的组织形式\"><a href=\"#chunk的组织形式\" class=\"headerlink\" title=\"chunk的组织形式\"></a>chunk的组织形式</h3><figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span> {</span><br>  <span class=\"hljs-comment\">/* #define INTERNAL_SIZE_T size_t */</span><br>  INTERNAL_SIZE_T      prev_size;  <span class=\"hljs-comment\">/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/</span><br>  INTERNAL_SIZE_T      size;       <span class=\"hljs-comment\">/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">fd</span>;</span>    <br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">bk</span>;</span><br>\t<span class=\"hljs-comment\">/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/</span><br>  <span class=\"hljs-comment\">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">fd_nextsize</span>;</span> <span class=\"hljs-comment\">/* double links -- used only if free. */</span><br>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_chunk</span>* <span class=\"hljs-title\">bk_nextsize</span>;</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<ul>\n<li>chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些</li>\n<li>基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk</li>\n<li>如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法</li>\n</ul>\n<p><strong>已分配chunk的数据结构情况</strong></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016938.png\" alt=\"image-20230613234305496\"></p>\n<p><strong>未分配的chunk数据结构情况</strong></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016286.png\" alt=\"image-20230613234401273\"></p>\n<p>​\t在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。</p>\n<p>​\t这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，<strong>且prev_size的大小指的是包含当前块头部和用户数据的部分</strong>）</p>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">N</span>：是不是「主分配区」分配的内存 <span class=\"hljs-number\">1</span> 表示不是主分配区分配的，<span class=\"hljs-number\">0</span> 表示是主分配区分配的<br><br><span class=\"hljs-attribute\">M</span>：是不是 Memory Mapped 分配的内存，<span class=\"hljs-number\">1</span> 表示是，<span class=\"hljs-number\">0</span> 表示是 heap<br><br><span class=\"hljs-attribute\">P</span>：表示前一个 chunk 是否在使用，在初始化的时候通常为 <span class=\"hljs-number\">1</span>，防止使用不能访问的内存<br></code></pre></td></tr></tbody></table></figure>\n\n<p><a href=\"https://www.freebuf.com/articles/system/171261.html\">https://www.freebuf.com/articles/system/171261.html</a></p>\n<p><a href=\"https://blog.csdn.net/Breeze_CAT/article/details/103788698\">https://blog.csdn.net/Breeze_CAT/article/details/103788698</a></p>\n<h3 id=\"tcache（thread-local-caching）机制\"><a href=\"#tcache（thread-local-caching）机制\" class=\"headerlink\" title=\"tcache（thread local caching）机制\"></a>tcache（thread local caching）机制</h3><ul>\n<li><code>tcache</code>属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。</li>\n<li>仅适用于glibc2.26以上的版本使用</li>\n</ul>\n<h3 id=\"Bin机制\"><a href=\"#Bin机制\" class=\"headerlink\" title=\"Bin机制\"></a>Bin机制</h3><ul>\n<li>ptmalloc 一共维护128个bin，使用数组存储链表头，</li>\n<li><strong>fast bin</strong>：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个<strong>单向链表</strong>进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。</li>\n<li><strong>small bin</strong>：专门存放size&lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin</li>\n<li><strong>large bin</strong>：需要对bin中的chunk按照大小进行排序。</li>\n<li><strong>unsorted bin</strong>：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。<ul>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。</li>\n<li>unsorted bin在使用的过程中是FIFO的</li>\n</ul>\n</li>\n<li><strong>Top Chunk</strong>：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，<strong>初始状态下的UNsorted chunk 就是 Top chunk</strong></li>\n<li>last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。</li>\n</ul>\n<h3 id=\"Bin运作流程\"><a href=\"#Bin运作流程\" class=\"headerlink\" title=\"Bin运作流程\"></a>Bin运作流程</h3><ul>\n<li>如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中</li>\n<li>在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。</li>\n<li>如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。</li>\n<li>unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。</li>\n<li>在size&gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。<br>Unsorted Bin</li>\n<li>空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中</li>\n<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>\n<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>\n<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话</li>\n<li>分配过程：fastbin-&gt;unsorted bin-&gt;其他bins-&gt;切割top chunk</li>\n<li>回收过程：<ul>\n<li>在maped区域，直接回收即可</li>\n<li>在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各个bin的处理先后顺序\"><a href=\"#各个bin的处理先后顺序\" class=\"headerlink\" title=\"各个bin的处理先后顺序\"></a>各个bin的处理先后顺序</h3><ul>\n<li>fastbin 是 LIFO (后入先出)</li>\n<li>unsorted bin是 FIFO (先进先出)</li>\n<li>small bin 是 FIFO</li>\n<li>large bin 是 FIFO</li>\n<li>tcache 是 LIFO</li>\n<li>实际利用时只要知道fastbin为了加快速度学习了栈的机制</li>\n</ul>\n<h3 id=\"线程堆\"><a href=\"#线程堆\" class=\"headerlink\" title=\"线程堆\"></a>线程堆</h3><ul>\n<li>每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。</li>\n</ul>\n<h3 id=\"malloc-state-1\"><a href=\"#malloc-state-1\" class=\"headerlink\" title=\"malloc_state\"></a>malloc_state</h3><ul>\n<li>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。</li>\n<li>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> {</span><br>    <span class=\"hljs-comment\">/* Serialize access.  */</span><br>    __libc_lock_define(, mutex);<br><br>    <span class=\"hljs-comment\">/* Flags (formerly in max_fast).  */</span><br>    <span class=\"hljs-type\">int</span> flags;<br><br>    <span class=\"hljs-comment\">/* Fastbins */</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];<br><br>    <span class=\"hljs-comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>    mchunkptr top;<br><br>    <span class=\"hljs-comment\">/* The remainder from the most recent split of a small request */</span><br>    mchunkptr last_remainder;<br><br>    <span class=\"hljs-comment\">/* Normal bins packed as described above */</span><br>    mchunkptr bins[ NBINS * <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">2</span> ];<br><br>    <span class=\"hljs-comment\">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> binmap[ BINMAPSIZE ];<br><br>    <span class=\"hljs-comment\">/* Linked list, points to the next arena */</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next</span>;</span><br><br>    <span class=\"hljs-comment\">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class=\"hljs-comment\">       by free_list_lock in arena.c.  */</span><br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">malloc_state</span> *<span class=\"hljs-title\">next_free</span>;</span><br><br>    <span class=\"hljs-comment\">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class=\"hljs-comment\">       the free list.  Access to this field is serialized by</span><br><span class=\"hljs-comment\">       free_list_lock in arena.c.  */</span><br>    INTERNAL_SIZE_T attached_threads;<br><br>    <span class=\"hljs-comment\">/* Memory allocated from the system in this arena.  */</span><br>    INTERNAL_SIZE_T system_mem;<br>    INTERNAL_SIZE_T max_system_mem;<br>};<br></code></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"堆管理函数\"><a href=\"#堆管理函数\" class=\"headerlink\" title=\"堆管理函数\"></a>堆管理函数</h2><h3 id=\"libc-malloc\"><a href=\"#libc-malloc\" class=\"headerlink\" title=\"libc_malloc\"></a>libc_malloc</h3><p>​\tmalloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。</p>\n<p><strong>用户申请的字节一旦进入libc_malloc会转换为无符号整数</strong>，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。</p>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。</li>\n<li>使用场景：<ul>\n<li><strong>malloc</strong><ul>\n<li>从恰好大小合适的 large bin 中获取 chunk。<ul>\n<li><strong>这里需要注意的是 fastbin 就没有使用 unlink，fastbin是单链表\t。</strong></li>\n<li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink</strong> 。</li>\n</ul>\n</li>\n<li>从比请求的 chunk 所在的large bin 中取 chunk。</li>\n</ul>\n</li>\n<li><strong>free</strong><ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>malloc_consolidate</strong>：用于合并的时候要把空闲块取出来先。<ul>\n<li>后向合并，合并物理相邻低地址空闲 chunk。</li>\n<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n<li><strong>realloc</strong><ul>\n<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Take a chunk off a bin list */</span><br><span class=\"hljs-comment\">// unlink p</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> unlink(AV, P, BK, FD) {  <span class=\"hljs-comment\">//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \\</span></span><br><span class=\"hljs-comment\"><span class=\"hljs-meta\">    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br>\t<span class=\"hljs-comment\">// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小</span><br>    <span class=\"hljs-keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"hljs-number\">0</span>))      \\<br>      malloc_printerr (<span class=\"hljs-string\">\"corrupted size vs. prev_size\"</span>);               \\<br>    FD = P-&gt;fd;                                                                      \\<br>    BK = P-&gt;bk;                                                                      \\<br>    <span class=\"hljs-comment\">// 此处才真正的取出FD和BK两个chunk块</span><br>    <span class=\"hljs-comment\">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span><br>    <span class=\"hljs-keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"hljs-number\">0</span>))                    \\ <span class=\"hljs-comment\">// 看看取出的目标块是不是真正的目标</span><br>      malloc_printerr (check_action, <span class=\"hljs-string\">\"corrupted double-linked list\"</span>, P, AV);  \\<br>    <span class=\"hljs-keyword\">else</span> {                                                                      \\<br>        FD-&gt;bk = BK;                                                              \\<br>        BK-&gt;fd = FD;   <span class=\"hljs-comment\">// 此处主要是将P排除在外，让前后块进行连接                 \\</span><br><span class=\"hljs-comment\">        // 下面主要考虑 P 对应的 nextsize 双向链表的修改</span><br>        <span class=\"hljs-keyword\">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \\<br>            <span class=\"hljs-comment\">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span><br>            <span class=\"hljs-comment\">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span><br>            <span class=\"hljs-comment\">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span><br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) {                      \\<br>            <span class=\"hljs-comment\">// 类似于小的 chunk 的检查思路</span><br>            <span class=\"hljs-keyword\">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class=\"hljs-number\">0</span>)              \\<br>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class=\"hljs-number\">0</span>))    \\<br>              malloc_printerr (check_action,                                      \\<br>                               <span class=\"hljs-string\">\"corrupted double-linked list (not small)\"</span>,    \\<br>                               P, AV);                                              \\<br>            <span class=\"hljs-comment\">// 这里说明 P 已经在 nextsize 链表中了。</span><br>            <span class=\"hljs-comment\">// 如果 FD 没有在 nextsize 链表中</span><br>            <span class=\"hljs-keyword\">if</span> (FD-&gt;fd_nextsize == <span class=\"hljs-literal\">NULL</span>) {                                      \\<br>                <span class=\"hljs-comment\">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span><br>                <span class=\"hljs-comment\">// 令 FD 为 nextsize 串起来的</span><br>                <span class=\"hljs-keyword\">if</span> (P-&gt;fd_nextsize == P)                                      \\<br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \\<br>                <span class=\"hljs-keyword\">else</span> {                                                              \\<br>                <span class=\"hljs-comment\">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span><br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \\<br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \\<br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \\<br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \\<br>                  }                                                              \\<br>              } <span class=\"hljs-keyword\">else</span> {                                                              \\<br>                <span class=\"hljs-comment\">// 如果在的话，直接拿走即可</span><br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \\<br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \\<br>              }                                                                      \\<br>          }                                                                       \\<br>      }                                                                              \\<br>}<br></code></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&gt;fd,和P-&gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露</li>\n<li>泄露思路：<ul>\n<li>P 位于双向链表头部，bk 泄漏</li>\n<li>P 位于双向链表尾部，fd 泄漏</li>\n<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）</li>\n</ul>\n</li>\n<li>泄露堆地址<ul>\n<li>P 位于双向链表头部，fd 泄漏</li>\n<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>\n<li>P 位于双向链表尾部，bk 泄漏</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>\n<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>\n<li><strong>堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"init-malloc函数\"><a href=\"#init-malloc函数\" class=\"headerlink\" title=\"_init_malloc函数\"></a>_init_malloc函数</h3><p>该函数是malloc申请内存的底层函数</p>\n<ol>\n<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>\n<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>\n<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>\n<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>\n</ol>\n<ul>\n<li>注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。</li>\n<li>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></li>\n</ul>\n<h2 id=\"堆溢出常见攻击手段\"><a href=\"#堆溢出常见攻击手段\" class=\"headerlink\" title=\"堆溢出常见攻击手段\"></a>堆溢出常见攻击手段</h2><p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016077.png\" alt=\"image-20230625155220102\"></p>\n<h3 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h3><p>​\t堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。</p>\n<h3 id=\"double-free\"><a href=\"#double-free\" class=\"headerlink\" title=\"double free\"></a>double free</h3><p>​\tdouble free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况。在fastibin中使用fd作为单向链表的索引链。double free的成功利用必须要满足下面过程：</p>\n<ul>\n<li>malloc(P)-&gt;free(p)-&gt;free(p)-&gt;malloc(p)-&gt;修改p中fd的内容为target address-&gt;malloc(p) </li>\n<li>最后一次返回的指针指向Target address，直接写入该堆块即可完成</li>\n<li>但是上面过程会检查是否连续两次free了同一块内存，因此需要中间加个chunk free一下。</li>\n</ul>\n<p>放入fastbin的过程会完成fastbin_ptr= p1, p1-&gt;fd = p2, p2-&gt;fd = p1</p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212692.png\" alt=\"image-20240305221155597\"></p>\n<p><img src=\"https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212770.png\" alt=\"image-20240305221209726\"></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/64434547\">https://zhuanlan.zhihu.com/p/64434547</a> </p>\n<p>这里注意，fastbin使用的其实是拉链法存储的chunk，从头部开始向后放的，从fastbin指针后面插入栈。最后fastbin的指针直接指向目标地址，然后malloc的时候就会分配该地址。</p>\n<h3 id=\"unlink-1\"><a href=\"#unlink-1\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。</li>\n<li>注意事项:unlink不发生在<em>fastbin和smallbin</em>中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储</li>\n<li>unlink本身存在一些检查</li>\n</ul>\n<p>unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。</p>\n<p>unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。</p>\n<figure class=\"highlight c\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">FD = p-&gt;fd;<br>BK = p-&gt;bk;<br>FD-&gt;bk = BK;<br>BK-&gt;fd = FD;<br><span class=\"hljs-comment\">// 其实就是传统的双向链表取元素的操作</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t上述操作中，当前块的fd和bk是可以被伪造的。</span><br><span class=\"hljs-comment\">\t假设此刻将两个地址分别重写为got[free], 和shellcode地址</span><br><span class=\"hljs-comment\">\t执行前两条指令后。</span><br><span class=\"hljs-comment\">\tFD = got[free] - 12（32位机器）</span><br><span class=\"hljs-comment\">\tBK = shellcode  // 这里BK要加fd，所以不需要存储</span><br><span class=\"hljs-comment\">\t执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持</span><br><span class=\"hljs-comment\">\t但是这个方法在新版libc里没有用！！！</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></tbody></table></figure>\n\n<p>​\tunlink之前需要进行一些简单的检查，这个检查是可以欺骗的：</p>\n<p>​\tfd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&gt;bk-&gt;fd==p &amp;&amp; p-&gt;fd-&gt;bk==p, 只需要保证满足 fd = &amp;p - 3*size(int); bk = &amp;p - 2*size(int) 即可。</p>\n<p>​\t<strong>也就是说</strong>：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;ptr - 3*size(int); bk = &amp;ptr- 2*size(int) ，在检查的过程中BK-&gt;fd = FD-&gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改</p>\n<h4 id=\"例题-0CTF2015-freenote\"><a href=\"#例题-0CTF2015-freenote\" class=\"headerlink\" title=\"例题 0CTF2015 freenote\"></a>例题 0CTF2015 freenote</h4><p>​\t</p>\n<h3 id=\"fastbin-attack\"><a href=\"#fastbin-attack\" class=\"headerlink\" title=\"fastbin attack\"></a>fastbin attack</h3><h4 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h4><p>fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。</p>\n<h4 id=\"house-of-spirit\"><a href=\"#house-of-spirit\" class=\"headerlink\" title=\"house of spirit\"></a>house of spirit</h4><p><a href=\"https://www.anquanke.com/post/id/85357\">https://www.anquanke.com/post/id/85357</a></p>\n<ul>\n<li>house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构</li>\n<li></li>\n</ul>\n<h3 id=\"tcache-attack\"><a href=\"#tcache-attack\" class=\"headerlink\" title=\"tcache attack\"></a>tcache attack</h3><p>tcache本身是单向链表，并且一个线程对应一个tcache存在。</p>\n<p><a href=\"https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B\">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B</a></p>\n<p><a href=\"https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/\">https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/</a></p>\n<h2 id=\"堆利用例题\"><a href=\"#堆利用例题\" class=\"headerlink\" title=\"堆利用例题\"></a>堆利用例题</h2><p><a href=\"https://www.freebuf.com/articles/system/171261.html\">https://www.freebuf.com/articles/system/171261.html</a></p>\n<h3 id=\"fastbin-dup-into-stack\"><a href=\"#fastbin-dup-into-stack\" class=\"headerlink\" title=\"fastbin_dup_into_stack\"></a>fastbin_dup_into_stack</h3>",
            "tags": [
                "HEAP PWN CTF"
            ]
        }
    ]
}