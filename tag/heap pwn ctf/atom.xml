<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alazymechnaic.github.io</id>
    <title>alazymachine • Posts by &#34;heap pwn ctf&#34; tag</title>
    <link href="https://alazymechnaic.github.io" />
    <updated>2023-05-12T11:47:55.000Z</updated>
    <category term="paper" />
    <category term="fuzz" />
    <category term="arm" />
    <category term="Linux" />
    <category term="C" />
    <category term="go" />
    <category term="Paper" />
    <category term="bypass" />
    <category term="clash" />
    <category term="Hook" />
    <category term="go, RE" />
    <category term="kernel pwn" />
    <category term="binary" />
    <category term="writing" />
    <category term="HEAP PWN CTF" />
    <category term="Android" />
    <category term="dataflow" />
    <category term="pwn" />
    <category term="java" />
    <category term="web" />
    <category term="exploit" />
    <category term="network" />
    <category term="代码分析" />
    <category term="二进制安全" />
    <category term="渗透" />
    <category term="程序分析" />
    <category term="stack overflow" />
    <category term="算法" />
    <entry>
        <id>https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/</id>
        <title>堆溢出利用</title>
        <link rel="alternate" href="https://alazymechnaic.github.io/2023/05/12/dui-yi-chu-li-yong/"/>
        <content type="html">&lt;h1 id=&#34;堆利用&#34;&gt;&lt;a href=&#34;#堆利用&#34; class=&#34;headerlink&#34; title=&#34;堆利用&#34;&gt;&lt;/a&gt;堆利用&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;​	本文用于介绍当前堆管理方式，堆溢出原理，常见的攻击方式及相关例题题解。&lt;/p&gt;
&lt;h2 id=&#34;堆管理机制&#34;&gt;&lt;a href=&#34;#堆管理机制&#34; class=&#34;headerlink&#34; title=&#34;堆管理机制&#34;&gt;&lt;/a&gt;堆管理机制&lt;/h2&gt;&lt;p&gt;​	堆区域与栈区域在内存使用上存在不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆位于当前程序中较低的地址位置，栈位于当前程序中的较高内存空间位置&lt;/li&gt;
&lt;li&gt;堆在使用时从低地址内存向高地址内存增长，栈从高地址内存向低地址内存增长&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆和栈都可以是每个线程所有独有的，堆依然存在线程堆的概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172015938.png&#34; alt=&#34;先知社区https://xz.aliyun.com/t/10650&#34;&gt;&lt;/p&gt;
&lt;p&gt;(上图中的共享库段中包含有不同权限的几个内存段，如下图所示，其中mapped区域是当前so文件代码段对应的heap段)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/HEAP-EXP-heap-management.assets/image-20230613200729790.png&#34; alt=&#34;image-20230613200729790&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内存管理&#34;&gt;&lt;a href=&#34;#内存管理&#34; class=&#34;headerlink&#34; title=&#34;内存管理&#34;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;32位下的text段是即时elf文件装入操作系统的起始位置0x8048000，也就是整个虚拟内存中用户可用的起始位置,最远的访问位置到0xbfffffff.&lt;/li&gt;
&lt;li&gt;64位下的内存起始位置在0x0000000000400000处，64位下总的内存大小为2的48次方，&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存的分配管理策略&#34;&gt;&lt;a href=&#34;#内存的分配管理策略&#34; class=&#34;headerlink&#34; title=&#34;内存的分配管理策略&#34;&gt;&lt;/a&gt;内存的分配管理策略&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;具有较长生命周期的大内存使用mmap进行分配（例如说，在初始化给用户分配堆的过程）&lt;/li&gt;
&lt;li&gt;特别大的内存分配使用的是mmap，&lt;strong&gt;使用mmap申请的内存在释放后并不会放入bin，而是直接还给操作系统，因为这一部分内存块一般都比较大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;短生命周期的内存分配使用brk，因为使用mmap分配的内存块需要多个物理页，浪费资源&lt;/li&gt;
&lt;li&gt;空闲小块是被管理，大内存块和长生命周期块都是直接回收返还给内存&lt;/li&gt;
&lt;li&gt;对于空闲的小内存块只会在malloc和free的时候进行合并，free后的空闲块可能放入pool中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意一点，在程序运行初期会使用brk分配一个内存空间，该内存空间中的内容再被用户进行各种malloc的分配，该分配区域被称作为主分配区，由brk和sbrk两个指针限定边缘。如果当前的heap0中有合适的小内存块就直接分配，但是当使用free时，合并后的chunk大小大于64kb时才会将顶端的空闲内存返回给操作系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;arena分配区机制&#34;&gt;&lt;a href=&#34;#arena分配区机制&#34; class=&#34;headerlink&#34; title=&#34;arena分配区机制&#34;&gt;&lt;/a&gt;arena分配区机制&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;arena就是mmap heap1/heap2等，该分配区一旦产生就不能再减少。每个arena中都使用独立的bin机制来管理当前线程的内存块，&lt;strong&gt;但是如果是单线程程序也可以拥有多个arena&lt;/strong&gt;，多个线程存在时，在malloc后可以使用其他线程的arena来分配内存：&lt;ul&gt;
&lt;li&gt;首先循环遍历所有可用的 &lt;em&gt;arena&lt;/em&gt;，在遍历的过程中，它会尝试加锁该 &lt;em&gt;arena&lt;/em&gt;。如果成功加锁（该 &lt;em&gt;arena&lt;/em&gt; 当前对应的线程并未使用堆内存则表示可加锁），比如将 &lt;em&gt;main arena&lt;/em&gt; 成功锁住，那么就将 &lt;em&gt;main arena&lt;/em&gt; 返回给用户，即表示该 &lt;em&gt;arena&lt;/em&gt; 被子线程 3 共享使用。&lt;/li&gt;
&lt;li&gt;如果没能找到可用的 &lt;em&gt;arena&lt;/em&gt;，那么就将子线程 3 的 &lt;code&gt;malloc&lt;/code&gt; 操作阻塞，直到有可用的 &lt;em&gt;arena&lt;/em&gt; 为止&lt;/li&gt;
&lt;li&gt;现在，如果子线程 3 再次调用 &lt;code&gt;malloc&lt;/code&gt; 的话，&lt;code&gt;glibc&lt;/code&gt; 的 &lt;code&gt;malloc&lt;/code&gt; 就会先尝试使用最近访问的 &lt;em&gt;arena&lt;/em&gt;（此时为 &lt;em&gt;main arena&lt;/em&gt;）。如果此时 &lt;em&gt;main arena&lt;/em&gt; 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 &lt;em&gt;main arena&lt;/em&gt; 再次可用为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在创建非主分配区时会先mmap创建分为一块较大的内存空间来模拟sub-heap（也就是类似主分配区的heap段），当然有heap就有top段的内容，topchunk是永远不会放在bin中的，因为top chunk总是在fast bin与bin之后被考虑。&lt;/li&gt;
&lt;li&gt;每个进程只能有一个主分配区，但有多个非主分配区&lt;ul&gt;
&lt;li&gt;主分配区可以使用brk和mmap两种方式进行内存的分配&lt;/li&gt;
&lt;li&gt;非主分配区只能使用mmap的方式进行内存的分配，但与主分配区相同，都使用链表进行管理&lt;/li&gt;
&lt;li&gt;同样在多线程下，主线程能够使用主分配区，当然其他线程也可以，线程之间对于堆内存的访问是不存在限制的，因此其他线程也是能够释放主线程内存的，但是分配区存在锁机制，对分配区的操作要进行互斥。线程在使用内存时，只能通过先用mmap申请一块大内存（32位默认1MB，64位默认64MB）到用户空间，再使用malloc一点一点分配出去。这个mmap分出来的这块内存就是非主分配区，管理这块内存的就是arena&lt;/li&gt;
&lt;li&gt;可以看到一个线程只能有一个分配区（arena）但是一个arena可以管理多个堆块，主分配区域只需要管理一个堆块就可以了，就是使用brk分配的那个。&lt;/li&gt;
&lt;li&gt;多线程环境下内存的分配与回收：&lt;ul&gt;
&lt;li&gt;查看当前线程下是否存在一个分配区，若存在一个分配区则尝试加锁，进行后续操作；如果加锁失败，则让分配器循环遍历arena，找到没有加锁的arena进行内存的分配操作；若所有的arena都在用，则使用malloc重新开辟一个新的内存空间，构造一个新的分配区；&lt;/li&gt;
&lt;li&gt;当进行内存的释放时，内存所在的分配区被加锁则等待，直到互斥锁被解开之后才能继续使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进一步的，每个arena管理的heap可以抽象成一个在地址上连续的内存片段，内存片段被抽象为无数个chunk未被分配的chunk都视为top chunk，对于已经释放的free chunk部分则会使用一个双向链表进行管理，每次在分配时会遍历这个双向链表选择最合适的内存块，而管理各种不同的空闲块的管理器就是bin机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;堆管理的数据结构&#34;&gt;&lt;a href=&#34;#堆管理的数据结构&#34; class=&#34;headerlink&#34; title=&#34;堆管理的数据结构&#34;&gt;&lt;/a&gt;堆管理的数据结构&lt;/h2&gt;&lt;h3 id=&#34;heap-info&#34;&gt;&lt;a href=&#34;#heap-info&#34; class=&#34;headerlink&#34; title=&#34;heap_info&#34;&gt;&lt;/a&gt;heap_info&lt;/h3&gt;&lt;p&gt;​	一个程序在运行时不只是存在一个主线程的heap，还会存在其他线程的heap（使用mmap申请的heap，使用该线程的arena进行管理），那么这些heap的信息需要使用一个heap_info 的结构进行管理，所以这部分的结构也叫作heap header。&lt;/p&gt;
&lt;p&gt;​	主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 &lt;em&gt;heap&lt;/em&gt; 所以也就不含有 &lt;code&gt;heap_info&lt;/code&gt; 结构体。当需要更多堆空间的时候，直接通过增长 &lt;code&gt;brk&lt;/code&gt; 指针来获取更多的空间，直到它碰到内存映射区域为止&lt;/p&gt;
&lt;p&gt;​	依照该数据结构的情况能够看到：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;heap_info&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-class&#34;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;heap_info&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;prev&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;//指向前一个heap_info结构&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;size_t&lt;/span&gt; size;  &lt;span class=&#34;hljs-comment&#34;&gt;//当前heap_info结构所描述的堆内存大小&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;int&lt;/span&gt; mmaped;  &lt;span class=&#34;hljs-comment&#34;&gt;//标记当前堆内存是否由mmap系统调用分配&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;heap_info&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;//指向后一个heap_info结构&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;arena&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;ar_ptr&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;//指向当前堆内存所在的arena&lt;/span&gt;&lt;br&gt;};&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;malloc-state&#34;&gt;&lt;a href=&#34;#malloc-state&#34; class=&#34;headerlink&#34; title=&#34;malloc_state&#34;&gt;&lt;/a&gt;malloc_state&lt;/h3&gt;&lt;p&gt;&lt;code&gt;malloc_state&lt;/code&gt; 用于表示 &lt;em&gt;arena&lt;/em&gt; 的信息，因此也被称为 &lt;em&gt;arena header&lt;/em&gt;，每个线程只含有一个 &lt;em&gt;arena header&lt;/em&gt;。&lt;em&gt;arena header&lt;/em&gt; 包含 &lt;em&gt;bin&lt;/em&gt;、&lt;em&gt;top chunk&lt;/em&gt; 以及 &lt;em&gt;last remainder chunk&lt;/em&gt; 等信息&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_state&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;binmap_t&lt;/span&gt;     binmap[BINMAPSIZE];  &lt;span class=&#34;hljs-comment&#34;&gt;// 用于标记哪些 bin 是非空的&lt;/span&gt;&lt;br&gt;  mfastbinptr  fastbinsY[NFASTBINS];  &lt;span class=&#34;hljs-comment&#34;&gt;// 用于存放小块内存的链表&lt;/span&gt;&lt;br&gt;  mchunkptr    top;  &lt;span class=&#34;hljs-comment&#34;&gt;// 指向当前 arena 中最后一个已分配的 chunk&lt;/span&gt;&lt;br&gt;  mchunkptr    last_remainder;  &lt;span class=&#34;hljs-comment&#34;&gt;// 指向上一个 arena 中未被使用完的 chunk&lt;/span&gt;&lt;br&gt;  mchunkptr    bins[NBINS * &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; - &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt;];  &lt;span class=&#34;hljs-comment&#34;&gt;// 用于存放各个 bin 中的 chunk&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_state&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;// 指向下一个 malloc_state 结构&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;uint64_t&lt;/span&gt;     magic;  &lt;span class=&#34;hljs-comment&#34;&gt;// 用于检查 malloc_state 结构的完整性&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;uint64_t&lt;/span&gt;     flags;  &lt;span class=&#34;hljs-comment&#34;&gt;// 保存了 malloc_state 的各种状态信息&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;mutex_t&lt;/span&gt;      mutex;  &lt;span class=&#34;hljs-comment&#34;&gt;// 用于保护 malloc_state 结构的互斥锁&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;char&lt;/span&gt; *       seg;  &lt;span class=&#34;hljs-comment&#34;&gt;// 指向当前 arena 的起始地址&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;size_t&lt;/span&gt;       size;  &lt;span class=&#34;hljs-comment&#34;&gt;// 当前 arena 的大小&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-type&#34;&gt;size_t&lt;/span&gt;       mprotect_size;  &lt;span class=&#34;hljs-comment&#34;&gt;// 当前 arena 中已经保护的内存大小&lt;/span&gt;&lt;br&gt;  mchunkptr    mprotect_base;  &lt;span class=&#34;hljs-comment&#34;&gt;// 当前 arena 中已经保护的内存的起始地址&lt;/span&gt;&lt;br&gt;  mchunkptr    last_remainder;  &lt;span class=&#34;hljs-comment&#34;&gt;// 上一个 arena 中未被使用完的 chunk&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;heap_info&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;heap_info&lt;/span&gt;;&lt;/span&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;// 当前 arena 所在的 heap_info 结构&lt;/span&gt;&lt;br&gt;};&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h3 id=&#34;chunk的组织形式&#34;&gt;&lt;a href=&#34;#chunk的组织形式&#34; class=&#34;headerlink&#34; title=&#34;chunk的组织形式&#34;&gt;&lt;/a&gt;chunk的组织形式&lt;/h3&gt;&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_chunk&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;/* #define INTERNAL_SIZE_T size_t */&lt;/span&gt;&lt;br&gt;  INTERNAL_SIZE_T      prev_size;  &lt;span class=&#34;hljs-comment&#34;&gt;/* 记录前一个chunk的大小，如果前一个chunk是free状态，此字段依然有用 ,而且该size的计算并不不包含前一个chunk的chunk头*/&lt;/span&gt;&lt;br&gt;  INTERNAL_SIZE_T      size;       &lt;span class=&#34;hljs-comment&#34;&gt;/* 指向在bin中时前一个chunk和后一个chunk的位置，因此只有空闲状态的chunk使用 */&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&#34;hljs-title&#34;&gt;fd&lt;/span&gt;;&lt;/span&gt;    &lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&#34;hljs-title&#34;&gt;bk&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;/* 上下这两个指针占用相同的空间 区别在于当前chunk是free的时候*/&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-comment&#34;&gt;/* Only used for large blocks: pointer to next larger size.  */&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&#34;hljs-title&#34;&gt;fd_nextsize&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;hljs-comment&#34;&gt;/* double links -- used only if free. */&lt;/span&gt;&lt;br&gt;  &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_chunk&lt;/span&gt;* &lt;span class=&#34;hljs-title&#34;&gt;bk_nextsize&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;};&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;chunk在32位下的8字节对齐，在64位下的16字节对齐，因此allocater返回的chunk要比实际需要的稍大一些&lt;/li&gt;
&lt;li&gt;基本的chunk分配策略是首先在先前释放的chunk中找到合适的，如果没有择取heap区域的chunk&lt;/li&gt;
&lt;li&gt;如果上面的方法均不成功，则会去要求系统新分配一块内存mmap方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;已分配chunk的数据结构情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016938.png&#34; alt=&#34;image-20230613234305496&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未分配的chunk数据结构情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016286.png&#34; alt=&#34;image-20230613234401273&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	在上面能够很明显的看到chunk在使用状态下原本存放fd和bk的位置会被直接用来存放用户数据。用户在使用malloc时返回的内存指针是指向chunk头后面的部分，在free后指向的fd的存放位置。&lt;/p&gt;
&lt;p&gt;​	这里的p是标志前一个chunk（地址更小的）是否处于被使用的状态，如果是则置位1，且prev_size有效（标志相邻的堆块大小，这里是指物理上相邻，主要用于进行内存块的合并操作，&lt;strong&gt;且prev_size的大小指的是包含当前块头部和用户数据的部分&lt;/strong&gt;）&lt;/p&gt;
&lt;figure class=&#34;highlight apache&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs apache&#34;&gt;&lt;span class=&#34;hljs-attribute&#34;&gt;N&lt;/span&gt;：是不是「主分配区」分配的内存 &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; 表示不是主分配区分配的，&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; 表示是主分配区分配的&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-attribute&#34;&gt;M&lt;/span&gt;：是不是 Memory Mapped 分配的内存，&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt; 表示是，&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt; 表示是 heap&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-attribute&#34;&gt;P&lt;/span&gt;：表示前一个 chunk 是否在使用，在初始化的时候通常为 &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;，防止使用不能访问的内存&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&#34;https://www.freebuf.com/articles/system/171261.html&#34;&gt;https://www.freebuf.com/articles/system/171261.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Breeze_CAT/article/details/103788698&#34;&gt;https://blog.csdn.net/Breeze_CAT/article/details/103788698&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcache（thread-local-caching）机制&#34;&gt;&lt;a href=&#34;#tcache（thread-local-caching）机制&#34; class=&#34;headerlink&#34; title=&#34;tcache（thread local caching）机制&#34;&gt;&lt;/a&gt;tcache（thread local caching）机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tcache&lt;/code&gt;属于一种缓存机制，它为每一个线程创建了一个缓存，从而实现了不加锁的堆块分配算法，起到了性能提升的作用。&lt;/li&gt;
&lt;li&gt;仅适用于glibc2.26以上的版本使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bin机制&#34;&gt;&lt;a href=&#34;#Bin机制&#34; class=&#34;headerlink&#34; title=&#34;Bin机制&#34;&gt;&lt;/a&gt;Bin机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ptmalloc 一共维护128个bin，使用数组存储链表头，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fast bin&lt;/strong&gt;：fastbin是一些要被系统回收的较小的内存块，此类内存块使用一个&lt;strong&gt;单向链表&lt;/strong&gt;进行存储，该bin中的所有chunk都不会被合并。内存分配时会先在fastbins中进行查找，随后才会在其他bin中进行查找。（chunksize &amp;lt; maxsize时才会被放在fastbin中）采用先进先出标准进行管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;small bin&lt;/strong&gt;：专门存放size&amp;lt;512的chunk，使用双向链表进行存储（也就是之前所说的拉链法存储），数组中的每个元素是chunk链的头，只有相同大小的bin能被存在一个链里，每个链之间相差8byte。共有62个循环双向链表。small bin与fast bin的某些大小是重合的，因此有些可以放入fastbin的块也可以在smallbin&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;large bin&lt;/strong&gt;：需要对bin中的chunk按照大小进行排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsorted bin&lt;/strong&gt;：可以将其视为一个bin在回归其正确的所属bin之前的一个缓存，在释放一个不符合fast bin要求的chunk时会被先放入到unsorted bin中进行存储，同理，在进行chunk的切割后，剩余的某个部分是不合fast bin要求的则会将其放入unsorted bin中进行存储。与一般的bin不同之处在于，unsorted bin其本身只有一个。&lt;ul&gt;
&lt;li&gt;当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;fastchunk中的某些bin合并后大于fast bin的要求，那就先放入usorted bin等待后续的处理。&lt;/li&gt;
&lt;li&gt;unsorted bin在使用的过程中是FIFO的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Top Chunk&lt;/strong&gt;：Topchunk其实是在用户进行首次malloc时使用的内存，一部分给用户，一部分留给了Topchunk，当所有的bin都没有符合所需大小的时候，才会去动Top chunk，Top chunk的prevsize永远为1，否则前面的chunk就会被合并到Top Chunk中（也就是说链表中的前一个chunk始终不会被合并到top chunk中去），其实根据上面的过程不难发现，&lt;strong&gt;初始状态下的UNsorted chunk 就是 Top chunk&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;last reminder：其实就是经过malloc分配后切割出来的一块，这一块会放进unsorted bin中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;Bin运作流程&#34;&gt;&lt;a href=&#34;#Bin运作流程&#34; class=&#34;headerlink&#34; title=&#34;Bin运作流程&#34;&gt;&lt;/a&gt;Bin运作流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果被用户释放的chunk大于max_fast，或者fast bins中的空闲chunk合并后，这些chunk首先会被放到unsorted bin队列中&lt;/li&gt;
&lt;li&gt;在进行malloc操作的时候，如果在fast bins中没有找到合适的chunk，则ptmalloc会先在unsorted bin中查找合适的空闲chunk，然后才查找bins。&lt;/li&gt;
&lt;li&gt;如果unsorted bin不能满足分配要求。malloc便会将unsorted bin中的chunk加入bins中。然后再从bins中继续进行查找和分配过程。&lt;/li&gt;
&lt;li&gt;unsorted bin可以看做是bins的一个缓冲区，增加它只是为了加快分配的速度。&lt;/li&gt;
&lt;li&gt;在size&amp;gt;FASTBIM_CONNSOLIDATION_THRESHOLD,时(需要大chunk时)，ptmalloc会遍历fast bins中的chunk，将相邻的空闲chunk进行合并，并将合并后的chunk加入unsorted bin中，然后再将usorted bin里的chunk加入bins中。&lt;br&gt;Unsorted Bin&lt;/li&gt;
&lt;li&gt;空闲的chunk连入bin时,会将 P 设为 0 , 并检查前后chunk是否空闲,若空闲则合并后加入unsorted bins中&lt;/li&gt;
&lt;li&gt;当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。&lt;/li&gt;
&lt;li&gt;当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话&lt;/li&gt;
&lt;li&gt;分配过程：fastbin-&amp;gt;unsorted bin-&amp;gt;其他bins-&amp;gt;切割top chunk&lt;/li&gt;
&lt;li&gt;回收过程：&lt;ul&gt;
&lt;li&gt;在maped区域，直接回收即可&lt;/li&gt;
&lt;li&gt;在heap区域：首先检查当前堆块是否符合fastbin的要求，如果不符合就将其先放入到unsorted bin中等待后续的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;各个bin的处理先后顺序&#34;&gt;&lt;a href=&#34;#各个bin的处理先后顺序&#34; class=&#34;headerlink&#34; title=&#34;各个bin的处理先后顺序&#34;&gt;&lt;/a&gt;各个bin的处理先后顺序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;fastbin 是 LIFO (后入先出)&lt;/li&gt;
&lt;li&gt;unsorted bin是 FIFO (先进先出)&lt;/li&gt;
&lt;li&gt;small bin 是 FIFO&lt;/li&gt;
&lt;li&gt;large bin 是 FIFO&lt;/li&gt;
&lt;li&gt;tcache 是 LIFO&lt;/li&gt;
&lt;li&gt;实际利用时只要知道fastbin为了加快速度学习了栈的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程堆&#34;&gt;&lt;a href=&#34;#线程堆&#34; class=&#34;headerlink&#34; title=&#34;线程堆&#34;&gt;&lt;/a&gt;线程堆&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个线程在创建之初是会先申请一大块堆，使用heap_info结构对其进行记录，所有的heap通过单链表进行连接。一个线程可以有多个堆（其实就是初始分配的不够用），由于线程只能使用mmap，后续的堆要使用pre指针将heap_info进行连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;malloc-state-1&#34;&gt;&lt;a href=&#34;#malloc-state-1&#34; class=&#34;headerlink&#34; title=&#34;malloc_state&#34;&gt;&lt;/a&gt;malloc_state&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。&lt;/li&gt;
&lt;li&gt;无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_state&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Serialize access.  */&lt;/span&gt;&lt;br&gt;    __libc_lock_define(, mutex);&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Flags (formerly in max_fast).  */&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-type&#34;&gt;int&lt;/span&gt; flags;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Fastbins */&lt;/span&gt;&lt;br&gt;    mfastbinptr fastbinsY[ NFASTBINS ];&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Base of the topmost chunk -- not otherwise kept in a bin */&lt;/span&gt;&lt;br&gt;    mchunkptr top;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* The remainder from the most recent split of a small request */&lt;/span&gt;&lt;br&gt;    mchunkptr last_remainder;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Normal bins packed as described above */&lt;/span&gt;&lt;br&gt;    mchunkptr bins[ NBINS * &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; - &lt;span class=&#34;hljs-number&#34;&gt;2&lt;/span&gt; ];&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-type&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;hljs-type&#34;&gt;int&lt;/span&gt; binmap[ BINMAPSIZE ];&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Linked list, points to the next arena */&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_state&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Linked list for free arenas.  Access to this field is serialized&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;       by free_list_lock in arena.c.  */&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;malloc_state&lt;/span&gt; *&lt;span class=&#34;hljs-title&#34;&gt;next_free&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Number of threads attached to this arena.  0 if the arena is on&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;       the free list.  Access to this field is serialized by&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;       free_list_lock in arena.c.  */&lt;/span&gt;&lt;br&gt;    INTERNAL_SIZE_T attached_threads;&lt;br&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;/* Memory allocated from the system in this arena.  */&lt;/span&gt;&lt;br&gt;    INTERNAL_SIZE_T system_mem;&lt;br&gt;    INTERNAL_SIZE_T max_system_mem;&lt;br&gt;};&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&#34;堆管理函数&#34;&gt;&lt;a href=&#34;#堆管理函数&#34; class=&#34;headerlink&#34; title=&#34;堆管理函数&#34;&gt;&lt;/a&gt;堆管理函数&lt;/h2&gt;&lt;h3 id=&#34;libc-malloc&#34;&gt;&lt;a href=&#34;#libc-malloc&#34; class=&#34;headerlink&#34; title=&#34;libc_malloc&#34;&gt;&lt;/a&gt;libc_malloc&lt;/h3&gt;&lt;p&gt;​	malloc函数的本质是libc_malloc, 该函数其实也是对_int_malloc函数做一个封装操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户申请的字节一旦进入libc_malloc会转换为无符号整数&lt;/strong&gt;，同时在源码中能看到其中包含一个对于malloc_hook函数指针的调用，是便于用于进行自定义的malloc函数的编写。&lt;/p&gt;
&lt;h3 id=&#34;unlink&#34;&gt;&lt;a href=&#34;#unlink&#34; class=&#34;headerlink&#34; title=&#34;unlink&#34;&gt;&lt;/a&gt;unlink&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;作用：将一个chunk从双向链表中取出来，其实就是解链操作，因此该函数的使用十分频繁。&lt;/li&gt;
&lt;li&gt;使用场景：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;malloc&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;从恰好大小合适的 large bin 中获取 chunk。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这里需要注意的是 fastbin 就没有使用 unlink，fastbin是单链表	。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依次遍历处理 unsorted bin 时也没有使用 unlink&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从比请求的 chunk 所在的large bin 中取 chunk。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;free&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;后向合并，合并物理相邻低地址空闲 chunk。&lt;/li&gt;
&lt;li&gt;前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;malloc_consolidate&lt;/strong&gt;：用于合并的时候要把空闲块取出来先。&lt;ul&gt;
&lt;li&gt;后向合并，合并物理相邻低地址空闲 chunk。&lt;/li&gt;
&lt;li&gt;前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;realloc&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;&lt;span class=&#34;hljs-comment&#34;&gt;/* Take a chunk off a bin list */&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// unlink p&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-meta&#34;&gt;#&lt;span class=&#34;hljs-keyword&#34;&gt;define&lt;/span&gt; unlink(AV, P, BK, FD) {  &lt;span class=&#34;hljs-comment&#34;&gt;//这里FD是前面的chunk，BK是后面的chunk,传入的BK和FD是空指针          \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;&lt;span class=&#34;hljs-meta&#34;&gt;    // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;// 这两个位置分别是下一个chunk的prevsize和他自己记录的chunksize大小&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;))      \&lt;br&gt;      malloc_printerr (&lt;span class=&#34;hljs-string&#34;&gt;&#34;corrupted size vs. prev_size&#34;&lt;/span&gt;);               \&lt;br&gt;    FD = P-&amp;gt;fd;                                                                      \&lt;br&gt;    BK = P-&amp;gt;bk;                                                                      \&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;// 此处才真正的取出FD和BK两个chunk块&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。&lt;/span&gt;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (__builtin_expect (FD-&amp;gt;bk != P || BK-&amp;gt;fd != P, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;))                    \ &lt;span class=&#34;hljs-comment&#34;&gt;// 看看取出的目标块是不是真正的目标&lt;/span&gt;&lt;br&gt;      malloc_printerr (check_action, &lt;span class=&#34;hljs-string&#34;&gt;&#34;corrupted double-linked list&#34;&lt;/span&gt;, P, AV);  \&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {                                                                      \&lt;br&gt;        FD-&amp;gt;bk = BK;                                                              \&lt;br&gt;        BK-&amp;gt;fd = FD;   &lt;span class=&#34;hljs-comment&#34;&gt;// 此处主要是将P排除在外，让前后块进行连接                 \&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;        // 下面主要考虑 P 对应的 nextsize 双向链表的修改&lt;/span&gt;&lt;br&gt;        &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (!in_smallbin_range (chunksize_nomask (P))                              \&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 如果P-&amp;gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。&lt;/span&gt;&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 那么其实也就没有必要对 nextsize 字段进行修改了。&lt;/span&gt;&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 这里没有去判断 bk_nextsize 字段，可能会出问题。&lt;/span&gt;&lt;br&gt;            &amp;amp;&amp;amp; __builtin_expect (P-&amp;gt;fd_nextsize != &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)) {                      \&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 类似于小的 chunk 的检查思路&lt;/span&gt;&lt;br&gt;            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (__builtin_expect (P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize != P, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)              \&lt;br&gt;                || __builtin_expect (P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize != P, &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;))    \&lt;br&gt;              malloc_printerr (check_action,                                      \&lt;br&gt;                               &lt;span class=&#34;hljs-string&#34;&gt;&#34;corrupted double-linked list (not small)&#34;&lt;/span&gt;,    \&lt;br&gt;                               P, AV);                                              \&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 这里说明 P 已经在 nextsize 链表中了。&lt;/span&gt;&lt;br&gt;            &lt;span class=&#34;hljs-comment&#34;&gt;// 如果 FD 没有在 nextsize 链表中&lt;/span&gt;&lt;br&gt;            &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (FD-&amp;gt;fd_nextsize == &lt;span class=&#34;hljs-literal&#34;&gt;NULL&lt;/span&gt;) {                                      \&lt;br&gt;                &lt;span class=&#34;hljs-comment&#34;&gt;// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P&lt;/span&gt;&lt;br&gt;                &lt;span class=&#34;hljs-comment&#34;&gt;// 令 FD 为 nextsize 串起来的&lt;/span&gt;&lt;br&gt;                &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (P-&amp;gt;fd_nextsize == P)                                      \&lt;br&gt;                  FD-&amp;gt;fd_nextsize = FD-&amp;gt;bk_nextsize = FD;                      \&lt;br&gt;                &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {                                                              \&lt;br&gt;                &lt;span class=&#34;hljs-comment&#34;&gt;// 否则我们需要将 FD 插入到 nextsize 形成的双链表中&lt;/span&gt;&lt;br&gt;                    FD-&amp;gt;fd_nextsize = P-&amp;gt;fd_nextsize;                              \&lt;br&gt;                    FD-&amp;gt;bk_nextsize = P-&amp;gt;bk_nextsize;                              \&lt;br&gt;                    P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize = FD;                              \&lt;br&gt;                    P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = FD;                              \&lt;br&gt;                  }                                                              \&lt;br&gt;              } &lt;span class=&#34;hljs-keyword&#34;&gt;else&lt;/span&gt; {                                                              \&lt;br&gt;                &lt;span class=&#34;hljs-comment&#34;&gt;// 如果在的话，直接拿走即可&lt;/span&gt;&lt;br&gt;                P-&amp;gt;fd_nextsize-&amp;gt;bk_nextsize = P-&amp;gt;bk_nextsize;                      \&lt;br&gt;                P-&amp;gt;bk_nextsize-&amp;gt;fd_nextsize = P-&amp;gt;fd_nextsize;                      \&lt;br&gt;              }                                                                      \&lt;br&gt;          }                                                                       \&lt;br&gt;      }                                                                              \&lt;br&gt;}&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;注意：以上操作有个Bug、就是其只是对P前后的内容进行了处理，也就是只对链进行了处理，但是并没有对P本身这个块进行任何的处理。也就是P-&amp;gt;fd,和P-&amp;gt;bk两个指针中还是存储着地址值的。因此可以利用这个地址进行libc地址的泄露&lt;/li&gt;
&lt;li&gt;泄露思路：&lt;ul&gt;
&lt;li&gt;P 位于双向链表头部，bk 泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表尾部，fd 泄漏&lt;/li&gt;
&lt;li&gt;双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏（啥意思？双向链表的起始地址，及时libc的地址吗？？）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;泄露堆地址&lt;ul&gt;
&lt;li&gt;P 位于双向链表头部，fd 泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表中，fd 和 bk 均可以泄漏&lt;/li&gt;
&lt;li&gt;P 位于双向链表尾部，bk 泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意：&lt;ul&gt;
&lt;li&gt;这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。&lt;/li&gt;
&lt;li&gt;这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;init-malloc函数&#34;&gt;&lt;a href=&#34;#init-malloc函数&#34; class=&#34;headerlink&#34; title=&#34;_init_malloc函数&#34;&gt;&lt;/a&gt;_init_malloc函数&lt;/h3&gt;&lt;p&gt;该函数是malloc申请内存的底层函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它根据用户申请的&lt;strong&gt;内存块大小&lt;/strong&gt;以及&lt;strong&gt;相应大小 chunk 通常使用的频度&lt;/strong&gt;（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。&lt;/li&gt;
&lt;li&gt;它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。&lt;/li&gt;
&lt;li&gt;当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。&lt;/li&gt;
&lt;li&gt;当 top chunk 也无法满足时，堆分配器才会进行内存块申请。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;注意一点，所有的数据进入malloc之后全部都会被转化为无符号整数。&lt;/li&gt;
&lt;li&gt;当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。&lt;strong&gt;为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;堆溢出常见攻击手段&#34;&gt;&lt;a href=&#34;#堆溢出常见攻击手段&#34; class=&#34;headerlink&#34; title=&#34;堆溢出常见攻击手段&#34;&gt;&lt;/a&gt;堆溢出常见攻击手段&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202309172016077.png&#34; alt=&#34;image-20230625155220102&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;堆溢出&#34;&gt;&lt;a href=&#34;#堆溢出&#34; class=&#34;headerlink&#34; title=&#34;堆溢出&#34;&gt;&lt;/a&gt;堆溢出&lt;/h3&gt;&lt;p&gt;​	堆溢出的本质可以类比栈溢出的内容，堆溢出的本质是从用户缓冲区向下溢出到下一个堆块中，如果溢出长度够长，甚至能够重写下一个堆块中的内容。&lt;/p&gt;
&lt;h3 id=&#34;double-free&#34;&gt;&lt;a href=&#34;#double-free&#34; class=&#34;headerlink&#34; title=&#34;double free&#34;&gt;&lt;/a&gt;double free&lt;/h3&gt;&lt;p&gt;​	double free漏洞的本质是将当前对应块的指针做二次的free操作。对同一个块进行两次free操作，则该块会被加入到bin链两次，那么在后续进行多次malloc时会出现指针相同的情况。在fastibin中使用fd作为单向链表的索引链。double free的成功利用必须要满足下面过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;malloc(P)-&amp;gt;free(p)-&amp;gt;free(p)-&amp;gt;malloc(p)-&amp;gt;修改p中fd的内容为target address-&amp;gt;malloc(p) &lt;/li&gt;
&lt;li&gt;最后一次返回的指针指向Target address，直接写入该堆块即可完成&lt;/li&gt;
&lt;li&gt;但是上面过程会检查是否连续两次free了同一块内存，因此需要中间加个chunk free一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;放入fastbin的过程会完成fastbin_ptr= p1, p1-&amp;gt;fd = p2, p2-&amp;gt;fd = p1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212692.png&#34; alt=&#34;image-20240305221155597&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://alazymechnaic.oss-cn-hangzhou.aliyuncs.com/blog-page/202403052212770.png&#34; alt=&#34;image-20240305221209726&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/64434547&#34;&gt;https://zhuanlan.zhihu.com/p/64434547&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这里注意，fastbin使用的其实是拉链法存储的chunk，从头部开始向后放的，从fastbin指针后面插入栈。最后fastbin的指针直接指向目标地址，然后malloc的时候就会分配该地址。&lt;/p&gt;
&lt;h3 id=&#34;unlink-1&#34;&gt;&lt;a href=&#34;#unlink-1&#34; class=&#34;headerlink&#34; title=&#34;unlink&#34;&gt;&lt;/a&gt;unlink&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;unlink的作用是将free时，操作双向链表中相邻的两个free chunk进行合并操作。&lt;/li&gt;
&lt;li&gt;注意事项:unlink不发生在&lt;em&gt;fastbin和smallbin&lt;/em&gt;中,所以fastbin和smallbin容易产生漏洞。fastbin使用单向链表进行存储&lt;/li&gt;
&lt;li&gt;unlink本身存在一些检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;unlink首先检查当前内存空间中该块的相邻块是否空闲，并且检查当前的块大小和下一个块记录的prev_size大小是否相同，如果空闲则进行合并操作。&lt;/p&gt;
&lt;p&gt;unlink的代码中实现的操作就是将当前程序中的某个chunk从双向链表中取出来，下面的代码以当前要取出的块是p为例。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c&#34;&gt;FD = p-&amp;gt;fd;&lt;br&gt;BK = p-&amp;gt;bk;&lt;br&gt;FD-&amp;gt;bk = BK;&lt;br&gt;BK-&amp;gt;fd = FD;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;// 其实就是传统的双向链表取元素的操作&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	上述操作中，当前块的fd和bk是可以被伪造的。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	假设此刻将两个地址分别重写为got[free], 和shellcode地址&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	执行前两条指令后。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	FD = got[free] - 12（32位机器）&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	BK = shellcode  // 这里BK要加fd，所以不需要存储&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	执行第三条指令，将got表中的地址写为shellcode地址，从而实现got表劫持&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;	但是这个方法在新版libc里没有用！！！&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​	unlink之前需要进行一些简单的检查，这个检查是可以欺骗的：&lt;/p&gt;
&lt;p&gt;​	fd的偏移是3个机器位数，bk的偏移是4个机器位数。即在64位机器上，fd是8*3=24字节，bk是8*4=32字节；32位机器上，fd是4 *3 =12字节，bk是4*4=16字节。设伪空闲堆块的堆块头指针是p，那么需要检查：p-&amp;gt;bk-&amp;gt;fd==p &amp;amp;&amp;amp; p-&amp;gt;fd-&amp;gt;bk==p, 只需要保证满足 fd = &amp;amp;p - 3*size(int); bk = &amp;amp;p - 2*size(int) 即可。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;也就是说&lt;/strong&gt;：在新版的glibc中，使用另一种思路，依赖于一个UAF漏洞，对一个已经free的堆块进行修改。假设想要修改的内存是ptr，那么就修改这p中fd = &amp;amp;ptr - 3*size(int); bk = &amp;amp;ptr- 2*size(int) ，在检查的过程中BK-&amp;gt;fd = FD-&amp;gt;BK = ptr。 最终在执行完unlink操作后，ptr变为了ptr-0x18（其实也就是最后一条指令的作用），但是同样新版的unlink也会修改&lt;/p&gt;
&lt;h4 id=&#34;例题-0CTF2015-freenote&#34;&gt;&lt;a href=&#34;#例题-0CTF2015-freenote&#34; class=&#34;headerlink&#34; title=&#34;例题 0CTF2015 freenote&#34;&gt;&lt;/a&gt;例题 0CTF2015 freenote&lt;/h4&gt;&lt;p&gt;​	&lt;/p&gt;
&lt;h3 id=&#34;fastbin-attack&#34;&gt;&lt;a href=&#34;#fastbin-attack&#34; class=&#34;headerlink&#34; title=&#34;fastbin attack&#34;&gt;&lt;/a&gt;fastbin attack&lt;/h3&gt;&lt;h4 id=&#34;攻击原理&#34;&gt;&lt;a href=&#34;#攻击原理&#34; class=&#34;headerlink&#34; title=&#34;攻击原理&#34;&gt;&lt;/a&gt;攻击原理&lt;/h4&gt;&lt;p&gt;fastbin是一种简单的单向链表，用于存储大小小于等于0x80（默认情况下）的已经释放的堆块。Fastbin attack的基本原理是利用fastbin链表的机制，通过伪造堆块的头部，使得堆分配器将伪造的堆块地址返回给程序，从而控制被释放的堆块的指针。攻击者可以通过覆盖被释放的堆块的指针，实现任意地址写或者控制流劫持。&lt;/p&gt;
&lt;h4 id=&#34;house-of-spirit&#34;&gt;&lt;a href=&#34;#house-of-spirit&#34; class=&#34;headerlink&#34; title=&#34;house of spirit&#34;&gt;&lt;/a&gt;house of spirit&lt;/h4&gt;&lt;p&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/85357&#34;&gt;https://www.anquanke.com/post/id/85357&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;house of sporit与double free存在相似之处，二者的区别free掉的块一个指向真正被malloc的过的内存，而另一个则是构造一个完全虚假的内存块，并且包含精心构造的chunk数据结构&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcache-attack&#34;&gt;&lt;a href=&#34;#tcache-attack&#34; class=&#34;headerlink&#34; title=&#34;tcache attack&#34;&gt;&lt;/a&gt;tcache attack&lt;/h3&gt;&lt;p&gt;tcache本身是单向链表，并且一个线程对应一个tcache存在。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B&#34;&gt;https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.14_glibc_tcache.html#ctf-%E5%AE%9E%E4%BE%8B&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/&#34;&gt;https://v1ckydxp.github.io/2019/06/30/Tcache-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;堆利用例题&#34;&gt;&lt;a href=&#34;#堆利用例题&#34; class=&#34;headerlink&#34; title=&#34;堆利用例题&#34;&gt;&lt;/a&gt;堆利用例题&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://www.freebuf.com/articles/system/171261.html&#34;&gt;https://www.freebuf.com/articles/system/171261.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;fastbin-dup-into-stack&#34;&gt;&lt;a href=&#34;#fastbin-dup-into-stack&#34; class=&#34;headerlink&#34; title=&#34;fastbin_dup_into_stack&#34;&gt;&lt;/a&gt;fastbin_dup_into_stack&lt;/h3&gt;</content>
        <category term="HEAP PWN CTF" />
        <updated>2023-05-12T11:47:55.000Z</updated>
    </entry>
</feed>
